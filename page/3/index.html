<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="正忙着优秀~~~"><meta name="keywords" content><meta name="author" content="YoungDream,undefined"><meta name="copyright" content="YoungDream"><title>小小搬砖工【YD Blog】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon-16x16-user.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!--link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!--link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!--script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"0BGAOITLJQ","apiKey":"2c864a8b4720c83c2ddfc7e53d4c1711","indexName":"article_NAME","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/user.jpg"></div><div class="author-info-name">YoungDream</div><div class="author-info-description">正忙着优秀~~~</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/qq994300880" target="_blank">GitHub<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="http://wpa.qq.com/msgrd?v=3&amp;uin=994300880&amp;site=qq&amp;menu=yes" target="_blank">QQ<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">47</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">57</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">5</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">YD Blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-WebClient/">使用SpringBoot-WebClient</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/rest/">rest</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/webflux/">webflux</a></div></div><div class="post-content"><div class="main-content content"><h1 id="WebClient"><a href="#WebClient" class="headerlink" title="WebClient"></a>WebClient</h1><p>如果在类路径上有Spring WebFlux，则还可以选择<code>WebClient</code>用于调用远程REST服务。相比之下<code>RestTemplate</code>，这个客户端具有更多的功能感并且完全被动。您可以<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client" target="_blank" rel="noopener">在Spring Framework文档</a><code>WebClient</code>的专用 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client" target="_blank" rel="noopener">部分中</a>了解有关该内容的更多信息。</p>
<p>Spring Boot <code>WebClient.Builder</code>为您创建并预配置一个; 强烈建议将其注入组件并使用它来创建<code>WebClient</code>实例。Spring Boot正在配置该构建器以共享HTTP资源，以与服务器相同的方式反映编解码器设置（请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webflux-httpcodecs" target="_blank" rel="noopener">WebFlux HTTP编解码器自动配置</a>）等。</p>
<p>以下代码显示了一个典型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebClient.Builder webClientBuilder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.webClient = webClientBuilder.baseUrl(<span class="string">"http://example.org"</span>).build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;Details&gt; <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.webClient.get().uri(<span class="string">"/&#123;name&#125;/details"</span>, name)</span><br><span class="line">						.retrieve().bodyToMono(Details.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WebClient运行时"><a href="#WebClient运行时" class="headerlink" title="WebClient运行时"></a>WebClient运行时</h2><p>Spring Boot将自动检测<code>ClientHttpConnector</code>用于驱动的驱动程序<code>WebClient</code>，具体取决于应用程序类路径上可用的库。目前，支持Reactor Netty和Jetty RS客户端。</p>
<p>在<code>spring-boot-starter-webflux</code>启动依赖于<code>io.projectreactor.netty:reactor-netty</code> 默认情况下，这使服务器和客户端的实现。如果您选择将Jetty用作反应式服务器，则应该在Jetty Reactive HTTP客户端库上添加依赖项<code>org.eclipse.jetty:jetty-reactive-httpclient</code>。对服务器和客户端使用相同的技术具有优势，因为它将自动在客户端和服务器之间共享HTTP资源。</p>
<p>开发人员可以通过提供自定义<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>bean 来覆盖Jetty和Reactor Netty的资源配置- 这将应用于客户端和服务器。</p>
<p>如果您希望覆盖客户端的该选项，则可以定义自己的 <code>ClientHttpConnector</code>bean并完全控制客户端配置。</p>
<p>您可以<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder" target="_blank" rel="noopener"><code>WebClient</code>在Spring Framework参考文档中</a>了解有关<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder" target="_blank" rel="noopener">配置选项的</a>更多信息 。</p>
<h2 id="WebClient自定义"><a href="#WebClient自定义" class="headerlink" title="WebClient自定义"></a>WebClient自定义</h2><p><code>WebClient</code>自定义有三种主要方法，具体取决于您希望自定义应用的广泛程度。</p>
<p>要使任何自定义的范围尽可能窄，请注入自动配置 <code>WebClient.Builder</code>，然后根据需要调用其方法。<code>WebClient.Builder</code>实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有客户端中。如果要使用相同的构建器创建多个客户端，还可以考虑使用克隆构建器<code>WebClient.Builder other = builder.clone();</code>。</p>
<p>要对所有<code>WebClient.Builder</code>实例进行应用程序范围的附加自定义，您可以声明<code>WebClientCustomizer</code>bean并<code>WebClient.Builder</code>在注入点更改本地。</p>
<p>最后，您可以回退到原始API并使用<code>WebClient.create()</code>。在这种情况下，不会自动配置或<code>WebClientCustomizer</code>应用。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-WebClient/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-RestTemplate/">使用SpringBoot-RestTemplate</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/rest/">rest</a></div></div><div class="post-content"><div class="main-content content"><h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p>如果需要从应用程序调用远程REST服务，可以使用Spring Framework的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener"><code>RestTemplate</code></a>类。由于 <code>RestTemplate</code>实例在使用之前通常需要自定义，因此Spring Boot不提供任何单个自动配置的<code>RestTemplate</code>bean。但是，它会自动配置a <code>RestTemplateBuilder</code>，可用于<code>RestTemplate</code> 在需要时创建实例。自动配置<code>RestTemplateBuilder</code>可确保将敏感 <code>HttpMessageConverters</code>应用于<code>RestTemplate</code>实例。</p>
<p>以下代码显示了一个典型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Details <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"/&#123;name&#125;/details"</span>, Details.class, name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>RestTemplateBuilder</code>包括许多可用于快速配置a的有用方法<code>RestTemplate</code>。例如，要添加BASIC auth支持，您可以使用<code>builder.basicAuthentication(&quot;user&quot;, &quot;password&quot;).build()</code>。</p>
</blockquote>
<h2 id="RestTemplate自定义"><a href="#RestTemplate自定义" class="headerlink" title="RestTemplate自定义"></a>RestTemplate自定义</h2><p><code>RestTemplate</code>自定义有三种主要方法，具体取决于您希望自定义应用的广泛程度。</p>
<p>要使任何自定义的范围尽可能窄，请注入自动配置 <code>RestTemplateBuilder</code>，然后根据需要调用其方法。每个方法调用都返回一个新<code>RestTemplateBuilder</code>实例，因此自定义只会影响构建器的这种使用。</p>
<p>要进行应用程序范围的附加定制，请使用<code>RestTemplateCustomizer</code>bean。所有这些bean都自动注册自动配置<code>RestTemplateBuilder</code> ，并应用于使用它构建的任何模板。</p>
<p>以下示例显示了一个自定义程序，它为所有主机配置代理的使用，但<code>192.168.0.5</code>以下情况除外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">		HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">"proxy.example.com"</span>);</span><br><span class="line">		HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">				.setRoutePlanner(<span class="keyword">new</span> DefaultProxyRoutePlanner(proxy) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">							HttpRequest request, HttpContext context)</span></span></span><br><span class="line"><span class="function">							<span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line">						<span class="keyword">if</span> (target.getHostName().equals(<span class="string">"192.168.0.5"</span>)) &#123;</span><br><span class="line">							<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;).build();</span><br><span class="line">		restTemplate.setRequestFactory(</span><br><span class="line">				<span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，最极端（很少使用）的选项是创建自己的 <code>RestTemplateBuilder</code>bean。这样做会关闭自动配置 的<code>RestTemplateBuilder</code>并阻止使用任何<code>RestTemplateCustomizer</code>bean。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-RestTemplate/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-消息中间件/">使用SpringBoot-消息中间件</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/jms/">jms</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/amqp/">amqp</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/rabbitmq/">rabbitmq</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/kafka/">kafka</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h1><p>Spring Framework为与消息传递系统的集成提供了广泛的支持，从简化使用JMS API <code>JmsTemplate</code>到完整的基础架构，以异步接收消息。Spring AMQP为高级消息队列协议提供了类似的功能集。Spring Boot还为<code>RabbitTemplate</code>RabbitMQ 提供了自动配置选项。Spring WebSocket本身包含对STOMP消息传递的支持，Spring Boot通过启动器和少量自动配置支持它。Spring Boot也支持Apache Kafka。</p>
<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>该<code>javax.jms.ConnectionFactory</code>接口提供了一种创建<code>javax.jms.Connection</code>与JMS代理交互的标准方法 。尽管Spring需要 <code>ConnectionFactory</code>使用JMS，但您通常不需要直接使用它，而是可以依赖于更高级别的消息传递抽象。（有关详细信息，请参阅Spring Framework参考文档的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#jms" target="_blank" rel="noopener">相关部分</a>。）Spring Boot还会自动配置发送和接收消息所需的基础结构。</p>
<h3 id="ActiveMQ支持"><a href="#ActiveMQ支持" class="headerlink" title="ActiveMQ支持"></a>ActiveMQ支持</h3><p>当<a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ</a>在类路径上可用时，Spring Boot也可以配置a <code>ConnectionFactory</code>。如果代理存在，则会自动启动并配置嵌入式代理（前提是未通过配置指定代理URL）。</p>
<blockquote>
<p>如果使用<code>spring-boot-starter-activemq</code>，则提供连接或嵌入ActiveMQ实例的必要依赖项，以及与JMS集成的Spring基础结构。</p>
</blockquote>
<p>ActiveMQ配置由外部配置属性控制 <code>spring.activemq.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.broker-url=tcp://192.168.1.210:9876</span><br><span class="line">spring.activemq.user=admin</span><br><span class="line">spring.activemq.password=secret</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用合理设置<code>CachingConnectionFactory</code>包装本机<code>ConnectionFactory</code>，您可以通过以下方式控制外部配置属性 <code>spring.jms.*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.cache.session-cache-size=5</span><br></pre></td></tr></table></figure>
<p>如果您更愿意使用本机池，则可以通过向相应位置添加依赖关系 <code>org.messaginghub:pooled-jms</code>并进行相应配置来实现<code>JmsPoolConnectionFactory</code>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.pool.enabled=true</span><br><span class="line">spring.activemq.pool.max-connections=50</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java" target="_blank" rel="noopener"><code>ActiveMQProperties</code></a> 更多支持的选项，请参阅 。您还可以注册任意数量的bean，以实现<code>ActiveMQConnectionFactoryCustomizer</code>更高级的自定义。</p>
</blockquote>
<p>默认情况下，ActiveMQ会创建一个目标（如果它尚不存在），以便根据提供的名称解析目标。</p>
<h3 id="Artemis-Support"><a href="#Artemis-Support" class="headerlink" title="Artemis Support"></a>Artemis Support</h3><p>Spring Boot可以<code>ConnectionFactory</code>在检测到<a href="http://activemq.apache.org/artemis/" target="_blank" rel="noopener">Artemis</a>在类路径上可用时 自动配置。如果代理存在，则会自动启动并配置嵌入式代理（除非已明确设置mode属性）。支持的模式是<code>embedded</code>（明确表示需要嵌入式代理，如果代理在类路径上不可用则发生错误）和<code>native</code>（使用<code>netty</code> 传输协议连接到代理）。配置后者后，Spring Boot会<code>ConnectionFactory</code>使用默认设置配置 连接到本地计算机上运行的代理的连接。</p>
<blockquote>
<p>如果使用<code>spring-boot-starter-artemis</code>，则提供连接到现有Artemis实例的必要依赖项，以及与JMS集成的Spring基础结构。添加<code>org.apache.activemq:artemis-jms-server</code>到您的应用程序可让您使用嵌入模式。</p>
</blockquote>
<p>Artemis配置由外部配置属性控制 <code>spring.artemis.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.artemis.mode=native</span><br><span class="line">spring.artemis.host=192.168.1.210</span><br><span class="line">spring.artemis.port=9876</span><br><span class="line">spring.artemis.user=admin</span><br><span class="line">spring.artemis.password=secret</span><br></pre></td></tr></table></figure>
<p>嵌入代理时，您可以选择是否要启用持久性并列出应该可用的目标。这些可以指定为以逗号分隔的列表，使用默认选项创建它们，或者您可以分别为高级队列和主题配置定义类型的bean <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code>或<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>。</p>
<p>默认情况下，使用合理设置<code>CachingConnectionFactory</code>包装本机<code>ConnectionFactory</code>，您可以通过以下方式控制外部配置属性 <code>spring.jms.*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.cache.session-cache-size=5</span><br></pre></td></tr></table></figure>
<p>如果您更愿意使用本机池，则可以通过向相应位置添加依赖关系 <code>org.messaginghub:pooled-jms</code>并进行相应配置来实现<code>JmsPoolConnectionFactory</code>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.artemis.pool.enabled=true</span><br><span class="line">spring.artemis.pool.max-connections=50</span><br></pre></td></tr></table></figure>
<p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java" target="_blank" rel="noopener"><code>ArtemisProperties</code></a> 更多支持选项，请参阅</p>
<p>不涉及JNDI查找，并使用<code>name</code>Artemis配置中的属性或通过配置提供的名称来解析目标名称。</p>
<h3 id="使用JNDI-ConnectionFactory"><a href="#使用JNDI-ConnectionFactory" class="headerlink" title="使用JNDI ConnectionFactory"></a>使用JNDI ConnectionFactory</h3><p>如果您在应用程序服务器中运行应用程序，Spring Boot会尝试<code>ConnectionFactory</code>使用JNDI 查找JMS 。默认情况下，将检查<code>java:/JmsXA</code>和<code>java:/XAConnectionFactory</code>位置。<code>spring.jms.jndi-name</code> 如果需要指定备用位置，可以使用该属性，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.jndi-name=java:/MyConnectionFactory</span><br></pre></td></tr></table></figure>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring <code>JmsTemplate</code>是自动配置的，你可以直接将它自动装入自己的bean中，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JmsTemplate jmsTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jmsTemplate = jmsTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html" target="_blank" rel="noopener"><code>JmsMessagingTemplate</code></a>可以以类似的方式注射。如果定义了一个<code>DestinationResolver</code>或一个<code>MessageConverter</code>bean，它将自动关联到自动配置<code>JmsTemplate</code>。</p>
</blockquote>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>当存在JMS基础结构时，可以使用任何bean来注释<code>@JmsListener</code>以创建侦听器端点。如果<code>JmsListenerContainerFactory</code>未定义，则自动配置默认值。如果定义了一个<code>DestinationResolver</code>或一个 <code>MessageConverter</code>bean，它将自动关联到默认工厂。</p>
<p>默认情况下，默认工厂是事务性的。如果您在<code>JtaTransactionManager</code>存在a的基础结构中运行 ，则默认情况下它与侦听器容器相关联。如果不是，<code>sessionTransacted</code>则启用该标志。在后一种情况下，您可以通过添加<code>@Transactional</code>侦听器方法（或其委托）将本地数据存储事务与传入消息的处理相关联。这确保了在本地事务完成后确认传入消息。这还包括发送已在同一JMS会话上执行的响应消息。</p>
<p>以下组件在<code>someQueue</code>目标上创建侦听器端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@JmsListener</span>(destination = <span class="string">"someQueue"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关 更多详细信息，请参阅<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/jms/annotation/EnableJms.html" target="_blank" rel="noopener">Javadoc<code>@EnableJms</code></a>。</p>
</blockquote>
<p>如果您需要创建更多<code>JmsListenerContainerFactory</code>实例，或者如果要覆盖默认实例，则Spring Boot提供了一个<code>DefaultJmsListenerContainerFactoryConfigurer</code>可用于初始化a <code>DefaultJmsListenerContainerFactory</code>的设置，其设置与自动配置的设置相同。</p>
<p>例如，以下示例公开了另一个使用特定工厂的工厂 <code>MessageConverter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">		DefaultJmsListenerContainerFactory factory =</span><br><span class="line">				<span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">		configurer.configure(factory, connectionFactory());</span><br><span class="line">		factory.setMessageConverter(myMessageConverter());</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后您可以在任何<code>@JmsListener</code>注释方法中使用工厂，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@JmsListener</span>(destination = <span class="string">"someQueue"</span>, containerFactory=<span class="string">"myFactory"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>高级消息队列协议（AMQP）是面向消息的中间件的平台中立的线级协议。Spring AMQP项目将核心Spring概念应用于基于AMQP的消息传递解决方案的开发。Spring Boot提供了几种通过RabbitMQ使用AMQP的便利，包括<code>spring-boot-starter-amqp</code> “Starter”。</p>
<h3 id="RabbitMQ支持"><a href="#RabbitMQ支持" class="headerlink" title="RabbitMQ支持"></a>RabbitMQ支持</h3><p><a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>是一个基于AMQP协议的轻量级，可靠，可扩展且可移植的消息代理。Spring用于<code>RabbitMQ</code>通过AMQP协议进行通信。</p>
<p>RabbitMQ配置由外部配置属性控制 <code>spring.rabbitmq.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=secret</span><br></pre></td></tr></table></figure>
<p>如果<code>ConnectionNameStrategy</code>上下文中存在bean，则它将自动用于命名由自动配置创建的连接<code>ConnectionFactory</code>。有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java" target="_blank" rel="noopener"><code>RabbitProperties</code></a>更多支持的选项，请参阅 。</p>
<blockquote>
<p>有关详细信息<a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/" target="_blank" rel="noopener">，</a>请参阅 <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/" target="_blank" rel="noopener">了解RabbitQQ使用的协议AMQP</a>。</p>
</blockquote>
<h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring的<code>AmqpTemplate</code>和<code>AmqpAdmin</code>被自动配置，您可以直接自动装配它们变成自己的豆类，如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AmqpAdmin amqpAdmin;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.amqpAdmin = amqpAdmin;</span><br><span class="line">		<span class="keyword">this</span>.amqpTemplate = amqpTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html" target="_blank" rel="noopener"><code>RabbitMessagingTemplate</code></a> 可以以类似的方式注射。如果<code>MessageConverter</code>定义了bean，它将自动关联到自动配置<code>AmqpTemplate</code>。</p>
</blockquote>
<p>如有必要，任何<code>org.springframework.amqp.core.Queue</code>定义为bean的都会自动用于在RabbitMQ实例上声明相应的队列。</p>
<p>要重试操作，可以启用重试<code>AmqpTemplate</code>（例如，在代理连接丢失的情况下）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.template.retry.enabled=true</span><br><span class="line">spring.rabbitmq.template.retry.initial-interval=2s</span><br></pre></td></tr></table></figure>
<p>默认情况下禁用重试。您还可以<code>RetryTemplate</code> 通过声明<code>RabbitRetryTemplateCustomizer</code>bean来以编程方式自定义。</p>
<h3 id="接收消息-1"><a href="#接收消息-1" class="headerlink" title="接收消息"></a>接收消息</h3><p>当Rabbit基础结构存在时，可以使用任何bean来注释 <code>@RabbitListener</code>以创建侦听器端点。如果<code>RabbitListenerContainerFactory</code> 未定义，<code>SimpleRabbitListenerContainerFactory</code>则会自动配置默认值，您可以使用该<code>spring.rabbitmq.listener.type</code>属性切换到直接容器 。如果 定义了a <code>MessageConverter</code>或<code>MessageRecoverer</code>bean，它将自动与默认工厂关联。</p>
<p>以下示例组件在<code>someQueue</code>队列上创建侦听器端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RabbitListener</span>(queues = <span class="string">"someQueue"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html" target="_blank" rel="noopener">Javadoc <code>@EnableRabbit</code></a>。</p>
</blockquote>
<p>如果您需要创建更多<code>RabbitListenerContainerFactory</code>实例，或者如果要覆盖默认实例，Spring Boot提供了一个<code>SimpleRabbitListenerContainerFactoryConfigurer</code>和一个 <code>DirectRabbitListenerContainerFactoryConfigurer</code>可用于初始化a<code>SimpleRabbitListenerContainerFactory</code>和a <code>DirectRabbitListenerContainerFactory</code>的设置，其设置与自动配置使用的工厂相同。</p>
<blockquote>
<p>您选择的容器类型无关紧要。这两个bean通过自动配置公开。</p>
</blockquote>
<p>例如，以下配置类公开了另一个使用特定的工厂<code>MessageConverter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">		SimpleRabbitListenerContainerFactory factory =</span><br><span class="line">				<span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">		configurer.configure(factory, connectionFactory);</span><br><span class="line">		factory.setMessageConverter(myMessageConverter());</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后您可以在任何<code>@RabbitListener</code>注释方法中使用工厂，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RabbitListener</span>(queues = <span class="string">"someQueue"</span>, containerFactory=<span class="string">"myFactory"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以启用重试来处理侦听器抛出异常的情况。默认<code>RejectAndDontRequeueRecoverer</code>使用，但您可以定义<code>MessageRecoverer</code> 自己的。当重试耗尽时，如果代理配置了这样做，则拒绝该消息并将其丢弃或路由到死信交换。默认情况下，禁用重试。您还可以<code>RetryTemplate</code>通过声明<code>RabbitRetryTemplateCustomizer</code>bean来以编程方式自定义。</p>
<blockquote>
<p><strong>重要:</strong></p>
<p>默认情况下，如果禁用重试并且侦听器抛出异常，则会无限期地重试传递。您可以通过两种方式修改此行为：将<code>defaultRequeueRejected</code>属性设置为<code>false</code>以便尝试零重新传递，或者抛出一个<code>AmqpRejectAndDontRequeueException</code>信号来表示应该拒绝该消息。后者是启用重试并且达到最大传递尝试次数时使用的机制。</p>
</blockquote>
<h2 id="Apache-Kafka支持"><a href="#Apache-Kafka支持" class="headerlink" title="Apache Kafka支持"></a>Apache Kafka支持</h2><p>通过提供<code>spring-kafka</code>项目的自动配置来支持<a href="https://kafka.apache.org/" target="_blank" rel="noopener">Apache Kafka</a>。</p>
<p>Kafka配置由外部配置属性控制 <code>spring.kafka.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.bootstrap-servers=localhost:9092</span><br><span class="line">spring.kafka.consumer.group-id=myGroup</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要在启动时创建主题，请添加类型的bean <code>NewTopic</code>。如果主题已存在，则忽略该bean。</p>
</blockquote>
<p>有关更多支持选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java" target="_blank" rel="noopener"><code>KafkaProperties</code></a> </p>
<h3 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring <code>KafkaTemplate</code>是自动配置的，您可以直接在自己的bean中自动装配它，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(KafkaTemplate kafkaTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果<code>spring.kafka.producer.transaction-id-prefix</code>定义了属性， <code>KafkaTransactionManager</code>则会自动配置a。此外，如果<code>RecordMessageConverter</code> 定义了bean，它将自动与自动配置相关联<code>KafkaTemplate</code>。</p>
</blockquote>
<h3 id="接收消息-2"><a href="#接收消息-2" class="headerlink" title="接收消息"></a>接收消息</h3><p>当存在Apache Kafka基础结构时，可以使用任何bean来注释 <code>@KafkaListener</code>以创建侦听器端点。如果<code>KafkaListenerContainerFactory</code>未定义，则使用定义的键自动配置默认值 <code>spring.kafka.listener.*</code>。</p>
<p>以下组件在<code>someTopic</code>主题上创建侦听器端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@KafkaListener</span>(topics = <span class="string">"someTopic"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>KafkaTransactionManager</code>定义了bean，它将自动关联到容器工厂。类似地，如果一个<code>RecordMessageConverter</code>，<code>ErrorHandler</code>或<code>AfterRollbackProcessor</code>豆被定义，它被自动关联为出厂默认。</p>
<blockquote>
<p><code>ChainedKafkaTransactionManager</code>必须标记自定义，<code>@Primary</code>因为它通常引用自动配置的<code>KafkaTransactionManager</code>bean。</p>
</blockquote>
<h3 id="Kafka-Streams"><a href="#Kafka-Streams" class="headerlink" title="Kafka Streams"></a>Kafka Streams</h3><p>Spring for Apache Kafka提供了一个工厂bean来创建一个<code>StreamsBuilder</code>对象并管理其流的生命周期。Spring Boot会自动配置所需的<code>KafkaStreamsConfiguration</code>bean，只要<code>kafka-streams</code>在类路径上，并通过<code>@EnableKafkaStreams</code>注释启用Kafka Streams 。</p>
<p>启用Kafka Streams意味着必须设置应用程序ID和引导服务器。前者可以使用配置<code>spring.kafka.streams.application-id</code>，<code>spring.application.name</code>如果没有设置则默认为默认 值。后者可以全局设置或专门为流而重写。</p>
<p>使用专用属性可以使用其他几个属性; 可以使用<code>spring.kafka.streams.properties</code>命名空间设置其他任意Kafka属性。有关更多信息<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-kafka-extra-props" target="_blank" rel="noopener">，</a>另请参见<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-kafka-extra-props" target="_blank" rel="noopener">第34.3.4节“其他Kafka属性”</a>。</p>
<p>要使用工厂bean，只需连接<code>StreamsBuilder</code>到您的bean，<code>@Bean</code>如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableKafkaStreams</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaStreamsExampleConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> KStream&lt;Integer, String&gt; <span class="title">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span> </span>&#123;</span><br><span class="line">		KStream&lt;Integer, String&gt; stream = streamsBuilder.stream(<span class="string">"ks1In"</span>);</span><br><span class="line">		stream.map((k, v) -&gt; <span class="keyword">new</span> KeyValue&lt;&gt;(k, v.toUpperCase())).to(<span class="string">"ks1Out"</span>,</span><br><span class="line">				Produced.with(Serdes.Integer(), <span class="keyword">new</span> JsonSerde&lt;&gt;()));</span><br><span class="line">		<span class="keyword">return</span> stream;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，由其<code>StreamBuilder</code>创建的对象管理的流将自动启动。您可以使用该<code>spring.kafka.streams.auto-startup</code>属性自定义此行为 。</p>
<h3 id="附加Kafka属性"><a href="#附加Kafka属性" class="headerlink" title="附加Kafka属性"></a>附加Kafka属性</h3><p>自动配置支持的属性显示在 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">附录A，<em>常见应用程序属性中</em></a>。请注意，在大多数情况下，这些属性（连字符或camelCase）直接映射到Apache Kafka点状属性。有关详细信息，请参阅Apache Kafka文档。</p>
<p>这些属性中的前几个适用于所有组件（生产者，使用者，管理员和流），但如果您希望使用不同的值，则可以在组件级别指定。Apache Kafka指定重要性为HIGH，MEDIUM或LOW的属性。Spring Boot自动配置支持所有HIGH重要性属性，一些选定的MEDIUM和LOW属性，以及任何没有默认值的属性。</p>
<p>只有Kafka支持的属性的一部分可以直接通过 <code>KafkaProperties</code>该类获得。如果您希望使用不直接支持的其他属性配置生产者或使用者，请使用以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.properties.prop.one=first</span><br><span class="line">spring.kafka.admin.properties.prop.two=second</span><br><span class="line">spring.kafka.consumer.properties.prop.three=third</span><br><span class="line">spring.kafka.producer.properties.prop.four=fourth</span><br><span class="line">spring.kafka.streams.properties.prop.five=fifth</span><br></pre></td></tr></table></figure>
<p>这将常见的<code>prop.one</code>Kafka属性设置为<code>first</code>（适用于生产者，使用者和管理员），<code>prop.two</code>admin属性<code>second</code>，<code>prop.three</code> 使用者属性<code>third</code>，<code>prop.four</code>生产者属性<code>fourth</code>和 <code>prop.five</code>streams属性<code>fifth</code>。</p>
<p>您还可以<code>JsonDeserializer</code>按如下方式配置Spring Kafka ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer</span><br><span class="line">spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice</span><br><span class="line">spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme</span><br></pre></td></tr></table></figure>
<p>同样，您可以禁用<code>JsonSerializer</code>在标头中发送类型信息的默认行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer</span><br><span class="line">spring.kafka.producer.properties.spring.json.add.type.headers=false</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>重要</strong>：</p>
<p>以这种方式设置的属性将覆盖Spring Boot明确支持的任何配置项。</p>
</blockquote>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-消息中间件/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-cache/">使用SpringBoot-cache</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/cache/">cache</a></div></div><div class="post-content"><div class="main-content content"><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>Spring Framework支持透明地向应用程序添加缓存。从本质上讲，抽象将缓存应用于方法，从而根据缓存中可用的信息减少执行次数。缓存逻辑是透明应用的，不会对调用者造成任何干扰。只要通过<code>@EnableCaching</code> 注释启用了缓存支持，Spring Boot就会自动配置缓存基础结构。</p>
<blockquote>
<p><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache" target="_blank" rel="noopener">有关</a>更多详细信息，请查看Spring Framework参考的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache" target="_blank" rel="noopener">相关部分</a>。</p>
</blockquote>
<p>简而言之，将缓存添加到服务操作就像在其方法中添加相关注释一样简单，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Cacheable</span>(<span class="string">"piDecimals"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computePiDecimal</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例演示了如何在可能代价高昂的操作上使用缓存。在调用之前<code>computePiDecimal</code>，抽象会在<code>piDecimals</code>缓存中查找与<code>i</code>参数匹配的条目。如果找到条目，则缓存中的内容会立即返回给调用者，并且不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。</p>
<blockquote>
<p>您还可以<code>@CacheResult</code>透明地使用标准JSR-107（JCache）注释（例如 ）。但是，我们强烈建议您不要混淆和匹配Spring Cache和JCache注释。</p>
</blockquote>
<p>如果您不添加任何特定的缓存库，Spring Boot会自动配置一个在内存中使用并发映射的 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-simple" target="_blank" rel="noopener">简单提供程序</a>。当需要缓存时（例如<code>piDecimals</code>在前面的示例中），此提供程序会为您创建缓存。简单的提供程序并不是真正推荐用于生产用途，但它非常适合入门并确保您了解这些功能。当您决定使用缓存提供程序时，请务必阅读其文档以了解如何配置应用程序使用的缓存。几乎所有提供程序都要求您显式配置在应用程序中使用的每个缓存。有些提供了一种自定义<code>spring.cache.cache-names</code>属性定义的默认缓存的方法。</p>
<blockquote>
<p>还可以透明地 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache-annotations-put" target="_blank" rel="noopener">更新</a>或 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache-annotations-evict" target="_blank" rel="noopener">逐出</a>缓存中的数据。</p>
</blockquote>
<h2 id="支持的缓存提供程序"><a href="#支持的缓存提供程序" class="headerlink" title="支持的缓存提供程序"></a>支持的缓存提供程序</h2><p>缓存抽象不提供实际存储，而是依赖于<code>org.springframework.cache.Cache</code>和 <code>org.springframework.cache.CacheManager</code>接口实现的抽象。</p>
<p>如果尚未定义类型的bean <code>CacheManager</code>或<code>CacheResolver</code>命名 的bean <code>cacheResolver</code>（请参阅参考资料 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html" target="_blank" rel="noopener"><code>CachingConfigurer</code></a>），Spring Boot会尝试检测以下提供程序（按指示的顺序）：</p>
<ol>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-generic" target="_blank" rel="noopener">Generic</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-jcache" target="_blank" rel="noopener">JCache（JSR-107）</a>（EhCache 3，Hazelcast，Infinispan等）</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-ehcache2" target="_blank" rel="noopener">EhCache 2.x</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-hazelcast" target="_blank" rel="noopener">Hazelcast</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-infinispan" target="_blank" rel="noopener">Infinispan</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-couchbase" target="_blank" rel="noopener">Couchbase</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-redis" target="_blank" rel="noopener">Redis</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-caffeine" target="_blank" rel="noopener">Caffeine</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-simple" target="_blank" rel="noopener">Simple</a></li>
</ol>
<blockquote>
<p>也可以通过设置属性来<em>强制</em>特定的缓存提供程序 <code>spring.cache.type</code>。如果您需要在某些环境（例如测试）中<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-none" target="_blank" rel="noopener">完全禁用缓存，</a>请使用此属性 。</p>
</blockquote>
<blockquote>
<p>使用<code>spring-boot-starter-cache</code>“Starter”快速添加基本缓存依赖项。首发引入<code>spring-context-support</code>。如果手动添加依赖项，则必须包括<code>spring-context-support</code>才能使用JCache，EhCache 2.x或Guava支持。</p>
</blockquote>
<p>如果<code>CacheManager</code>由Spring Boot自动配置，则可以通过公开实现该<code>CacheManagerCustomizer</code>接口的bean完全初始化之前进一步调整其配置 。以下示例设置一个标志，表示应将null值传递给底层映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConcurrentMapCacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">			cacheManager.setAllowNullValues(<span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在前面的示例中，<code>ConcurrentMapCacheManager</code>预期会自动配置。如果不是这种情况（您提供了自己的配置或自动配置了不同的缓存提供程序），则根本不会调用自定义程序。您可以拥有任意数量的自定义程序，也可以使用<code>@Order</code>或订购它们<code>Ordered</code>。</p>
</blockquote>
<h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><p>如果上下文定义<em>至少</em>一个 <code>org.springframework.cache.Cache</code>bean，则使用通用高速缓存。将<code>CacheManager</code>创建包装该类型的所有bean。</p>
<h3 id="JCache（JSR-107）"><a href="#JCache（JSR-107）" class="headerlink" title="JCache（JSR-107）"></a>JCache（JSR-107）</h3><p><a href="https://jcp.org/en/jsr/detail?id=107" target="_blank" rel="noopener">JCache</a>通过<code>javax.cache.spi.CachingProvider</code>类路径上的存在（即类路径上存在符合JSR-107的缓存库）进行引导 ，<code>JCacheCacheManager</code>并由<code>spring-boot-starter-cache</code>“Starter”提供。可以使用各种兼容库，Spring Boot为Ehcache 3，Hazelcast和Infinispan提供依赖管理。还可以添加任何其他兼容库。</p>
<p>可能会出现多个提供程序，在这种情况下，必须明确指定提供程序。即使JSR-107标准没有强制执行定义配置文件位置的标准化方法，Spring Boot也会尽力满足设置缓存的实现细节，如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   #仅在存在多个提供程序时才需要</span><br><span class="line">spring.cache.jcache.provider=com.acme.MyCachingProvider</span><br><span class="line">spring.cache.jcache.config=classpath:acme.xml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当缓存库同时提供本机实现和JSR-107支持时，Spring Boot更喜欢JSR-107支持，因此如果切换到不同的JSR-107实现，则可以使用相同的功能。</p>
</blockquote>
<blockquote>
<p>Spring Boot <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">对Hazelcast</a>有<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">一般支持</a>。如果单个<code>HazelcastInstance</code>可用，则<code>CacheManager</code>除非<code>spring.cache.jcache.config</code>指定了属性，否则它也会自动重复使用 。</p>
</blockquote>
<p>有两种方法可以自定义底层<code>javax.cache.cacheManager</code>：</p>
<ul>
<li>可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存。如果定义了自定义<code>javax.cache.configuration.Configuration</code>bean，则会使用它来自定义它们。</li>
<li><code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code>使用<code>CacheManager</code>for完全自定义的引用调用bean 。</li>
</ul>
<blockquote>
<p>如果<code>javax.cache.CacheManager</code>定义了标准bean，它将自动包装在<code>org.springframework.cache.CacheManager</code>抽象所期望的实现中。没有进一步的自定义。</p>
</blockquote>
<h3 id="EhCache-2-x"><a href="#EhCache-2-x" class="headerlink" title="EhCache 2.x"></a>EhCache 2.x</h3><p>如果<code>ehcache.xml</code>可以在类路径的根目录中找到名为的文件，则使用<a href="http://www.ehcache.org/" target="_blank" rel="noopener">EhCache 2.x. </a>如果找到EhCache 2.x，则使用“Starter” <code>EhCacheCacheManager</code>提供的<code>spring-boot-starter-cache</code>引导缓存管理器。还可以提供备用配置文件，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.ehcache.config=classpath:config/another-config.xml</span><br></pre></td></tr></table></figure>
<h3 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h3><p>Spring Boot <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">对Hazelcast</a>有<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">一般支持</a>。如果a <code>HazelcastInstance</code>已自动配置，则会自动包装在a中 <code>CacheManager</code>。</p>
<h3 id="Infinispan"><a href="#Infinispan" class="headerlink" title="Infinispan"></a>Infinispan</h3><p><a href="http://infinispan.org/" target="_blank" rel="noopener">Infinispan</a>没有默认配置文件位置，因此必须明确指定。否则，使用默认引导程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.infinispan.config=infinispan.xml</span><br></pre></td></tr></table></figure>
<p>可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存。如果定义了自定义<code>ConfigurationBuilder</code>bean，则它用于自定义缓存。</p>
<blockquote>
<p>Infinispan在Spring Boot中的支持仅限于嵌入式模式，非常基础。如果你想要更多选项，你应该使用官方的Infinispan Spring Boot启动器。有关更多详细信息，请参阅 <a href="https://github.com/infinispan/infinispan-spring-boot" target="_blank" rel="noopener">Infinispan的文档</a>。</p>
</blockquote>
<h3 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h3><p>如果<a href="https://www.couchbase.com/" target="_blank" rel="noopener">Couchbase</a> Java客户端和<code>couchbase-spring-cache</code> 实现可用且<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-couchbase" target="_blank" rel="noopener">配置</a>了Couchbase ， <code>CouchbaseCacheManager</code>则会自动配置a。也可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存。这些缓存在<code>Bucket</code>自动配置的情况下运行。您可以<em>还</em>创建另一个附加缓存中<code>Bucket</code>，通过使用定制。假设在“main” 和one（）缓存上需要两个缓存（<code>cache1</code>和 <code>cache2</code>），<code>Bucket</code>并且<code>cache3</code>“另一个”上的自定义时间为2秒<code>Bucket</code>。您可以通过配置创建前两个缓存，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br></pre></td></tr></table></figure>
<p>然后，您可以定义一个<code>@Configuration</code>类来配置额外<code>Bucket</code>和 <code>cache3</code>缓存，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouchbaseCacheConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Cluster cluster;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CouchbaseCacheConfiguration</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Bucket <span class="title">anotherBucket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.cluster.openBucket(<span class="string">"another"</span>, <span class="string">"secret"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;CouchbaseCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c -&gt; &#123;</span><br><span class="line">			c.prepareCache(<span class="string">"cache3"</span>, CacheBuilder.newInstance(anotherBucket())</span><br><span class="line">					.withExpiration(<span class="number">2</span>));</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例配置重用<code>Cluster</code>通过自动配置创建的配置。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>如果<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>可用且已配置，<code>RedisCacheManager</code>则会自动配置。可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存， 并可以使用<code>spring.cache.redis.*</code>属性配置缓存默认值 。例如，以下配置创建 <code>cache1</code>并<code>cache2</code>缓存10分钟的<em>生存</em>时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br><span class="line">spring.cache.redis.time-to-live=600000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，会添加一个键前缀，这样，如果两个单独的缓存使用相同的键，则Redis没有重叠键，也不能返回无效值。如果您创建自己的设置，我们强烈建议您启用此设置<code>RedisCacheManager</code>。</p>
</blockquote>
<blockquote>
<p>您可以通过添加<code>RedisCacheConfiguration</code> <code>@Bean</code>自己的配置来完全控制配置。如果您正在寻找自定义序列化策略，这可能很有用。</p>
</blockquote>
<h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><p><a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">Caffeine</a>是Java 8重写的Guava缓存，取代了对Guava的支持。如果存在Caffeine，则自动配置一个 <code>CaffeineCacheManager</code>（由<code>spring-boot-starter-cache</code>启动器提供）。可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存，并且可以通过以下之一（按指示的顺序）自定义缓存：</p>
<ol>
<li>由…定义的缓存规范 <code>spring.cache.caffeine.spec</code></li>
<li><code>com.github.benmanes.caffeine.cache.CaffeineSpec</code>定义了一个bean</li>
<li><code>com.github.benmanes.caffeine.cache.Caffeine</code>定义了一个bean</li>
</ol>
<p>例如，以下配置创建<code>cache1</code>和<code>cache2</code>缓存，最大大小为500，<em>生存时间为</em> 10分钟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br><span class="line">spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s</span><br></pre></td></tr></table></figure>
<p>如果<code>com.github.benmanes.caffeine.cache.CacheLoader</code>定义了bean，它将自动关联到<code>CaffeineCacheManager</code>。由于<code>CacheLoader</code>它将与缓存管理器管理的<em>所有</em>缓存相关联，因此必须将其定义为 <code>CacheLoader&lt;Object, Object&gt;</code>。自动配置忽略任何其他泛型类型。</p>
<h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>如果找不到其他提供程序，<code>ConcurrentHashMap</code>则配置使用一个作为缓存存储的简单实现 。如果应用程序中不存在缓存库，则这是默认值。默认情况下，会根据需要创建缓存，但您可以通过设置<code>cache-names</code>属性来限制可用缓存列表。例如，如果只需要<code>cache1</code>和<code>cache2</code>缓存，请<code>cache-names</code>按如下方式设置属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br></pre></td></tr></table></figure>
<p>如果这样做并且您的应用程序使用未列出的缓存，则在需要缓存时它会在运行时失败，但在启动时则不会。这类似于“真实”缓存提供程序在使用未声明的缓存时的行为方式。</p>
<h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>如果<code>@EnableCaching</code>配置中存在，则还需要合适的缓存配置。如果需要在某些环境中完全禁用缓存，请强制缓存类型<code>none</code>使用no-op实现，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.type=none</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-cache/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-NoSQL数据库/">使用SpringBoot-NoSQL数据库</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/database/">database</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/nosql/">nosql</a></div></div><div class="post-content"><div class="main-content content"><h1 id="NoSQL-Technologies"><a href="#NoSQL-Technologies" class="headerlink" title="NoSQL Technologies"></a>NoSQL Technologies</h1><p>Spring Data提供了其他项目，可帮助您访问各种NoSQL技术，包括： <a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">MongoDB</a>， <a href="https://projects.spring.io/spring-data-neo4j/" target="_blank" rel="noopener">Neo4J</a>， <a href="https://github.com/spring-projects/spring-data-elasticsearch/" target="_blank" rel="noopener">Elasticsearch</a>， <a href="https://projects.spring.io/spring-data-solr/" target="_blank" rel="noopener">Solr</a>， <a href="https://projects.spring.io/spring-data-redis/" target="_blank" rel="noopener">Redis</a>， <a href="https://projects.spring.io/spring-data-gemfire/" target="_blank" rel="noopener">Gemfire</a>， <a href="https://projects.spring.io/spring-data-cassandra/" target="_blank" rel="noopener">Cassandra</a>， <a href="https://projects.spring.io/spring-data-couchbase/" target="_blank" rel="noopener">Couchbase</a>和<a href="https://projects.spring.io/spring-data-ldap/" target="_blank" rel="noopener">LDAP</a>。Spring Boot为Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase和LDAP提供自动配置。您可以使用其他项目，但必须自己配置它们。请参阅<a href="https://projects.spring.io/spring-data" target="_blank" rel="noopener">projects.spring.io/spring-data</a>上的相应参考文档 。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>是一个缓存，消息代理和功能丰富的键值存储。Spring Boot为<a href="https://github.com/lettuce-io/lettuce-core/" target="_blank" rel="noopener">Lettuce</a>和 <a href="https://github.com/xetorthio/jedis/" target="_blank" rel="noopener">Jedis</a>客户端库提供了基本的自动配置， 并为<a href="https://github.com/spring-projects/spring-data-redis" target="_blank" rel="noopener">Spring Data Redis</a>提供了它们之外的抽象。</p>
<p>有一个<code>spring-boot-starter-data-redis</code>“Starter”用于以方便的方式收集依赖项。默认情况下，它使用 <a href="https://github.com/lettuce-io/lettuce-core/" target="_blank" rel="noopener">Lettuce</a>。该启动器处理传统和反应应用程序。</p>
<blockquote>
<p>我们还提供一个<code>spring-boot-starter-data-redis-reactive</code>启动器，以便与其他具有反应支持的商店保持一致。</p>
</blockquote>
<h3 id="连接到Redis"><a href="#连接到Redis" class="headerlink" title="连接到Redis"></a>连接到Redis</h3><p>你可以注入的自动配置<code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code>或香草<code>RedisTemplate</code>，就像任何其他的Spring Bean实例。默认情况下，实例尝试连接到Redis服务器<code>localhost:6379</code>。以下清单显示了这样一个bean的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您还可以注册任意数量的bean，以实现 <code>LettuceClientConfigurationBuilderCustomizer</code>更高级的自定义。如果您使用Jedis，<code>JedisClientConfigurationBuilderCustomizer</code>也可以使用。</p>
</blockquote>
<p>如果您添加自己<code>@Bean</code>的任何自动配置类型，它将替换默认值（除非在<code>RedisTemplate</code>排除基于bean名称时 <code>redisTemplate</code>，而不是其类型）。默认情况下，如果<code>commons-pool2</code>在类路径上，则会获得池化连接工厂。</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p><a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB</a>是一个开源的NoSQL文档数据库，它使用类似JSON的模式而不是传统的基于表的关系数据。Spring Boot提供了一些使用MongoDB的便利，包括<code>spring-boot-starter-data-mongodb</code>和<code>spring-boot-starter-data-mongodb-reactive</code> 启动器。</p>
<h3 id="连接到MongoDB数据库"><a href="#连接到MongoDB数据库" class="headerlink" title="连接到MongoDB数据库"></a>连接到MongoDB数据库</h3><p>要访问Mongo数据库，可以注入自动配置 <code>org.springframework.data.mongodb.MongoDbFactory</code>。默认情况下，实例尝试连接到MongoDB服务器<code>mongodb://localhost/test</code>。以下示例显示如何连接到MongoDB数据库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.MongoDbFactory;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.DB;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MongoDbFactory mongo;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoDbFactory mongo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mongo = mongo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		DB db = mongo.getDb();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以设置该<code>spring.data.mongodb.uri</code>属性以更改URL并配置其他设置，例如<em>副本集</em>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</span><br></pre></td></tr></table></figure>
<p>或者，只要您使用Mongo 2.x，就可以指定<code>host</code>/ <code>port</code>。例如，您可以在以下内容中声明以下设置<code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.host=mongoserver</span><br><span class="line">spring.data.mongodb.port=27017</span><br></pre></td></tr></table></figure>
<p>如果您已经定义了自己的<code>MongoClient</code>，它将用于自动配置合适的 <code>MongoDbFactory</code>。这两个<code>com.mongodb.MongoClient</code>和<code>com.mongodb.client.MongoClient</code> 支持。</p>
<blockquote>
<p>如果使用蒙戈3.0 Java驱动程序，<code>spring.data.mongodb.host</code>并且 <code>spring.data.mongodb.port</code>不支持。在这种情况下，<code>spring.data.mongodb.uri</code> 应该用于提供所有配置。</p>
</blockquote>
<blockquote>
<p>如果<code>spring.data.mongodb.port</code>未指定，<code>27017</code>则使用默认值。您可以从前面显示的示例中删除此行。</p>
</blockquote>
<blockquote>
<p>如果您不使用Spring Data Mongo，则可以注入<code>com.mongodb.MongoClient</code>bean而不是使用<code>MongoDbFactory</code>。如果要完全控制建立MongoDB连接，还可以声明自己的 bean <code>MongoDbFactory</code>或<code>MongoClient</code>bean。</p>
</blockquote>
<blockquote>
<p>如果您使用的是反应式驱动程序，则SSL需要Netty。如果Netty可用并且尚未自定义要使用的工厂，则自动配置会自动配置此工厂。</p>
</blockquote>
<h3 id="MongoTemplate"><a href="#MongoTemplate" class="headerlink" title="MongoTemplate"></a>MongoTemplate</h3><p><a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">Spring Data MongoDB</a>提供了一个<a href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoTemplate.html" target="_blank" rel="noopener"><code>MongoTemplate</code></a>与Spring的设计非常相似的 类<code>JdbcTemplate</code>。与此同时<code>JdbcTemplate</code>，Spring Boot会自动为您配置一个bean来注入模板，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoTemplate mongoTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mongoTemplate = mongoTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关完整的详细信息，请参阅 <a href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoOperations.html" target="_blank" rel="noopener"><code>MongoOperations</code> Javadoc</a>。</p>
<h3 id="Spring-Data-MongoDB存储库"><a href="#Spring-Data-MongoDB存储库" class="headerlink" title="Spring Data MongoDB存储库"></a>Spring Data MongoDB存储库</h3><p>Spring Data包括MongoDB的存储库支持。与前面讨论的JPA存储库一样，基本原则是基于方法名称自动构造查询。</p>
<p>事实上，Spring Data JPA和Spring Data MongoDB共享相同的通用基础架构。您可以从之前获取JPA示例，并假设它<code>City</code>现在是Mongo数据类而不是JPA <code>@Entity</code>，它的工作方式相同，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您可以使用<code>@EntityScan</code>注释自定义文档扫描位置。</p>
</blockquote>
<blockquote>
<p>有关Spring Data MongoDB的完整详细信息，包括其丰富的对象映射技术，请参阅其<a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h3 id="嵌入式Mongo"><a href="#嵌入式Mongo" class="headerlink" title="嵌入式Mongo"></a>嵌入式Mongo</h3><p>Spring Boot为<a href="https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo" target="_blank" rel="noopener">Embedded Mongo</a>提供自动配置 。要在Spring Boot应用程序中使用它，请添加依赖项 <code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code>。</p>
<p>可以通过设置<code>spring.data.mongodb.port</code> 属性来配置Mongo侦听的端口。要使用随机分配的空闲端口，请使用值0. <code>MongoClient</code> 创建者<code>MongoAutoConfiguration</code>自动配置为使用随机分配的端口。</p>
<blockquote>
<p>如果未配置自定义端口，则默认情况下，嵌入式支持使用随机端口（而不是27017）。</p>
</blockquote>
<p>如果类路径上有SLF4J，则Mongo生成的输出会自动路由到名为的记录器<code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code>。</p>
<p>您可以声明自己的bean <code>IMongodConfig</code>和<code>IRuntimeConfig</code>bean来控制Mongo实例的配置和日志记录路由。</p>
<h2 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h2><p><a href="http://neo4j.com/" target="_blank" rel="noopener">Neo4j</a>是一个开源的NoSQL图形数据库，它使用由一级关系连接的节点的丰富数据模型，与传统的RDBMS方法相比，它更适合于连接的大数据。Spring Boot为使用Neo4j提供了一些便利，包括<code>spring-boot-starter-data-neo4j</code> 启动器。</p>
<h3 id="连接到Neo4j数据库"><a href="#连接到Neo4j数据库" class="headerlink" title="连接到Neo4j数据库"></a>连接到Neo4j数据库</h3><p>要访问Neo4j服务器，您可以注入自动配置 <code>org.neo4j.ogm.session.Session</code>。默认情况下，实例尝试<code>localhost:7687</code>使用Bolt协议连接到Neo4j服务器。以下示例显示了如何注入Neo4j <code>Session</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Session session;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.session = session;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以通过设置<code>spring.data.neo4j.*</code> 属性来配置要使用的URI和凭据，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.data.neo4j.uri=bolt://my-server:7687</span><br><span class="line">spring.data.neo4j.username=neo4j</span><br><span class="line">spring.data.neo4j.password=secret</span><br></pre></td></tr></table></figure>
<p>您可以通过添加a来完全控制会话创建 <code>org.neo4j.ogm.config.Configuration</code> <code>@Bean</code>。此外，添加一个<code>@Bean</code>类型 <code>SessionFactory</code>会禁用自动配置并为您提供完全控制。</p>
<h3 id="使用嵌入模式"><a href="#使用嵌入模式" class="headerlink" title="使用嵌入模式"></a>使用嵌入模式</h3><p>如果添加<code>org.neo4j:neo4j-ogm-embedded-driver</code>到应用程序的依赖项，Spring Boot会自动配置Neo4j的进程内嵌入式实例，该应用程序在应用程序关闭时不会保留任何数据。</p>
<blockquote>
<p>由于嵌入式Neo4j OGM驱动程序本身不提供Neo4j内核，因此您必须自己声明<code>org.neo4j:neo4j</code>为依赖项。有关兼容版本的列表，请参阅 <a href="https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started" target="_blank" rel="noopener">Neo4j OGM文档</a>。</p>
</blockquote>
<p>当类路径上有多个驱动程序时，嵌入式驱动程序优先于其他驱动程序。您可以通过设置明确禁用嵌入模式 <code>spring.data.neo4j.embedded.enabled=false</code>。</p>
<p>如果嵌入式驱动程序和Neo4j内核如上所述位于类路径上，则<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test" target="_blank" rel="noopener">数据Neo4j测试会</a>自动使用嵌入式Neo4j实例。</p>
<blockquote>
<p>您可以通过在配置中提供数据库文件的路径来为嵌入模式启用持久性，例如<code>spring.data.neo4j.uri=file://var/tmp/graph.db</code>。</p>
</blockquote>
<h3 id="Neo4jSession"><a href="#Neo4jSession" class="headerlink" title="Neo4jSession"></a>Neo4jSession</h3><p>默认情况下，如果您正在运行Web应用程序，则会话将绑定到线程以进行整个请求处理（即，它使用“在视图中打开会话”模式）。如果您不想要此行为，请将以下行添加到您的 <code>application.properties</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.neo4j.embedded.enabled=false</span><br></pre></td></tr></table></figure>
<h3 id="Spring-Data-Neo4j存储库"><a href="#Spring-Data-Neo4j存储库" class="headerlink" title="Spring Data Neo4j存储库"></a>Spring Data Neo4j存储库</h3><p>Spring Data包含对Neo4j的存储库支持。</p>
<p>Spring Data Neo4j与Spring Data JPA共享通用基础架构，就像许多其他Spring Data模块一样。您可以从之前的JPA示例中获取并定义 <code>City</code>为Neo4j OGM <code>@NodeEntity</code>而不是JPA <code>@Entity</code>，并且存储库抽象以相同的方式工作，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Neo4jRepository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">Optional&lt;City&gt; <span class="title">findOneByNameAndState</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>spring-boot-starter-data-neo4j</code>“入门”使仓库的支持以及事务管理。您可以自定义的位置通过查找资料库和实体<code>@EnableNeo4jRepositories</code>，并<code>@EntityScan</code>分别在 <code>@Configuration</code>-bean。</p>
<blockquote>
<p>有关Spring Data Neo4j的完整详细信息，包括其对象映射技术，请参阅<a href="https://projects.spring.io/spring-data-neo4j/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="Gemfire"><a href="#Gemfire" class="headerlink" title="Gemfire"></a>Gemfire</h2><p><a href="https://github.com/spring-projects/spring-data-gemfire" target="_blank" rel="noopener">Spring Data Gemfire</a>为访问<a href="https://pivotal.io/big-data/pivotal-gemfire#details" target="_blank" rel="noopener">Pivotal Gemfire</a>数据管理平台提供了方便的Spring友好工具 。有一个<code>spring-boot-starter-data-gemfire</code>启动器用于以方便的方式收集依赖项。目前没有对Gemfire的自动配置支持，但您可以使用单个注释<a href="https://github.com/spring-projects/spring-data-gemfire/blob/master/src/main/java/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.java" target="_blank" rel="noopener"><code>@EnableGemfireRepositories</code></a>启用Spring Data Repositories <a href="https://github.com/spring-projects/spring-data-gemfire/blob/master/src/main/java/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.java" target="_blank" rel="noopener">:</a> .</p>
<h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p><a href="https://lucene.apache.org/solr/" target="_blank" rel="noopener">Apache Solr</a>是一个搜索引擎。Spring Boot为Solr 5客户端库提供了基本的自动配置，并为<a href="https://github.com/spring-projects/spring-data-solr" target="_blank" rel="noopener">Spring Data Solr</a>提供了它的抽象。有一个<code>spring-boot-starter-data-solr</code>启动器用于以方便的方式收集依赖项。</p>
<h3 id="连接到Solr"><a href="#连接到Solr" class="headerlink" title="连接到Solr"></a>连接到Solr</h3><p>您可以<code>SolrClient</code>像任何其他Spring bean一样注入自动配置的实例。默认情况下，实例尝试连接到服务器 <code>localhost:8983/solr</code>。以下示例显示如何注入Solr bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> SolrClient solr;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(SolrClient solr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.solr = solr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加自己<code>@Bean</code>的类型<code>SolrClient</code>，则会替换默认值。</p>
<h3 id="Spring-Data-Solr存储库"><a href="#Spring-Data-Solr存储库" class="headerlink" title="Spring Data Solr存储库"></a>Spring Data Solr存储库</h3><p>Spring Data包括Apache Solr的存储库支持。与前面讨论的JPA存储库一样，基本原则是根据方法名称自动构造查询。</p>
<p>事实上，Spring Data JPA和Spring Data Solr共享相同的通用基础架构。您可以从之前获取JPA示例，并假设它<code>City</code>现在是一个 <code>@SolrDocument</code>类而不是JPA <code>@Entity</code>，它以相同的方式工作。</p>
<blockquote>
<p>有关Spring Data Solr的完整详细信息，请参阅 <a href="https://projects.spring.io/spring-data-solr/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p><a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a>是一个开源，分布式，RESTful搜索和分析引擎。Spring Boot为Elasticsearch提供基本的自动配置。</p>
<p>Spring Boot支持多个HTTP客户端：</p>
<ul>
<li>官方Java“低级”和“高级”REST客户端</li>
<li><a href="https://github.com/searchbox-io/Jest" target="_blank" rel="noopener">笑话</a></li>
</ul>
<p><a href="https://github.com/spring-projects/spring-data-elasticsearch" target="_blank" rel="noopener">Spring Data Elasticsearch</a>仍在使用传输客户端 ，您可以使用<code>spring-boot-starter-data-elasticsearch</code>启动器开始使用它。</p>
<h3 id="REST客户端连接到Elasticsearch"><a href="#REST客户端连接到Elasticsearch" class="headerlink" title="REST客户端连接到Elasticsearch"></a>REST客户端连接到Elasticsearch</h3><p>Elasticsearch提供了 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html" target="_blank" rel="noopener">两个</a> 可用于查询集群的<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html" target="_blank" rel="noopener">REST客户端</a>：“低级”客户端和“高级”客户端。</p>
<p>如果您<code>org.elasticsearch.client:elasticsearch-rest-client</code>依赖于类路径，Spring Boot将自动配置并注册<code>RestClient</code>默认目标的bean <code>localhost:9200</code>。您可以进一步调整<code>RestClient</code>配置方式，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.elasticsearch.rest.uris=http://search.example.com:9200</span><br><span class="line">spring.elasticsearch.rest.username=user</span><br><span class="line">spring.elasticsearch.rest.password=secret</span><br></pre></td></tr></table></figure>
<p>您还可以注册任意数量的bean，以实现 <code>RestClientBuilderCustomizer</code>更高级的自定义。要完全控制注册，请定义<code>RestClient</code>bean。</p>
<p>如果您<code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code>对类路径有依赖性，Spring Boot将自动配置a <code>RestHighLevelClient</code>，它包装任何现有的<code>RestClient</code>bean，重用其HTTP配置。</p>
<h3 id="使用Jest连接到Elasticsearch"><a href="#使用Jest连接到Elasticsearch" class="headerlink" title="使用Jest连接到Elasticsearch"></a>使用Jest连接到Elasticsearch</h3><p>如果您具有<code>Jest</code>类路径，则可以注入<code>JestClient</code>默认目标的自动配置<code>localhost:9200</code>。您可以进一步调整客户端的配置方式，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.elasticsearch.jest.uris=http://search.example.com:9200</span><br><span class="line">spring.elasticsearch.jest.read-timeout=10000</span><br><span class="line">spring.elasticsearch.jest.username=user</span><br><span class="line">spring.elasticsearch.jest.password=secret</span><br></pre></td></tr></table></figure>
<p>您还可以注册任意数量的bean，以实现 <code>HttpClientConfigBuilderCustomizer</code>更高级的自定义。以下示例调整其他HTTP设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSettingsCustomizer</span> <span class="keyword">implements</span> <span class="title">HttpClientConfigBuilderCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(HttpClientConfig.Builder builder)</span> </span>&#123;</span><br><span class="line">		builder.maxTotalConnection(<span class="number">100</span>).defaultMaxTotalConnectionPerRoute(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要完全控制注册，请定义<code>JestClient</code>bean。</p>
<h3 id="使用Spring数据连接Elasticsearch"><a href="#使用Spring数据连接Elasticsearch" class="headerlink" title="使用Spring数据连接Elasticsearch"></a>使用Spring数据连接Elasticsearch</h3><p>要连接到Elasticsearch，您必须提供一个或多个群集节点的地址。可以通过将<code>spring.data.elasticsearch.cluster-nodes</code> 属性设置为逗号分隔<code>host:port</code>列表来指定地址。使用此配置， 可以像任何其他Spring bean一样注入<code>ElasticsearchTemplate</code>或<code>TransportClient</code>注入，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.elasticsearch.cluster-nodes=localhost:9300</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ElasticsearchTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您添加自己的<code>ElasticsearchTemplate</code>或<code>TransportClient</code> <code>@Bean</code>，它将替换默认值。</p>
<h3 id="Spring-Data-Elasticsearch存储库"><a href="#Spring-Data-Elasticsearch存储库" class="headerlink" title="Spring Data Elasticsearch存储库"></a>Spring Data Elasticsearch存储库</h3><p>Spring Data包括对Elasticsearch的存储库支持。与前面讨论的JPA存储库一样，基本原则是根据方法名称自动为您构建查询。</p>
<p>事实上，Spring Data JPA和Spring Data Elasticsearch共享相同的通用基础架构。您可以从之前的JPA示例中获取，假设它<code>City</code>现在是Elasticsearch <code>@Document</code>类而不是JPA <code>@Entity</code>，它的工作方式相同。</p>
<blockquote>
<p>有关Spring Data Elasticsearch的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/elasticsearch/docs/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p><a href="https://cassandra.apache.org/" target="_blank" rel="noopener">Cassandra</a>是一个开源的分布式数据库管理系统，旨在处理许多商用服务器上的大量数据。Spring Boot提供了Cassandra的自动配置以及<a href="https://github.com/spring-projects/spring-data-cassandra" target="_blank" rel="noopener">Spring Data Cassandra</a>提供的抽象。有一个<code>spring-boot-starter-data-cassandra</code>启动器用于以方便的方式收集依赖项。</p>
<h3 id="连接到Cassandra"><a href="#连接到Cassandra" class="headerlink" title="连接到Cassandra"></a>连接到Cassandra</h3><p>您可以像使用任何其他Spring Bean一样注入自动配置<code>CassandraTemplate</code>或Cassandra <code>Session</code>实例。这些<code>spring.data.cassandra.*</code>属性可用于自定义连接。通常，您提供<code>keyspace-name</code>和 <code>contact-points</code>属性，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.data.cassandra.keyspace-name=mykeyspace</span><br><span class="line">spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2</span><br></pre></td></tr></table></figure>
<p>您还可以注册任意数量的bean，以实现 <code>ClusterBuilderCustomizer</code>更高级的自定义。</p>
<p>以下代码清单显示了如何注入Cassandra bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> CassandraTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CassandraTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加自己<code>@Bean</code>的类型<code>CassandraTemplate</code>，则会替换默认值。</p>
<h3 id="Spring-Data-Cassandra存储库"><a href="#Spring-Data-Cassandra存储库" class="headerlink" title="Spring Data Cassandra存储库"></a>Spring Data Cassandra存储库</h3><p>Spring Data包含对Cassandra的基本存储库支持。目前，这比前面讨论的JPA存储库更有限，需要使用注释查找器方法<code>@Query</code>。</p>
<blockquote>
<p>有关Spring Data Cassandra的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/cassandra/docs/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h2><p><a href="https://www.couchbase.com/" target="_blank" rel="noopener">Couchbase</a>是一个开源的，分布式的，多模型的NoSQL面向文档的数据库，针对交互式应用程序进行了优化。Spring Boot提供了Couchbase的自动配置以及<a href="https://github.com/spring-projects/spring-data-couchbase" target="_blank" rel="noopener">Spring Data Couchbase</a>提供的抽象 。有一个 <code>spring-boot-starter-data-couchbase</code>和<code>spring-boot-starter-data-couchbase-reactive</code> 启动器方便的方法收集的依赖关系。</p>
<h3 id="连接到Couchbase"><a href="#连接到Couchbase" class="headerlink" title="连接到Couchbase"></a>连接到Couchbase</h3><p>你可以得到一个<code>Bucket</code>和<code>Cluster</code>通过添加Couchbase SDK和一些配置。这些<code>spring.couchbase.*</code>属性可用于自定义连接。通常，您提供引导主机，存储桶名称和密码，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123</span><br><span class="line">spring.couchbase.bucket.name=my-bucket</span><br><span class="line">spring.couchbase.bucket.password=secret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您需要<em>至少</em>提供引导主机，在这种情况下，存储桶名称为 <code>default</code>，密码为空字符串。或者，您可以定义自己的<code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code> <code>@Bean</code>控件来控制整个配置。</p>
</blockquote>
<p>也可以自定义一些<code>CouchbaseEnvironment</code>设置。例如，以下配置更改用于打开新的超时<code>Bucket</code> 并启用SSL支持的超时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.couchbase.env.timeouts.connect=3000</span><br><span class="line">spring.couchbase.env.ssl.key-store=/location/of/keystore.jks</span><br><span class="line">spring.couchbase.env.ssl.key-store-password=secret</span><br></pre></td></tr></table></figure>
<p>检查<code>spring.couchbase.env.*</code>属性以获取更多详细信息。</p>
<h3 id="Spring-Data-Couchbase存储库"><a href="#Spring-Data-Couchbase存储库" class="headerlink" title="Spring Data Couchbase存储库"></a>Spring Data Couchbase存储库</h3><p>Spring Data包括对Couchbase的存储库支持。有关Spring Data Couchbase的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/" target="_blank" rel="noopener">参考文档</a>。</p>
<p>您可以<code>CouchbaseTemplate</code>像使用任何其他Spring Bean一样注入自动配置的实例，只要有<em>默认值</em> <code>CouchbaseConfigurer</code>（当您启用Couchbase支持时会发生这种情况，如前所述）。</p>
<p>以下示例显示了如何注入Couchbase bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> CouchbaseTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CouchbaseTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在自己的配置中定义一些bean来覆盖自动配置提供的bean：</p>
<ul>
<li><code>CouchbaseTemplate</code> <code>@Bean</code>的名字是<code>couchbaseTemplate</code>。</li>
<li><code>IndexManager</code> <code>@Bean</code>用的名称<code>couchbaseIndexManager</code>。</li>
<li><code>CustomConversions</code> <code>@Bean</code>的名字是<code>couchbaseCustomConversions</code>。</li>
</ul>
<p>为避免在您自己的配置中对这些名称进行硬编码，您可以重复使用<code>BeanNames</code>Spring Data Couchbase。例如，您可以自定义要使用的转换器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span>(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> CustomConversions <span class="title">myCustomConversions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CustomConversions(...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要完全绕过Spring Data Couchbase的自动配置，请提供自己的实现<code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code>。</p>
</blockquote>
<h2 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h2><p><a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" target="_blank" rel="noopener">LDAP</a>（轻量级目录访问协议）是一种开放的，与供应商无关的行业标准应用程序协议，用于通过IP网络访问和维护分布式目录信息服务。Spring Boot为任何兼容的LDAP服务器提供自动配置，并为<a href="https://www.ldap.com/unboundid-ldap-sdk-for-java" target="_blank" rel="noopener">UnboundID</a>支持嵌入式内存中LDAP服务器 。</p>
<p>LDAP抽象由 <a href="https://github.com/spring-projects/spring-data-ldap" target="_blank" rel="noopener">Spring Data LDAP提供</a>。有一个<code>spring-boot-starter-data-ldap</code>启动器用于以方便的方式收集依赖项。</p>
<h3 id="连接LDAP服务器"><a href="#连接LDAP服务器" class="headerlink" title="连接LDAP服务器"></a>连接LDAP服务器</h3><p>要连接到LDAP服务器，请确保声明对<code>spring-boot-starter-data-ldap</code>启动器 的依赖关系 <code>spring-ldap-core</code>，然后在application.properties中声明服务器的URL，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.urls=ldap://myserver:1235</span><br><span class="line">spring.ldap.username=admin</span><br><span class="line">spring.ldap.password=secret</span><br></pre></td></tr></table></figure>
<p>如果需要自定义连接设置，可以使用<code>spring.ldap.base</code>和 <code>spring.ldap.base-environment</code>属性。</p>
<p>一种<code>LdapContextSource</code>是自动配置基于这些设置。如果您需要自定义它，例如使用a <code>PooledContextSource</code>，您仍然可以注入自动配置<code>LdapContextSource</code>。确保将自定义标记<code>ContextSource</code>为<code>@Primary</code>自动配置<code>LdapTemplate</code>使用它。</p>
<h3 id="Spring-Data-LDAP存储库"><a href="#Spring-Data-LDAP存储库" class="headerlink" title="Spring Data LDAP存储库"></a>Spring Data LDAP存储库</h3><p>Spring Data包括对LDAP的存储库支持。有关Spring Data LDAP的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/" target="_blank" rel="noopener">参考文档</a>。</p>
<p>您也可以<code>LdapTemplate</code>像使用任何其他Spring Bean一样注入自动配置的实例，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LdapTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(LdapTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌入式内存LDAP服务器"><a href="#嵌入式内存LDAP服务器" class="headerlink" title="嵌入式内存LDAP服务器"></a>嵌入式内存LDAP服务器</h3><p>出于测试目的，Spring Boot支持从<a href="https://www.ldap.com/unboundid-ldap-sdk-for-java" target="_blank" rel="noopener">UnboundID</a>自动配置内存中的LDAP服务器。要配置服务器，请向依赖项添加依赖项<code>com.unboundid:unboundid-ldapsdk</code>并声明<code>base-dn</code>属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.embedded.base-dn=dc=spring,dc=io</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以定义多个base-dn值，但是，由于可分辨名称通常包含逗号，因此必须使用正确的表示法定义它们。</p>
<p>在yaml文件中，您可以使用yaml列表表示法：</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.ldap.embedded.base-dn:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dc=spring,dc=io</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dc=pivotal,dc=io</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在属性文件中，必须包含索引作为属性名称的一部分：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.embedded.base-dn[0]=dc=spring,dc=io</span><br><span class="line">spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io</span><br></pre></td></tr></table></figure>
<p>默认情况下，服务器在随机端口上启动并触发常规LDAP支持。无需指定<code>spring.ldap.urls</code>属性。</p>
<p>如果<code>schema.ldif</code>类路径中有文件，则用于初始化服务器。如果要从其他资源加载初始化脚本，还可以使用该<code>spring.ldap.embedded.ldif</code>属性。</p>
<p>默认情况下，标准模式用于验证<code>LDIF</code>文件。您可以通过设置<code>spring.ldap.embedded.validation.enabled</code>属性完全关闭验证。如果您有自定义属性，则可以使用它<code>spring.ldap.embedded.validation.schema</code>来定义自定义属性类型或对象类。</p>
<h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><p><a href="https://www.influxdata.com/" target="_blank" rel="noopener">InfluxDB</a>是一个开源时间序列数据库，针对运营监控，应用程序指标，物联网传感器数据和实时分析等领域中的时间序列数据的快速，高可用性存储和检索进行了优化。</p>
<h3 id="连接到InfluxDB"><a href="#连接到InfluxDB" class="headerlink" title="连接到InfluxDB"></a>连接到InfluxDB</h3><p><code>InfluxDB</code>如果<code>influxdb-java</code>客户端在类路径上并且设置了数据库的URL，则Spring Boot会自动配置实例，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.influx.url=http://172.0.0.1:8086</span><br></pre></td></tr></table></figure>
<p>如果与InfluxDB的连接需要用户和密码，则可以相应地设置 <code>spring.influx.user</code>和<code>spring.influx.password</code>属性。</p>
<p>InfluxDB依赖于OkHttp。如果需要调整http客户端<code>InfluxDB</code>在幕后使用，可以注册一个<code>InfluxDbOkHttpClientBuilderProvider</code>bean。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-NoSQL数据库/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/20/使用SpringBoot-SQL数据库/">使用SpringBoot-SQL数据库</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/sql/">sql</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/database/">database</a></div></div><div class="post-content"><div class="main-content content"><h1 id="SQL数据库"><a href="#SQL数据库" class="headerlink" title="SQL数据库"></a>SQL数据库</h1><p>在<a href="https://projects.spring.io/spring-framework/" target="_blank" rel="noopener">Spring框架</a>提供了广泛的支持使用使用SQL数据库，直接JDBC访问<code>JdbcTemplate</code>来完成“对象关系映射”技术，比如Hibernate。<a href="https://projects.spring.io/spring-data/" target="_blank" rel="noopener">Spring Data</a>提供了更多级别的功能：<code>Repository</code>直接从接口创建实现，并使用约定从方法名称生成查询。</p>
<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>Java的<code>javax.sql.DataSource</code>接口提供了一种使用数据库连接的标准方法。传统上，’DataSource’使用<code>URL</code>一些凭证来建立数据库连接。</p>
<blockquote>
<p>有关更多高级示例，请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-a-datasource" target="_blank" rel="noopener">“操作方法”</a>，通常可以完全控制DataSource的配置。</p>
</blockquote>
<h3 id="嵌入式数据库支持"><a href="#嵌入式数据库支持" class="headerlink" title="嵌入式数据库支持"></a>嵌入式数据库支持</h3><p>通过使用内存中的嵌入式数据库来开发应用程序通常很方便。显然，内存数据库不提供持久存储。您需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。</p>
<blockquote>
<p>“操作方法”部分包含<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-database-initialization" target="_blank" rel="noopener">有关如何初始化数据库的部分</a>。</p>
</blockquote>
<p>Spring Boot可以自动配置嵌入式<a href="http://www.h2database.com/" target="_blank" rel="noopener">H2</a>， <a href="http://hsqldb.org/" target="_blank" rel="noopener">HSQL</a>和<a href="https://db.apache.org/derby/" target="_blank" rel="noopener">Derby</a>数据库。您无需提供任何连接URL。您只需要包含要使用的嵌入式数据库的构建依赖项。</p>
<blockquote>
<p>如果您在测试中使用此功能，您可能会注意到整个测试套件都会重复使用相同的数据库，而不管您使用的应用程序上下文的数量。如果要确保每个上下文都有一个单独的嵌入式数据库，则应设置<code>spring.datasource.generate-unique-name</code>为<code>true</code>。</p>
</blockquote>
<p>例如，典型的POM依赖关系如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>您需要依赖于<code>spring-jdbc</code>自动配置嵌入式数据库。在这个例子中，它被传递过来 <code>spring-boot-starter-data-jpa</code>。</p>
</blockquote>
<blockquote>
<p>如果由于某种原因，您确实为嵌入式数据库配置了连接URL，请注意确保禁用数据库的自动关闭。如果你使用H2，你应该<code>DB_CLOSE_ON_EXIT=FALSE</code>这样做。如果使用HSQLDB，则应确保<code>shutdown=true</code>未使用HSQLDB 。禁用数据库的自动关闭可以在数据库关闭时进行Spring Boot控制，从而确保在不再需要访问数据库时发生。</p>
</blockquote>
<h3 id="连接到生产数据库"><a href="#连接到生产数据库" class="headerlink" title="连接到生产数据库"></a>连接到生产数据库</h3><p>也可以使用池自动配置生产数据库连接 <code>DataSource</code>。Spring Boot使用以下算法来选择特定的实现：</p>
<ol>
<li>我们更喜欢<a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">HikariCP</a>的性能和并发性。如果HikariCP可用，我们总是选择它。</li>
<li>否则，如果Tomcat池<code>DataSource</code>可用，我们将使用它。</li>
<li>如果HikariCP和Tomcat池化数据源都不可用，并且 <a href="https://commons.apache.org/proper/commons-dbcp/" target="_blank" rel="noopener">Commons DBCP2</a>可用，我们就会使用它。</li>
</ol>
<p>如果您使用<code>spring-boot-starter-jdbc</code>或<code>spring-boot-starter-data-jpa</code>启动器，您将自动获得依赖<code>HikariCP</code>。</p>
<blockquote>
<p>您可以完全绕过该算法，并通过设置<code>spring.datasource.type</code>属性指定要使用的连接池。如果您在Tomcat容器中运行应用程序<code>tomcat-jdbc</code>（默认情况下提供），这一点尤为重要。</p>
</blockquote>
<blockquote>
<p>始终可以手动配置其他连接池。如果您定义自己的<code>DataSource</code>bean，则不会进行自动配置。</p>
</blockquote>
<p>DataSource配置由外部配置属性控制 <code>spring.datasource.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost/test</span><br><span class="line">spring.datasource.username=dbuser</span><br><span class="line">spring.datasource.password=dbpass</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您至少应该通过设置<code>spring.datasource.url</code> 属性来指定URL 。否则，Spring Boot会尝试自动配置嵌入式数据库。</p>
</blockquote>
<blockquote>
<p>您通常不需要指定<code>driver-class-name</code>，因为Spring Boot可以从大多数数据库推断它<code>url</code>。</p>
</blockquote>
<blockquote>
<p>对于<code>DataSource</code>要创建的池，我们需要能够验证有效的 <code>Driver</code>类是否可用，因此我们在执行任何操作之前检查它。换句话说，如果你设置<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>，那么该类必须是可加载的。</p>
</blockquote>
<p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java" target="_blank" rel="noopener"><code>DataSourceProperties</code></a> 更多支持的选项，请参阅 。无论实际实施如何，这些都是标准选项。也可以微调实现特定的设置，使用各自的前缀（<code>spring.datasource.hikari.*</code>， <code>spring.datasource.tomcat.*</code>，和<code>spring.datasource.dbcp2.*</code>）。有关更多详细信息，请参阅您正在使用的连接池实现的文档。</p>
<p>例如，如果使用 <a href="https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes" target="_blank" rel="noopener">Tomcat连接池</a>，则可以自定义许多其他设置，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">＃如果没有可用连接，则在抛出异常之前要等待的ms数。</span><br><span class="line">spring.datasource.tomcat.max-wait = 10000</span><br><span class="line"></span><br><span class="line">＃可以同时从该池分配的最大活动连接数。</span><br><span class="line">spring.datasource.tomcat.max-active = 50</span><br><span class="line"></span><br><span class="line">＃在从池中借用连接之前验证连接。</span><br><span class="line">spring.datasource.tomcat.test-on-borrow = true</span><br></pre></td></tr></table></figure>
<h3 id="连接到JNDI数据源"><a href="#连接到JNDI数据源" class="headerlink" title="连接到JNDI数据源"></a>连接到JNDI数据源</h3><p>如果将Spring Boot应用程序部署到Application Server，则可能需要使用Application Server的内置功能配置和管理DataSource，并使用JNDI访问它。</p>
<p>该<code>spring.datasource.jndi-name</code>属性可以被用作一个替代 <code>spring.datasource.url</code>，<code>spring.datasource.username</code>和<code>spring.datasource.password</code>属性来访问<code>DataSource</code>从一个特定的JNDI位置。例如，以下部分<code>application.properties</code>显示了如何访问定义的JBoss AS <code>DataSource</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.jndi-name=java:jboss/datasources/customers</span><br></pre></td></tr></table></figure>
<h2 id="使用JdbcTemplate"><a href="#使用JdbcTemplate" class="headerlink" title="使用JdbcTemplate"></a>使用JdbcTemplate</h2><p>Spring <code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>类是自动配置的，您可以<code>@Autowire</code>直接将它们放入自己的bean中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>spring.jdbc.template.*</code> 属性自定义模板的某些属性，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jdbc.template.max-rows=500</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>NamedParameterJdbcTemplate</code>重复使用相同的<code>JdbcTemplate</code>幕后情况。如果<code>JdbcTemplate</code>定义了多个且没有主要候选项，<code>NamedParameterJdbcTemplate</code>则不会自动配置。</p>
</blockquote>
<h2 id="JPA和Spring-Data-JPA"><a href="#JPA和Spring-Data-JPA" class="headerlink" title="JPA和Spring Data JPA"></a>JPA和Spring Data JPA</h2><p>Java Persistence API是一种标准技术，可让您将对象“映射”到关系数据库。该<code>spring-boot-starter-data-jpa</code>POM提供了上手的快捷方式。它提供以下关键依赖项：</p>
<ul>
<li>Hibernate：最受欢迎的JPA实现之一。</li>
<li>Spring Data JPA：使实现基于JPA的存储库变得容易。</li>
<li>Spring ORMs：Spring Framework的核心ORM支持。</li>
</ul>
<blockquote>
<p>我们不会在这里详细介绍JPA或<a href="https://projects.spring.io/spring-data/" target="_blank" rel="noopener">Spring Data</a>。您可以按照<a href="https://spring.io/guides/gs/accessing-data-jpa/" target="_blank" rel="noopener">“访问数据与JPA”</a> 从指导<a href="https://spring.io/" target="_blank" rel="noopener">spring.io</a>并宣读了<a href="https://projects.spring.io/spring-data-jpa/" target="_blank" rel="noopener">春天的数据JPA</a>和 <a href="https://hibernate.org/orm/documentation/" target="_blank" rel="noopener">Hibernate的</a>参考文档。</p>
</blockquote>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>传统上，JPA“实体”类在<code>persistence.xml</code>文件中指定。使用Spring Boot，此文件不是必需的，而是使用“实体扫描”。默认情况下，将搜索主配置类（注释为<code>@EnableAutoConfiguration</code>或者<code>@SpringBootApplication</code>）下的所有包 。</p>
<p>任何类别标注了<code>@Entity</code>，<code>@Embeddable</code>或者<code>@MappedSuperclass</code>被认为是。典型的实体类类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue</span></span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...其他成员，通常包括@OneToMany映射</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//JPA规范要求的no-args构造函数</span></span><br><span class="line">		<span class="comment">//这个是受保护的，因为它不应该直接使用</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ... etc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您可以使用<code>@EntityScan</code>注释自定义实体扫描位置。请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration" target="_blank" rel="noopener">第84.4节</a> ” <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration" target="_blank" rel="noopener">，“从Spring配置中分离@Entity定义”</a> “ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration" target="_blank" rel="noopener">操作方法”</a>。</p>
</blockquote>
<h3 id="Spring-Data-JPA存储库"><a href="#Spring-Data-JPA存储库" class="headerlink" title="Spring Data JPA存储库"></a>Spring Data JPA存储库</h3><p><a href="https://projects.spring.io/spring-data-jpa/" target="_blank" rel="noopener">Spring Data JPA</a>存储库是您可以定义以访问数据的接口。JPA查询是从您的方法名称自动创建的。例如， <code>CityRepository</code>接口可能会声明一种<code>findAllByState(String state)</code>方法来查找给定状态中的所有城市。</p>
<p>对于更复杂的查询，您可以使用Spring Data的<a href="https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/Query.html" target="_blank" rel="noopener"><code>Query</code></a>注释来注释您的方法 。</p>
<p>Spring Data存储库通常从<a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/Repository.html" target="_blank" rel="noopener"><code>Repository</code></a>或 <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html" target="_blank" rel="noopener"><code>CrudRepository</code></a> 接口扩展 。如果使用自动配置，则会从包含主配置类（带有<code>@EnableAutoConfiguration</code>或标注的<code>@SpringBootApplication</code>）的包中搜索存储库 。</p>
<p>以下示例显示了典型的Spring Data存储库接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">	<span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data JPA存储库支持三种不同的引导模式：default，deferred和lazy。要启用延迟或延迟引导，请分别设置<code>spring.data.jpa.repositories.bootstrap-mode</code>为<code>deferred</code>或<code>lazy</code>。使用延迟或延迟引导时，自动配置<code>EntityManagerFactoryBuilder</code> 将使用上下文（<code>AsyncTaskExecutor</code>如果有）作为引导程序执行程序。如果存在多个，则使用命名的那个<code>applicationTaskExecutor</code>。</p>
<blockquote>
<p>我们几乎没有涉及Spring Data JPA的表面。有关完整的详细信息，请参阅<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" target="_blank" rel="noopener">Spring Data JPA参考文档</a>。</p>
</blockquote>
<h3 id="创建和删除JPA数据库"><a href="#创建和删除JPA数据库" class="headerlink" title="创建和删除JPA数据库"></a>创建和删除JPA数据库</h3><p>默认情况下，<strong>仅</strong>当您使用嵌入式数据库（H2，HSQL或Derby）时，<strong>才会</strong>自动创建JPA数据库。您可以使用<code>spring.jpa.*</code>属性显式配置JPA设置 。例如，要创建和删除表，您可以将以下行添加到<code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.ddl-auto=create-drop</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Hibernate自己的内部属性名称（如果你碰巧记得更好）是<code>hibernate.hbm2ddl.auto</code>。您可以使用<code>spring.jpa.properties.*</code>（在将它们添加到实体管理器之前剥离前缀）来设置它以及其他Hibernate本机属性。以下行显示了为Hibernate设置JPA属性的示例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.globally_quoted_identifiers=true</span><br></pre></td></tr></table></figure>
<p>在前面的示例中的线穿过的一个值<code>true</code>的 <code>hibernate.globally_quoted_identifiers</code>属性设置为休眠实体管理器。</p>
<p>默认情况下，DDL执行（或验证）将延迟到<code>ApplicationContext</code> 启动。还有一个<code>spring.jpa.generate-ddl</code>标志，但如果Hibernate自动配置处于活动状态，则不会使用该标志，因为<code>ddl-auto</code>设置更精细。</p>
<h3 id="在View中打开EntityManager"><a href="#在View中打开EntityManager" class="headerlink" title="在View中打开EntityManager"></a>在View中打开EntityManager</h3><p>如果您正在运行Web应用程序，则默认情况下Spring Boot会注册 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html" target="_blank" rel="noopener"><code>OpenEntityManagerInViewInterceptor</code></a> 以应用“在视图中打开EntityManager”模式，以允许在Web视图中进行延迟加载。如果你不希望这种行为，你应该设置<code>spring.jpa.open-in-view</code>到 <code>false</code>你<code>application.properties</code>。</p>
<h2 id="Spring-Data-JDBC"><a href="#Spring-Data-JDBC" class="headerlink" title="Spring Data JDBC"></a>Spring Data JDBC</h2><p>Spring Data包含对JDBC的存储库支持，并将自动为方法生成SQL <code>CrudRepository</code>。对于更高级的查询，<code>@Query</code>提供了注释。</p>
<p>当必要的依赖项在类路径上时，Spring Boot将自动配置Spring Data的JDBC存储库。它们可以通过单个依赖项添加到项目中<code>spring-boot-starter-data-jdbc</code>。如有必要，您可以通过向应用程序添加<code>@EnableJdbcRepositories</code>注释或 <code>JdbcConfiguration</code>子类来控制Spring Data JDBC的配置。</p>
<blockquote>
<p>有关Spring Data JDBC的完整详细信息，请参阅 <a href="https://projects.spring.io/spring-data-jdbc/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="使用H2的Web控制台"><a href="#使用H2的Web控制台" class="headerlink" title="使用H2的Web控制台"></a>使用H2的Web控制台</h2><p>该<a href="http://www.h2database.com/" target="_blank" rel="noopener">H2数据库</a>提供了一个 <a href="http://www.h2database.com/html/quickstart.html#h2_console" target="_blank" rel="noopener">基于浏览器的控制台</a>,Spring启动即可自动配置。满足以下条件时，将自动配置控制台：</p>
<ul>
<li>您正在开发基于servlet的Web应用程序。</li>
<li><code>com.h2database:h2</code> 在类路径上。</li>
<li>您正在使用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#using-boot-devtools" target="_blank" rel="noopener">Spring Boot的开发人员工具</a>。</li>
</ul>
<blockquote>
<p>如果您没有使用Spring Boot的开发人员工具但仍希望使用H2的控制台，则可以<code>spring.h2.console.enabled</code>使用值配置属性<code>true</code>。</p>
</blockquote>
<blockquote>
<p>H2控制台仅用于开发期间，因此您应该注意确保<code>spring.h2.console.enabled</code>在生产中不要设置为<code>true</code>。</p>
</blockquote>
<h3 id="更改H2控制台的路径"><a href="#更改H2控制台的路径" class="headerlink" title="更改H2控制台的路径"></a>更改H2控制台的路径</h3><p>默认情况下，控制台可用于<code>/h2-console</code>。您可以使用该<code>spring.h2.console.path</code>属性自定义控制台的路径。</p>
<h2 id="使用jOOQ"><a href="#使用jOOQ" class="headerlink" title="使用jOOQ"></a>使用jOOQ</h2><p>Java面向对象查询（<a href="http://www.jooq.org/" target="_blank" rel="noopener">jOOQ</a>）是<a href="http://www.datageekery.com/" target="_blank" rel="noopener">Data Geekery的</a>一个流行产品， 它从您的数据库生成Java代码，并允许您通过其流畅的API构建类型安全的SQL查询。商业版和开源版都可以与Spring Boot一起使用。</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>为了使用jOOQ类型安全查询，您需要从数据库模式生成Java类。您可以按照<a href="https://www.jooq.org/doc/3.11.9/manual-single-page/#jooq-in-7-steps-step3" target="_blank" rel="noopener">jOOQ用户手册中</a>的说明进行 <a href="https://www.jooq.org/doc/3.11.9/manual-single-page/#jooq-in-7-steps-step3" target="_blank" rel="noopener">操作</a>。如果您使用该 <code>jooq-codegen-maven</code>插件并且还使用<code>spring-boot-starter-parent</code> “父POM”，则可以安全地省略插件的<code>&lt;version&gt;</code>标签。您还可以使用Spring Boot定义的版本变量（例如<code>h2.version</code>）来声明插件的数据库依赖性。以下清单显示了一个示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jooq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">		...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;h2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jdbc</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">driver</span>&gt;</span>org.h2.Driver<span class="tag">&lt;/<span class="name">driver</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:h2:~/yourdatabase<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">jdbc</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">generator</span>&gt;</span></span><br><span class="line">			...</span><br><span class="line">		<span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用DSLContext"><a href="#使用DSLContext" class="headerlink" title="使用DSLContext"></a>使用DSLContext</h3><p>jOOQ提供的流畅API通过<code>org.jooq.DSLContext</code>界面启动。Spring Boot自动配置<code>DSLContext</code>为Spring Bean并将其连接到您的应用程序<code>DataSource</code>。要使用<code>DSLContext</code>，您可以使用<code>@Autowire</code>它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JooqExample</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> DSLContext create;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JooqExample</span><span class="params">(DSLContext dslContext)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.create = dslContext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>jOOQ手册倾向于使用一个名为<code>create</code>hold的变量<code>DSLContext</code>。</p>
</blockquote>
<p>然后，您可以使用它<code>DSLContext</code>来构建查询，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;GregorianCalendar&gt; <span class="title">authorsBornAfter1980</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.create.selectFrom(AUTHOR)</span><br><span class="line">		.where(AUTHOR.DATE_OF_BIRTH.greaterThan(<span class="keyword">new</span> GregorianCalendar(<span class="number">1980</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">		.fetch(AUTHOR.DATE_OF_BIRTH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jOOQ-SQL方言"><a href="#jOOQ-SQL方言" class="headerlink" title="jOOQ SQL方言"></a>jOOQ SQL方言</h3><p>除非<code>spring.jooq.sql-dialect</code>已配置该属性，否则Spring Boot会确定用于数据源的SQL方言。如果Spring Boot无法检测到方言，则使用<code>DEFAULT</code>。</p>
<blockquote>
<p>Spring Boot只能自动配置开源版本的jOOQ支持的方言。</p>
</blockquote>
<h3 id="自定义jOOQ"><a href="#自定义jOOQ" class="headerlink" title="自定义jOOQ"></a>自定义jOOQ</h3><p>通过定义自己的<code>@Bean</code>定义可以实现更高级的自定义，这些定义在<code>Configuration</code>创建jOOQ时使用。您可以为以下jOOQ类型定义bean：</p>
<ul>
<li><code>ConnectionProvider</code></li>
<li><code>ExecutorProvider</code></li>
<li><code>TransactionProvider</code></li>
<li><code>RecordMapperProvider</code></li>
<li><code>RecordUnmapperProvider</code></li>
<li><code>RecordListenerProvider</code></li>
<li><code>ExecuteListenerProvider</code></li>
<li><code>VisitListenerProvider</code></li>
<li><code>TransactionListenerProvider</code></li>
</ul>
<p><code>org.jooq.Configuration</code> <code>@Bean</code>如果要完全控制jOOQ配置，也可以创建自己的。</p>
</div></div><a class="button-hover more" href="/2019/03/20/使用SpringBoot-SQL数据库/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/20/使用SpringBoot-Security/">使用SpringBoot-Security</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-20</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/security/">security</a></div></div><div class="post-content"><div class="main-content content"><h2 id="Security-安全"><a href="#Security-安全" class="headerlink" title="Security(安全)"></a>Security(安全)</h2><p>如果<a href="https://projects.spring.io/spring-security/" target="_blank" rel="noopener">Spring Security</a>位于类路径上，则默认情况下Web应用程序是安全的。Spring Boot依赖于Spring Security的内容协商策略来确定是否使用<code>httpBasic</code>或<code>formLogin</code>。要向Web应用程序添加方法级安全性，您还可以<code>@EnableGlobalMethodSecurity</code>使用所需的设置进行添加。其他信息可以在 <a href="https://docs.spring.io/spring-security/site/docs/5.1.4.RELEASE/reference/htmlsingle#jc-method" target="_blank" rel="noopener">Spring Security Reference Guide中找到</a>。</p>
<p>默认设置<code>UserDetailsService</code>只有一个用户。用户名是<code>user</code>，密码是随机的，在应用程序启动时以INFO级别打印，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用生成的安全密码：78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您对日志记录配置进行微调，请确保将 <code>org.springframework.boot.autoconfigure.security</code>类别设置为log <code>INFO</code>-level messages。否则，不会打印默认密码。</p>
</blockquote>
<p>您可以通过提供<code>spring.security.user.name</code>和 更改用户名和密码<code>spring.security.user.password</code>。</p>
<p>您在Web应用程序中默认获得的基本功能包括：</p>
<ul>
<li>A <code>UserDetailsService</code>（或<code>ReactiveUserDetailsService</code>WebFlux应用程序的情况）bean具有内存存储，单个用户具有生成的密码（请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html" target="_blank" rel="noopener"><code>SecurityProperties.User</code></a> 用户的属性）。</li>
<li>基于表单的登录或HTTP基本安全性（取决于Content-Type）用于整个应用程序（如果执行器在类路径上，则包括执行器端点）。</li>
<li>一个<code>DefaultAuthenticationEventPublisher</code>用于发布身份验证事件。</li>
</ul>
<p>你可以<code>AuthenticationEventPublisher</code>通过为它添加一个bean 来提供不同的东西。</p>
<h3 id="MVC安全性"><a href="#MVC安全性" class="headerlink" title="MVC安全性"></a>MVC安全性</h3><p>默认安全配置在<code>SecurityAutoConfiguration</code>和中 实现<code>UserDetailsServiceAutoConfiguration</code>。<code>SecurityAutoConfiguration</code>导入<code>SpringBootWebSecurityConfiguration</code>Web安全性并 <code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这也与非Web应用程序相关。要完全关闭默认Web应用程序安全配置，您可以添加类型的bean <code>WebSecurityConfigurerAdapter</code>（这样做不会禁用<code>UserDetailsService</code>配置或Actuator的安全性）。</p>
<p>为了还关闭<code>UserDetailsService</code>的配置，您可以添加类型的豆 <code>UserDetailsService</code>，<code>AuthenticationProvider</code>或<code>AuthenticationManager</code>。<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/" target="_blank" rel="noopener">Spring Boot示例中</a>有几个安全的应用程序可以帮助您开始使用常见的用例。</p>
<p>可以通过添加自定义来覆盖访问规则<code>WebSecurityConfigurerAdapter</code>。Spring Boot提供了便捷方法，可用于覆盖执行器端点和静态资源的访问规则。<code>EndpointRequest</code>可用于创建<code>RequestMatcher</code> 基于<code>management.endpoints.web.base-path</code>属性的。 <code>PathRequest</code>可用于<code>RequestMatcher</code>在常用位置创建资源。</p>
<h3 id="WebFlux安全性"><a href="#WebFlux安全性" class="headerlink" title="WebFlux安全性"></a>WebFlux安全性</h3><p>与Spring MVC应用程序类似，您可以通过添加<code>spring-boot-starter-security</code>依赖项来保护WebFlux应用程序。默认安全配置在<code>ReactiveSecurityAutoConfiguration</code>和中 实现<code>UserDetailsServiceAutoConfiguration</code>。<code>ReactiveSecurityAutoConfiguration</code>导入<code>WebFluxSecurityConfiguration</code>Web安全性并<code>UserDetailsServiceAutoConfiguration</code> 配置身份验证，这也与非Web应用程序相关。要完全关闭默认Web应用程序安全配置，您可以添加类型的bean <code>WebFilterChainProxy</code>（这样做不会禁用<code>UserDetailsService</code>配置或Actuator的安全性）。</p>
<p>要关闭<code>UserDetailsService</code>配置，可以添加类型为<code>ReactiveUserDetailsService</code>或的bean <code>ReactiveAuthenticationManager</code>。</p>
<p>可以通过添加自定义来配置访问规则<code>SecurityWebFilterChain</code>。Spring Boot提供了便捷方法，可用于覆盖执行器端点和静态资源的访问规则。<code>EndpointRequest</code>可用于创建 <code>ServerWebExchangeMatcher</code>基于<code>management.endpoints.web.base-path</code> 属性的。</p>
<p><code>PathRequest</code>可用于<code>ServerWebExchangeMatcher</code>在常用位置创建资源。</p>
<p>例如，您可以通过添加以下内容来自定义安全配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityWebFilterChain <span class="title">springSecurityFilterChain</span><span class="params">(ServerHttpSecurity http)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> http.authorizeExchange()</span><br><span class="line">			.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()</span><br><span class="line">			.pathMatchers(<span class="string">"/foo"</span>, <span class="string">"/bar"</span>)</span><br><span class="line">			.authenticated().and()</span><br><span class="line">			.formLogin().and()</span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><p><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth2</a>是Spring支持的一种广泛使用的授权框架。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>如果您具有<code>spring-security-oauth2-client</code>类路径，则可以利用某些自动配置来轻松设置OAuth2 / Open ID Connect客户端。此配置使用下的属性<code>OAuth2ClientProperties</code>。相同的属性适用于servlet和反应式应用程序。</p>
<p>您可以在<code>spring.security.oauth2.client</code>前缀下注册多个OAuth2客户端和提供程序 ，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.registration.my-client-1.client-id=abcd</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.client-secret=password</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.scope=user</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.redirect-uri-template=http://my-redirect-uri.com</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code</span><br><span class="line"></span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-id=abcd</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-secret=password</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.scope=email</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.redirect-uri-template=http://my-redirect-uri.com</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code</span><br><span class="line"></span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=http://my-auth-server/oauth/authorize</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.token-uri=http://my-auth-server/oauth/token</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=http://my-auth-server/userinfo</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=http://my-auth-server/token_keys</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</span><br></pre></td></tr></table></figure>
<p>对于支持<a href="https://openid.net/specs/openid-connect-discovery-1_0.html" target="_blank" rel="noopener">OpenID Connect发现的</a> OpenID Connect提供程序，可以进一步简化配置。需要为提供程序配置一个<code>issuer-uri</code>URI，它将其声明为其颁发者标识符。例如，如果 <code>issuer-uri</code>提供的是“<a href="https://example.com”，`OpenID" target="_blank" rel="noopener">https://example.com”，`OpenID</a> Provider Configuration Request<code>则会进行“https://example.com/.well-known/openid-configuration”。结果预计是一个</code>OpenID Provider Configuration Response<code>。以下示例显示如何使用以下命令配置OpenID Connect Provider</code>issuer-uri`：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.provider.oidc-provider.issuer-uri = https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></td></tr></table></figure>
<p>默认情况下，Spring Security <code>OAuth2LoginAuthenticationFilter</code>仅处理URL匹配<code>/login/oauth2/code/*</code>。如果要自定义<code>redirect-uri</code>以使用其他模式，则需要提供配置以处理该自定义模式。例如，对于servlet应用程序，您可以添加<code>WebSecurityConfigurerAdapter</code>类似于以下内容的应用程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuth2LoginSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		http</span><br><span class="line">			.authorizeRequests()</span><br><span class="line">				.anyRequest().authenticated()</span><br><span class="line">				.and()</span><br><span class="line">			.oauth2Login()</span><br><span class="line">				.redirectionEndpoint()</span><br><span class="line">					.baseUri(<span class="string">"/custom-callback"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>OAuth2客户端注册常见providers</strong></p>
<p>对于常见的OAuth2和OpenID提供商，包括谷歌，Github上，Facebook和1563，我们提供了一组供应商默认的（<code>google</code>，<code>github</code>，<code>facebook</code>，和<code>okta</code>，分别）。</p>
<p>如果您不需要自定义这些提供程序，则可以将<code>provider</code>属性设置为需要推断默认值的属性。此外，如果客户端注册的密钥与默认支持的提供程序匹配，则Spring Boot也会推断出。</p>
<p>换句话说，以下示例中的两个配置使用Google提供程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.registration.my-client.client-id = abcd</span><br><span class="line">spring.security.oauth2.client.registration.my-client.client-secret = password</span><br><span class="line">spring.security.oauth2.client.registration.my- client.provider = google</span><br><span class="line"></span><br><span class="line">spring.security.oauth2.client.registration.google.client-id = abcd</span><br><span class="line">spring.security.oauth2.client.registration.google.client-secret = password</span><br></pre></td></tr></table></figure>
<h4 id="Resource-Server-资源服务器"><a href="#Resource-Server-资源服务器" class="headerlink" title="Resource Server(资源服务器)"></a>Resource Server(资源服务器)</h4><p>如果您具有<code>spring-security-oauth2-resource-server</code>类路径，则只要指定了JWK Set URI或OIDC Issuer URI，Spring Boot就可以设置OAuth2资源服务器，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.resourceserver.jwt.jwk-set-uri = https://example.com/oauth2/default/v1/keys</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.resourceserver.jwt.issuer-uri = https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></td></tr></table></figure>
<p>相同的属性适用于servlet和反应应用程序。</p>
<p>或者，您可以<code>JwtDecoder</code>为servlet应用程序或<code>ReactiveJwtDecoder</code>响应应用程序定义自己的bean 。</p>
<h4 id="Authorization-Server-授权服务器"><a href="#Authorization-Server-授权服务器" class="headerlink" title="Authorization Server(授权服务器)"></a>Authorization Server(授权服务器)</h4><p>目前，Spring Security不支持实施OAuth 2.0授权服务器。但是，此功能可从<a href="https://projects.spring.io/spring-security-oauth/" target="_blank" rel="noopener">Spring Security OAuth</a>项目获得，该项目最终将完全被Spring Security取代。在此之前，您可以使用该<code>spring-security-oauth2-autoconfigure</code>模块轻松设置OAuth 2.0授权服务器; 请参阅其<a href="https://docs.spring.io/spring-security-oauth2-boot" target="_blank" rel="noopener">文档</a>以获取说明</p>
<h3 id="Actuator-Security-执行器安全性"><a href="#Actuator-Security-执行器安全性" class="headerlink" title="Actuator Security(执行器安全性)"></a>Actuator Security(执行器安全性)</h3><p>出于安全考虑，默认情况下除了<code>/health</code>和<code>/info</code>禁用所有执行器。该<code>management.endpoints.web.exposure.include</code>属性可用于启用执行器。</p>
<p>如果春季安全是在类路径上，并没有其他WebSecurityConfigurerAdapter存在，比其他所有的驱动器<code>/health</code>，并<code>/info</code>通过春天开机自动配置安全。如果您定义自定义<code>WebSecurityConfigurerAdapter</code>，Spring Boot自动配置将退回，您将完全控制执行器访问规则。</p>
<blockquote>
<p>在设置之前<code>management.endpoints.web.exposure.include</code>，请确保暴露的执行器不包含敏感信息和/或通过将它们放在防火墙后面或通过Spring Security等方式进行保护。</p>
</blockquote>
<h4 id="跨站点请求伪造保护"><a href="#跨站点请求伪造保护" class="headerlink" title="跨站点请求伪造保护"></a>跨站点请求伪造保护</h4><p>由于Spring Boot依赖于Spring Security的默认值，因此默认情况下会启用CSRF保护。这意味着执行器端点需要<code>POST</code>（关闭和记录器端点），<code>PUT</code>或者<code>DELETE</code>在使用默认安全配置时将获得403禁止错误。</p>
<blockquote>
<p>我们建议仅在创建非浏览器客户端使用的服务时才完全禁用CSRF保护。</p>
</blockquote>
<p>有关CSRF保护的其他信息，请参阅“ <a href="https://docs.spring.io/spring-security/site/docs/5.1.4.RELEASE/reference/htmlsingle#csrf" target="_blank" rel="noopener">Spring Security参考指南”</a>。</p>
</div></div><a class="button-hover more" href="/2019/03/20/使用SpringBoot-Security/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/20/使用SpringBoot-开发Web应用程序/">使用SpringBoot-开发Web应用程序</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-20</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/web/">web</a></div></div><div class="post-content"><div class="main-content content"><h2 id="开发Web应用程序"><a href="#开发Web应用程序" class="headerlink" title="开发Web应用程序"></a>开发Web应用程序</h2><p>Spring Boot非常适合Web应用程序开发。您可以使用嵌入式Tomcat，Jetty，Undertow或Netty创建自包含的HTTP服务器。大多数Web应用程序使用该<code>spring-boot-starter-web</code>模块快速启动和运行。您还可以选择使用该<code>spring-boot-starter-webflux</code>模块构建响应式Web应用程序 。</p>
<p>如果您还没有开发Spring Boot Web应用程序，可以按照“Hello World！”进行操作。“ <em>入门”</em>部分中的示例 。</p>
<h3 id="Spring-Web-MVC框架"><a href="#Spring-Web-MVC框架" class="headerlink" title="Spring Web MVC框架"></a>Spring Web MVC框架</h3><p>在<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">SpringWeb MVC框架</a>（通常简称为“SpringMVC”）是一个丰富的“模型视图控制器” Web框架。Spring MVC允许您创建特殊<code>@Controller</code>或<code>@RestController</code>bean来处理传入的HTTP请求。控制器中的方法通过使用<code>@RequestMapping</code>注释映射到HTTP 。</p>
<p>以下代码显示了<code>@RestController</code>为JSON数据提供服务的典型代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="meta">@RequestMapping</span>（value =“/ users”）</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RequestMapping</span>（value =“/ &#123;user&#125;”，method = RequestMethod.GET）</span><br><span class="line">	 <span class="keyword">public</span> User getUser（ <span class="meta">@PathVariable</span> Long user）&#123;</span><br><span class="line">		 <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>（value =“/ &#123;user&#125; / customers”，method = RequestMethod.GET） </span><br><span class="line">	List &lt;Customer&gt; getUserCustomers（ <span class="meta">@PathVariable</span> Long user）&#123;</span><br><span class="line">		 <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>（value =“/ &#123;user&#125;”，method = RequestMethod.DELETE）</span><br><span class="line">	 <span class="keyword">public</span> User deleteUser（ <span class="meta">@PathVariable</span> Long user）&#123;</span><br><span class="line">		 <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring MVC是核心Spring Framework的一部分，详细信息可在<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">参考文档中找到</a>。也有涵盖Spring MVC中提供一些指南<a href="https://spring.io/guides" target="_blank" rel="noopener">spring.io/guides</a>。</p>
<h4 id="Spring-MVC自动配置"><a href="#Spring-MVC自动配置" class="headerlink" title="Spring MVC自动配置"></a>Spring MVC自动配置</h4><p>Spring Boot为Spring MVC提供自动配置，适用于大多数应用程序。</p>
<p>自动配置在Spring的默认值之上添加了以下功能：</p>
<ul>
<li>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>豆类。</li>
<li>支持提供静态资源，包括对WebJars的支持（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">本文档稍后介绍</a>））。</li>
<li>自动注册<code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code>豆类。</li>
<li>支持<code>HttpMessageConverters</code>（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-message-converters" target="_blank" rel="noopener">本文档后面部分</a>）。</li>
<li>自动注册<code>MessageCodesResolver</code>（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-message-codes" target="_blank" rel="noopener">本文档后面部分</a>）。</li>
<li>静态<code>index.html</code>支持。</li>
<li>自定义<code>Favicon</code>支持（<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-favicon" target="_blank" rel="noopener">本文档稍后介绍</a>）。</li>
<li>自动使用<code>ConfigurableWebBindingInitializer</code>bean（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-web-binding-initializer" target="_blank" rel="noopener">本文档稍后介绍</a>）。</li>
</ul>
<p>如果您想保留Spring Boot MVC功能并且想要添加其他 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC配置</a>（拦截器，格式化程序，视图控制器和其他功能），您可以添加自己的<code>@Configuration</code>类类型<code>WebMvcConfigurer</code>但<strong>不需要</strong> <code>@EnableWebMvc</code>。如果您希望提供，或的 自定义实例<code>RequestMappingHandlerMapping</code>，则可以声明 实例以提供此类组件。<code>RequestMappingHandlerAdapter`</code>ExceptionHandlerExceptionResolver<code></code>WebMvcRegistrationsAdapter`</p>
<p>如果您想完全控制Spring MVC，可以添加自己的<code>@Configuration</code> 注释<code>@EnableWebMvc</code>。</p>
<h4 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h4><p>Spring MVC使用该<code>HttpMessageConverter</code>接口来转换HTTP请求和响应。明智的默认设置包含在开箱即用中。例如，对象可以自动转换为JSON（通过使用Jackson库）或XML（如果可用，则使用Jackson XML扩展，或者如果Jackson XML扩展不可用，则使用JAXB）。默认情况下，字符串是以编码的<code>UTF-8</code>。</p>
<p>如果需要添加或自定义转换器，可以使用Spring Boot的 <code>HttpMessageConverters</code>类，如下面的清单所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">		HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HttpMessageConverter</code>上下文中存在的任何bean都将添加到转换器列表中。您也可以以相同的方式覆盖默认转换器。</p>
<h4 id="自定义JSON序列化程序和反序列化程序"><a href="#自定义JSON序列化程序和反序列化程序" class="headerlink" title="自定义JSON序列化程序和反序列化程序"></a>自定义JSON序列化程序和反序列化程序</h4><p>如果您使用Jackson序列化和反序列化JSON数据，您可能希望编写自己的类<code>JsonSerializer</code>和<code>JsonDeserializer</code>类。自定义序列化程序通常 <a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers" target="_blank" rel="noopener">通过模块向Jackson注册</a>，但Spring Boot提供了另一种<code>@JsonComponent</code>注释，可以更容易地直接注册Spring Beans。</p>
<p>您可以<code>@JsonComponent</code>直接使用注释<code>JsonSerializer</code>或 <code>JsonDeserializer</code>实现。您还可以在包含序列化程序/反序列化程序作为内部类的类上使用它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.jackson.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的所有<code>@JsonComponent</code>豆子都会<code>ApplicationContext</code>自动在杰克逊注册。因为<code>@JsonComponent</code>是元注释<code>@Component</code>，所以通常的组件扫描规则适用。</p>
<p>春季启动也提供 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java" target="_blank" rel="noopener"><code>JsonObjectSerializer</code></a>和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java" target="_blank" rel="noopener"><code>JsonObjectDeserializer</code></a>基础类，序列化对象时提供标准版本的杰克逊有用的替代。见 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html" target="_blank" rel="noopener"><code>JsonObjectSerializer</code></a>和<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html" target="_blank" rel="noopener"><code>JsonObjectDeserializer</code></a>在Javadoc了解详情。</p>
<h4 id="MessageCodesResolver"><a href="#MessageCodesResolver" class="headerlink" title="MessageCodesResolver"></a>MessageCodesResolver</h4><p>Spring MVC有一个生成错误代码的策略，用于从绑定错误中呈现错误消息：<code>MessageCodesResolver</code>。如果设置了<code>spring.mvc.message-codes-resolver.format</code>财产<code>PREFIX_ERROR_CODE</code>或 <code>POSTFIX_ERROR_CODE</code>春季启动为您创建一个（见枚举<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html" target="_blank" rel="noopener"><code>DefaultMessageCodesResolver.Format</code></a>）。</p>
<h4 id="静态内容"><a href="#静态内容" class="headerlink" title="静态内容"></a>静态内容</h4><p>默认情况下，Spring Boot从类路径中的<code>/static</code>（ <code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>）目录或者根目录中提供静态内容<code>ServletContext</code>。它使用<code>ResourceHttpRequestHandler</code>Spring MVC，以便您可以通过添加自己<code>WebMvcConfigurer</code>的<code>addResourceHandlers</code>方法来修改该行为并覆盖该 方法。</p>
<p>在独立的Web应用程序中，容器中的默认servlet也会启用，并作为后备，从<code>ServletContext</code>if 的根目录提供内容，决定不处理它。大多数情况下，这不会发生（除非你修改默认的MVC配置），因为Spring总是可以通过它来处理请求 <code>DispatcherServlet</code>。</p>
<p>默认情况下，会映射资源<code>/**</code>，但您可以使用该<code>spring.mvc.static-path-pattern</code>属性对其进行调整 。例如，重新定位所有资源 <code>/resources/**</code>可以实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.static-path-pattern = /resources/**</span><br></pre></td></tr></table></figure>
<p>您还可以使用该<code>spring.resources.static-locations</code>属性自定义静态资源位置 （将默认值替换为目录位置列表）。根Servlet上下文路径<code>&quot;/&quot;</code>也会自动添加为位置。</p>
<p>除了前面提到的“标准”静态资源位置之外，还为<a href="https://www.webjars.org/" target="_blank" rel="noopener">Webjars内容</a>制作了一个特例。具有路径的任何资源 <code>/webjars/**</code>都是从jar文件提供的，如果它们以Webjars格式打包的话。</p>
<blockquote>
<p><code>src/main/webapp</code>如果您的应用程序打包为jar，请不要使用该目录。虽然这个目录是一个通用的标准，它的工作原理<strong>只是</strong>war的包装，它是默默大多数构建工具忽略，如果你生成一个jar。</p>
</blockquote>
<p>Spring Boot还支持Spring MVC提供的高级资源处理功能，允许使用缓存破坏静态资源或使用与Webjars无关的URL。</p>
<p>要为Webjars使用版本无关的URL，请添加<code>webjars-locator-core</code>依赖项。然后声明你的Webjar。以jQuery为例，添加 <code>&quot;/webjars/jquery/jquery.min.js&quot;</code>结果 <code>&quot;/webjars/jquery/x.y.z/jquery.min.js&quot;</code>。<code>x.y.z</code>Webjar版本在哪里。</p>
<blockquote>
<p>如果你使用JBoss，你需要声明<code>webjars-locator-jboss-vfs</code> 依赖而不是<code>webjars-locator-core</code>。否则，所有Webjars都会解析为 <code>404</code>。</p>
</blockquote>
<p>要使用缓存清除，以下配置会为所有静态资源配置缓存清除解决方案，从而有效地<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>在URL中添加内容哈希，例如 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled = true</span><br><span class="line">spring.resources.chain.strategy.content.paths = /**</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于<code>ResourceUrlEncodingFilter</code>为Thymeleaf和FreeMarker自动配置了资源链接，因此在运行时会在模板中重写 。您应该在使用JSP时手动声明此过滤器。目前不支持其他模板引擎，但可以使用自定义模板宏/帮助程序和使用 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html" target="_blank" rel="noopener"><code>ResourceUrlProvider</code></a>。</p>
</blockquote>
<p>使用（例如）JavaScript模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也得到支持并可以合并的原因。“固定”策略在URL中添加静态版本字符串而不更改文件名，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled = true</span><br><span class="line">spring.resources.chain.strategy.content.paths = / **</span><br><span class="line">spring.resources.chain.strategy.fixed.enabled = true</span><br><span class="line">spring.resources.chain.strategy.fixed .paths = / js / lib /</span><br><span class="line">spring.resources.chain.strategy.fixed.version = v12</span><br></pre></td></tr></table></figure>
<p>使用此配置，JavaScript模块位于<code>&quot;/js/lib/&quot;</code>使用固定版本控制策略（<code>&quot;/v12/js/lib/mymodule.js&quot;</code>），而其他资源仍使用内容one（<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>）。</p>
<p>有关更多支持选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java" target="_blank" rel="noopener"><code>ResourceProperties</code></a> </p>
<blockquote>
<p>此功能已在专门的<a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources" target="_blank" rel="noopener">博客文章</a>和Spring Framework的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources" target="_blank" rel="noopener">参考文档中</a>进行了详细描述 。</p>
</blockquote>
<h4 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h4><p>Spring Boot支持静态和模板化欢迎页面。它首先<code>index.html</code>在配置的静态内容位置中查找 文件。如果找不到，则查找<code>index</code>模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。</p>
<h4 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h4><p>Spring Boot <code>favicon.ico</code>在配置的静态内容位置和类路径的根（按此顺序）中查找a 。如果存在这样的文件，它将自动用作应用程序的favicon。</p>
<h4 id="路径匹配和内容协商"><a href="#路径匹配和内容协商" class="headerlink" title="路径匹配和内容协商"></a>路径匹配和内容协商</h4><p>Spring MVC可以通过查看请求路径并将其与应用程序中定义的映射（例如，<code>@GetMapping</code> Controller方法上的注释）相匹配，将传入的HTTP请求映射到处理程序。</p>
<p>Spring Boot默认选择禁用后缀模式匹配，这意味着请求<code>&quot;GET /projects/spring-boot.json&quot;</code>不会与<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>映射匹配 。这被认为是<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match" target="_blank" rel="noopener">Spring MVC应用程序</a>的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match" target="_blank" rel="noopener">最佳实践</a>。对于没有发送正确“接受”请求标头的HTTP客户端，此功能在过去主要有用; 我们需要确保将正确的内容类型发送给客户端。如今，内容协商更加可靠。</p>
<p>还有其他方法可以处理不一致发送正确“接受”请求标头的HTTP客户端。我们可以使用查询参数来确保将请求<code>&quot;GET /projects/spring-boot?format=json&quot;</code> 映射到<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>以下内容，而不是使用后缀匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-parameter = true</span><br><span class="line"></span><br><span class="line">＃我们可以更改参数名称，默认为“format”：</span><br><span class="line">＃spring.mvc.contentnegotiation.parameter-name = myparam</span><br><span class="line"></span><br><span class="line">＃我们还可以注册其他文件扩展名/媒体类型：</span><br><span class="line">spring.mvc.contentnegotiation.media-types.markdown = text/markdown</span><br></pre></td></tr></table></figure>
<p>如果您了解警告并仍希望您的应用程序使用后缀模式匹配，则需要以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-path-extension = true</span><br><span class="line">spring.mvc.pathmatch.use-suffix-pattern = true</span><br></pre></td></tr></table></figure>
<p>或者，不是打开所有后缀模式，而是仅支持已注册的后缀模式更安全：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-path-extension = true</span><br><span class="line">spring.mvc.pathmatch.use-registered-suffix-pattern = true</span><br><span class="line"></span><br><span class="line">＃您还可以注册其他文件扩展名/媒体类型：</span><br><span class="line">＃spring.mvc.contentnegotiation.media-types.adoc = text/asciidoc</span><br></pre></td></tr></table></figure>
<h4 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h4><p>Spring MVC使用一个 <code>WebBindingInitializer</code>来初始化<code>WebDataBinder</code>特定请求。如果你自己创建<code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot会自动配置Spring MVC来使用它。</p>
<h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>除REST Web服务外，您还可以使用Spring MVC来提供动态HTML内容。Spring MVC支持各种模板技术，包括Thymeleaf，FreeMarker和JSP。此外，许多其他模板引擎包括他们自己的Spring MVC集成。</p>
<p>Spring Boot包括对以下模板引擎的自动配置支持：</p>
<ul>
<li><a href="https://freemarker.apache.org/docs/" target="_blank" rel="noopener">FreeMarker</a></li>
<li><a href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine" target="_blank" rel="noopener">Groovy</a></li>
<li><a href="http://www.thymeleaf.org/" target="_blank" rel="noopener">Thymeleaf</a></li>
<li><a href="https://mustache.github.io/" target="_blank" rel="noopener">Mustache</a></li>
</ul>
<blockquote>
<p>如果可能，应该避免使用JSP。将它们与嵌入式servlet容器一起使用时有几个 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-jsp-limitations" target="_blank" rel="noopener">已知的限制</a>。</p>
</blockquote>
<p>当您使用其中一个模板引擎和默认配置时，您的模板将自动从中获取<code>src/main/resources/templates</code>。</p>
<blockquote>
<p>根据您运行应用程序的方式，IntelliJ IDEA以不同方式对类路径进行排序。从主方法在IDE中运行应用程序会导致与使用Maven或Gradle或其打包的jar运行应用程序时的顺序不同。这可能导致Spring Boot无法在类路径中找到模板。如果遇到此问题，可以在IDE中重新排序类路径，以便首先放置模块的类和资源。或者，您可以配置模板前缀以搜索<code>templates</code>类路径上的每个目录，如下所示： <code>classpath*:/templates/</code>。</p>
</blockquote>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>默认情况下，Spring Boot提供了一个<code>/error</code>以合理方式处理所有错误的映射，并将其注册为servlet容器中的“全局”错误页面。对于计算机客户端，它会生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，有一个“whitelabel”错误视图，它以HTML格式呈现相同的数据（以自定义它，添加<code>View</code>解析后的数据<code>error</code>）。要完全替换默认行为，您可以实现 <code>ErrorController</code>并注册该类型的bean定义，或者添加类型的bean <code>ErrorAttributes</code>以使用现有机制但替换内容。</p>
<blockquote>
<p>在<code>BasicErrorController</code>可以用作自定义基类 <code>ErrorController</code>。如果要为新内容类型添加处理程序（默认情况下是<code>text/html</code>专门处理并为其他所有内容提供后备），这将特别有用。为此，请扩展<code>BasicErrorController</code>，添加<code>@RequestMapping</code>具有<code>produces</code>属性的公共方法 ，并创建新类型的bean。</p>
</blockquote>
<p>您还可以定义一个带注释的类，<code>@ControllerAdvice</code>以自定义要为特定控制器和/或异常类型返回的JSON文档，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(basePackageClasses = AcmeController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeControllerAdvice</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(YourException.class)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> CustomErrorType(status.value(), ex.getMessage()), status);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> HttpStatus <span class="title">getStatus</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Integer statusCode = (Integer) request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>);</span><br><span class="line">		<span class="keyword">if</span> (statusCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，如果<code>YourException</code>由在同一个包中定义的控制器抛出，则使用POJO <code>AcmeController</code>的JSON表示<code>CustomErrorType</code>而不是<code>ErrorAttributes</code>表示。</p>
<p><strong>自定义错误页面</strong></p>
<p>如果要显示给定状态代码的自定义HTML错误页面，可以将文件添加到文件<code>/error</code>夹。错误页面可以是静态HTML（即，添加到任何静态资源文件夹下），也可以使用模板构建。文件名应该是确切的状态代码或系列掩码。</p>
<p>例如，要映射<code>404</code>到静态HTML文件，您的文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
<p>要<code>5xx</code>使用FreeMarker模板映射所有错误，您的文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.ftl</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure>
<p>对于更复杂的映射，您还可以添加实现该<code>ErrorViewResolver</code> 接口的bean ，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorViewResolver</span> <span class="keyword">implements</span> <span class="title">ErrorViewResolver</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Use the request or status to optionally return a ModelAndView</span></span><br><span class="line">		<span class="keyword">return</span> ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以使用常规的Spring MVC功能，例如 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers" target="_blank" rel="noopener"><code>@ExceptionHandler</code>方法</a>和 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice" target="_blank" rel="noopener"><code>@ControllerAdvice</code></a>。在 <code>ErrorController</code>随后拿起任何未处理的异常。</p>
<p><strong>映射Spring MVC之外的错误页面</strong></p>
<p>对于不使用Spring MVC的应用程序，可以使用该<code>ErrorPageRegistrar</code> 接口直接注册<code>ErrorPages</code>。这种抽象直接与底层嵌入式servlet容器一起工作，即使你没有Spring MVC也可以工作 <code>DispatcherServlet</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ErrorPageRegistrar <span class="title">errorPageRegistrar</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MyErrorPageRegistrar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorPageRegistrar</span> <span class="keyword">implements</span> <span class="title">ErrorPageRegistrar</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</span><br><span class="line">		registry.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">"/400"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您注册的<code>ErrorPage</code>路径最终由a处理<code>Filter</code> （与一些非Spring Web框架（如Jersey和Wicket）一样），那么 <code>Filter</code>必须将其显式注册为<code>ERROR</code>调度程序，如以下示例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">	registration.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">	...</span><br><span class="line">	registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class="line">	<span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，默认值<code>FilterRegistrationBean</code>不包括<code>ERROR</code>调度程序类型。</p>
<p>小心：当部署到servlet容器时，Spring Boot使用其错误页面过滤器将具有错误状态的请求转发到相应的错误页面。如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0及更高版本在成功完成servlet的服务方法后提交响应。您应该通过设置<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>为禁用此行为 <code>false</code>。</p>
<h4 id="Spring-HATEOAS"><a href="#Spring-HATEOAS" class="headerlink" title="Spring HATEOAS"></a>Spring HATEOAS</h4><p>如果您开发使用超媒体的RESTful API，Spring Boot为Spring HATEOAS提供自动配置，适用于大多数应用程序。自动配置取代了使用<code>@EnableHypermediaSupport</code>和注册多个bean 的需要，以便于构建基于超媒体的应用程序，包括 <code>LinkDiscoverers</code>（用于客户端支持）和<code>ObjectMapper</code>配置为正确编组响应到所需表示的响应。的<code>ObjectMapper</code>是通过设置各种定制的<code>spring.jackson.*</code>属性，或者，如果存在的话，通过一个<code>Jackson2ObjectMapperBuilder</code>豆。</p>
<p>您可以使用控制Spring HATEOAS的配置 <code>@EnableHypermediaSupport</code>。请注意，这样做会禁用<code>ObjectMapper</code>前面描述的自定义。</p>
<h4 id="CORS支持"><a href="#CORS支持" class="headerlink" title="CORS支持"></a>CORS支持</h4><p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank" rel="noopener">跨源资源共享</a> （CORS）是<a href="https://caniuse.com/#feat=cors" target="_blank" rel="noopener">大多数浏览器</a>实现 的<a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener">W3C规范</a>，允许您以灵活的方式指定授权何种跨域请求，而不是使用一些安全性较低且功能较弱的方法，如IFRAME或JSONP。</p>
<p>从版本4.2开始，Spring MVC <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#cors" target="_blank" rel="noopener">支持CORS</a>。 在Spring Boot应用程序中使用带有 注释的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#controller-method-cors-configuration" target="_blank" rel="noopener">控制器方法CORS配置</a><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html" target="_blank" rel="noopener"><code>@CrossOrigin</code></a>不需要任何特定配置。 可以通过使用自定义方法注册bean 来定义<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#global-cors-configuration" target="_blank" rel="noopener">全局CORS配置</a>，如以下示例所示：<code>WebMvcConfigurer</code>. <code>addCorsMappings(CorsRegistry)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">				registry.addMapping(<span class="string">"/api/**"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring-WebFlux框架"><a href="#Spring-WebFlux框架" class="headerlink" title="Spring WebFlux框架"></a>Spring WebFlux框架</h3><p>Spring WebFlux是Spring Framework 5.0中引入的新的响应式Web框架。与Spring MVC不同，它不需要Servlet API，完全异步且无阻塞，并 通过<a href="https://projectreactor.io/" target="_blank" rel="noopener">Reactor项目</a>实现<a href="http://www.reactive-streams.org/" target="_blank" rel="noopener">Reactive Streams</a>规范。</p>
<p>Spring WebFlux有两种版本：基于功能和注释。基于注释的注释非常接近Spring MVC模型，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/&#123;user&#125;/customers"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Flux&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">deleteUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“WebFlux.fn”是功能变体，它将路由配置与请求的实际处理分开，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">monoRouterFunction</span><span class="params">(UserHandler userHandler)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> route(GET(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">                .and(accept(APPLICATION_JSON)), userHandler::getUser)</span><br><span class="line">				.andRoute(GET(<span class="string">"/&#123;user&#125;/customers"</span>)</span><br><span class="line">                .and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)</span><br><span class="line">				.andRoute(DELETE(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">                .and(accept(APPLICATION_JSON)), userHandler::deleteUser);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHandler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUserCustomers</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">deleteUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WebFlux是Spring Framework的一部分，详细信息可在其 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn" target="_blank" rel="noopener">参考文档中找到</a>。</p>
<blockquote>
<p>您可以根据需要定义任意数量的<code>RouterFunction</code>bean来模块化路由器的定义。如果需要应用优先级，可以订购Bean。</p>
</blockquote>
<p>要开始，请将<code>spring-boot-starter-webflux</code>模块添加到您的应用程序中。</p>
<blockquote>
<p>在应用程序中添加两个<code>spring-boot-starter-web</code>和<code>spring-boot-starter-webflux</code>模块会导致Spring Boot自动配置Spring MVC，而不是WebFlux。选择此行为是因为许多Spring开发人员<code>spring-boot-starter-webflux</code> 在其Spring MVC应用程序中添加了使用被动的<code>WebClient</code>。您仍然可以通过将所选应用程序类型设置为来强制执行您的选择<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code>。</p>
</blockquote>
<h4 id="Spring-WebFlux自动配置"><a href="#Spring-WebFlux自动配置" class="headerlink" title="Spring WebFlux自动配置"></a>Spring WebFlux自动配置</h4><p>Spring Boot为Spring WebFlux提供自动配置，适用于大多数应用程序。</p>
<p>自动配置在Spring的默认值之上添加了以下功能：</p>
<ul>
<li>为for <code>HttpMessageReader</code>和<code>HttpMessageWriter</code>实例配置编解码器（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webflux-httpcodecs" target="_blank" rel="noopener">在本文档后面介绍</a>）。</li>
<li>支持提供静态资源，包括对WebJars的支持（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">在本文档后面介绍</a>）。</li>
</ul>
<p>如果你想保留Spring Boot WebFlux功能，并且想要添加额外的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#web-reactive" target="_blank" rel="noopener">WebFlux配置</a>，你可以添加自己的 <code>@Configuration</code>类类<code>WebFluxConfigurer</code>但<strong>不需要</strong><code>@EnableWebFlux</code>。</p>
<p>如果您想完全控制Spring WebFlux，可以添加自己的 <code>@Configuration</code>注释<code>@EnableWebFlux</code>。</p>
<h4 id="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器"><a href="#带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器" class="headerlink" title="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器"></a>带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</h4><p>Spring WebFlux使用<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>接口转换HTTP请求和响应。<code>CodecConfigurer</code>通过查看类路径中可用的库，它们被配置为具有合理的默认值。</p>
<p>Spring Boot通过使用<code>CodecCustomizer</code>实例进一步自定义。例如，<code>spring.jackson.*</code>配置密钥应用于Jackson编解码器。</p>
<p>如果需要添加或自定义编解码器，可以创建自定义<code>CodecCustomizer</code> 组件，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.codec.CodecCustomizer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CodecCustomizer <span class="title">myCodecCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> codecConfigurer -&gt; &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以利用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-json-components" target="_blank" rel="noopener">Boot的自定义JSON序列化程序和反序列化程序</a>。</p>
<h4 id="静态内容-1"><a href="#静态内容-1" class="headerlink" title="静态内容"></a>静态内容</h4><p>默认情况下，Spring Boot从类路径中名为<code>/static</code>（ <code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>）的目录中提供静态内容。它使用<code>ResourceWebHandler</code>Spring WebFlux，以便您可以通过添加自己<code>WebFluxConfigurer</code>的<code>addResourceHandlers</code>方法来修改该行为并覆盖该方法。</p>
<p>默认情况下，映射资源<code>/**</code>，但您可以通过设置<code>spring.webflux.static-path-pattern</code>属性来调整它 。例如，重新定位所有资源 <code>/resources/**</code>可以实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.webflux.static-path-pattern = /resources/**</span><br></pre></td></tr></table></figure>
<p>您还可以使用自定义静态资源位置 <code>spring.resources.static-locations</code>。这样做会将默认值替换为目录位置列表。如果这样做，默认的欢迎页面检测将切换到您的自定义位置。因此，如果<code>index.html</code>您的任何位置在启动时存在，则它是应用程序的主页。</p>
<p>除了前面列出的“标准”静态资源位置之外，还为<a href="https://www.webjars.org/" target="_blank" rel="noopener">Webjars内容</a>制作了一个特例。具有路径的任何资源 <code>/webjars/**</code>都是从jar文件提供的，如果它们以Webjars格式打包的话。</p>
<blockquote>
<p>Spring WebFlux应用程序并不严格依赖于Servlet API，因此它们不能作为war文件部署，也不能使用该<code>src/main/webapp</code>目录。</p>
</blockquote>
<h4 id="模板引擎-1"><a href="#模板引擎-1" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>除REST Web服务外，您还可以使用Spring WebFlux来提供动态HTML内容。Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker和Mustache。</p>
<p>Spring Boot包括对以下模板引擎的自动配置支持：</p>
<ul>
<li><a href="https://freemarker.apache.org/docs/" target="_blank" rel="noopener">FreeMarker</a></li>
<li><a href="http://www.thymeleaf.org/" target="_blank" rel="noopener">Thymeleaf</a></li>
<li><a href="https://mustache.github.io/" target="_blank" rel="noopener">Mustache</a></li>
</ul>
<p>当您使用其中一个模板引擎和默认配置时，您的模板将自动从中获取<code>src/main/resources/templates</code>。</p>
<h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>Spring Boot提供了<code>WebExceptionHandler</code>一种以合理的方式处理所有错误的方法。它在处理顺序中的位置紧接在WebFlux提供的处理程序之前，这些处理程序被认为是最后一个。对于计算机客户端，它会生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，有一个“whitelabel”错误处理程序，它以HTML格式呈现相同的数据。您还可以提供自己的HTML模板来显示错误（请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webflux-error-handling-custom-error-pages" target="_blank" rel="noopener">下一节</a>）。</p>
<p>自定义此功能的第一步通常涉及使用现有机制，但替换或扩充错误内容。为此，您可以添加类型的bean <code>ErrorAttributes</code>。</p>
<p>要更改错误处理行为，可以实现<code>ErrorWebExceptionHandler</code>并注册该类型的bean定义。由于a <code>WebExceptionHandler</code>是一个非常低级的，Spring Boot还提供了一个方便<code>AbstractErrorWebExceptionHandler</code>的让你以WebFlux功能方式处理错误，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomErrorWebExceptionHandler</span> <span class="keyword">extends</span> <span class="title">AbstractErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在这里定义构造函数</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> RouterFunctions</span><br><span class="line">				.route(aPredicate, aHandler)</span><br><span class="line">				.andRoute(anotherPredicate, anotherHandler);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获得更完整的图片，您还可以<code>DefaultErrorWebExceptionHandler</code> 直接子类化并覆盖特定方法。</p>
<p><strong>自定义错误页面</strong></p>
<p>如果要显示给定状态代码的自定义HTML错误页面，可以将文件添加到文件<code>/error</code>夹。错误页面可以是静态HTML（即，添加到任何静态资源文件夹下）或使用模板构建。文件名应该是确切的状态代码或系列掩码。</p>
<p>例如，要映射<code>404</code>到静态HTML文件，您的文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
<p>要<code>5xx</code>使用<code>Mustache</code>模板映射所有错误，您的文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.mustache</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Web过滤器"><a href="#Web过滤器" class="headerlink" title="Web过滤器"></a>Web过滤器</h4><p>Spring WebFlux提供了一个<code>WebFilter</code>可以实现过滤HTTP请求 - 响应交换的接口。<code>WebFilter</code>在应用程序上下文中找到的bean将自动用于过滤每个交换。</p>
<p>如果过滤器的顺序很重要，则可以实现<code>Ordered</code>或注释<code>@Order</code>。Spring Boot自动配置可以为您配置Web过滤器。执行此操作时，将使用下表中显示的订单：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Web Filter</th>
<th style="text-align:center">Order</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>MetricsWebFilter</code></td>
<td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>WebFilterChainProxy</code> （spring Security）</td>
<td style="text-align:center"><code>-100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>HttpTraceWebFilter</code></td>
<td style="text-align:center"><code>Ordered.LOWEST_PRECEDENCE - 10</code></td>
</tr>
</tbody>
</table>
<h3 id="JAX-RS-and-Jersey"><a href="#JAX-RS-and-Jersey" class="headerlink" title="JAX-RS and Jersey"></a>JAX-RS and Jersey</h3><p>如果您更喜欢REST端点的JAX-RS编程模型，则可以使用其中一个可用的实现而不是Spring MVC。<a href="https://jersey.github.io/" target="_blank" rel="noopener">Jersey</a>和 <a href="https://cxf.apache.org/" target="_blank" rel="noopener">Apache CXF</a>开箱即用。CXF要求您在应用程序上下文中注册<code>Servlet</code>或<code>Filter</code>作为其注册<code>@Bean</code>。Jersey有一些原生的Spring支持，因此我们还在Spring Boot中为它提供了自动配置支持以及启动器。</p>
<p>要开始使用Jersey，请将其<code>spring-boot-starter-jersey</code>作为依赖项包含在内，然后您需要一个注册所有端点<code>@Bean</code>的类型<code>ResourceConfig</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyConfig</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JerseyConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		register(Endpoint.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Jersey对扫描可执行档案的支持相当有限。例如，它无法扫描<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#deployment-install" target="_blank" rel="noopener">完全可执行jar文件</a>中的包中或<code>WEB-INF/classes</code>运行可执行war文件时的端点。为避免此限制，<code>packages</code>不应使用该方法，并且应使用该<code>register</code>方法单独注册端点，如上例所示。</p>
</blockquote>
<p>对于更高级的自定义，您还可以注册实现的任意数量的bean <code>ResourceConfigCustomizer</code>。</p>
<p>所有已注册的端点都应<code>@Components</code>使用HTTP资源注释（<code>@GET</code>和其他），如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GET</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Endpoint</code>是Spring <code>@Component</code>，它的生命周期由Spring管理，您可以使用<code>@Autowired</code>注释注入依赖项并使用<code>@Value</code> 注释注入外部配置。默认情况下，Jersey servlet已注册并映射到<code>/*</code>。您可以通过添加<code>@ApplicationPath</code>到您 的地图来更改映射<code>ResourceConfig</code>。</p>
<p>默认情况下，Jersey被设置为 名为<code>@Bean</code>的类型的Servlet 。默认情况下，servlet是懒惰地初始化的，但您可以通过设置来自定义该行为。您可以通过创建具有相同名称的bean来禁用或覆盖该bean。您还可以通过设置（在这种情况下，替换或覆盖是）来使用过滤器而不是servlet 。过滤器有一个，您可以设置。通过使用指定属性的映射，可以为servlet和过滤器注册提供init参数。<code>ServletRegistrationBean</code> <code>jerseyServletRegistration</code> <code>spring.jersey.servlet.load-on-startup</code> <code>spring.jersey.type=filter</code> <code>@Bean</code> <code>jerseyFilterRegistration</code> <code>@Order</code> <code>spring.jersey.filter.order</code> <code>spring.jersey.init.*</code></p>
<p>有一个<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/spring-boot-sample-jersey" target="_blank" rel="noopener">Jersey sample</a>以便您可以看到如何设置。</p>
<h3 id="嵌入式Servlet容器支持"><a href="#嵌入式Servlet容器支持" class="headerlink" title="嵌入式Servlet容器支持"></a>嵌入式Servlet容器支持</h3><p>Spring Boot包括对嵌入式<a href="https://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat</a>， <a href="https://www.eclipse.org/jetty/" target="_blank" rel="noopener">Jetty</a>和<a href="http://undertow.io/" target="_blank" rel="noopener">Undertow</a>服务器的支持。大多数开发人员使用适当的“Starter”来获取完全配置的实例。默认情况下，嵌入式服务器侦听端口上的HTTP请求<code>8080</code>。</p>
<blockquote>
<p>如果您选择在<a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a>上使用Tomcat ，请注意，默认情况下，临时目录用于存储已编译的JSP，文件上载等。<code>tmpwatch</code>应用程序运行时可能会删除此目录，从而导致失败。要避免此行为，您可能希望自定义<code>tmpwatch</code>配置，以便<code>tomcat.*</code>不删除或配置目录以<code>server.tomcat.basedir</code>使嵌入式Tomcat使用其他位置。</p>
</blockquote>
<h4 id="Servlet，Filter和Listeners"><a href="#Servlet，Filter和Listeners" class="headerlink" title="Servlet，Filter和Listeners"></a>Servlet，Filter和Listeners</h4><p>使用嵌入式servlet容器时，可以<code>HttpSessionListener</code>通过使用Spring bean或扫描Servlet组件，从Servlet规范中注册servlet，过滤器和所有侦听器（如HttpSessionListener）。</p>
<p><strong>将Servlet，过滤器和监听器注册为Spring Bean</strong></p>
<p>作为Spring bean的任何<code>Servlet</code>，<code>Filter</code>或者servlet <code>*Listener</code>实例都是在嵌入式容器中注册的。如果要从<code>application.properties</code>配置期间引用值，这可能特别方便。</p>
<p>默认情况下，如果上下文仅包含一个Servlet，则将其映射到<code>/</code>。在多个servlet bean的情况下，bean名称用作路径前缀。过滤器映射到 <code>/*</code>。</p>
<p>如果以公约为基础测绘不够灵活，你可以使用 <code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>以及 <code>ServletListenerRegistrationBean</code>类的完全控制。</p>
<p>Spring Boot附带了许多可以定义Filter bean的自动配置。以下是过滤器及其各自顺序的一些示例（较低的顺序值表示较高的优先级）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ServletFilter</th>
<th style="text-align:center">Order</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>OrderedCharacterEncodingFilter</code></td>
<td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE</code></td>
</tr>
<tr>
<td style="text-align:center"><code>WebMvcMetricsFilter</code></td>
<td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ErrorPageFilter</code></td>
<td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>HttpTraceFilter</code></td>
<td style="text-align:center"><code>Ordered.LOWEST_PRECEDENCE - 10</code></td>
</tr>
</tbody>
</table>
<p>将Filter beans无序放置通常是安全的。</p>
<p>如果需要特定的顺序，则应避免配置读取请求主体的过滤器<code>Ordered.HIGHEST_PRECEDENCE</code>，因为它可能违反应用程序的字符编码配置。如果Servlet过滤器包装请求，则应使用小于或等于的顺序进行配置 <code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>。</p>
<h4 id="Servlet上下文初始化"><a href="#Servlet上下文初始化" class="headerlink" title="Servlet上下文初始化"></a>Servlet上下文初始化</h4><p>嵌入式servlet容器不直接执行Servlet 3.0+ <code>javax.servlet.ServletContainerInitializer</code>接口或Spring<code>org.springframework.web.WebApplicationInitializer</code>接口。这是一个有意的设计决策，旨在降低设计在战争中运行的第三方库可能会破坏Spring Boot应用程序的风险。</p>
<p>如果需要在Spring Boot应用程序中执行servlet上下文初始化，则应注册实现该<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的bean 。单一<code>onStartup</code>方法提供对s的访问，<code>ServletContext</code>并且如果需要，可以轻松地用作现有的适配器<code>WebApplicationInitializer</code>。</p>
<p><strong>扫描Servlet，过滤器和侦听器</strong></p>
<p>当使用嵌入式容器中，类自动登记注释有 <code>@WebServlet</code>，<code>@WebFilter</code>和<code>@WebListener</code>可以通过使用被使能 <code>@ServletComponentScan</code>。</p>
<blockquote>
<p><code>@ServletComponentScan</code> 在独立容器中没有任何效果，而是使用容器的内置发现机制。</p>
</blockquote>
<h4 id="ServletWebServerApplicationContext"><a href="#ServletWebServerApplicationContext" class="headerlink" title="ServletWebServerApplicationContext"></a>ServletWebServerApplicationContext</h4><p>在引擎盖下，Spring Boot使用不同类型的<code>ApplicationContext</code>嵌入式servlet容器支持。该<code>ServletWebServerApplicationContext</code>是一种特殊类型的<code>WebApplicationContext</code>通过搜索单说引导自身 <code>ServletWebServerFactory</code>豆。通常是<code>TomcatServletWebServerFactory</code>,,<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code> 已经自动配置。</p>
<blockquote>
<p>您通常不需要了解这些实现类。大多数应用程序都自动配置，并适当的<code>ApplicationContext</code>和 <code>ServletWebServerFactory</code>以您的名义创建。</p>
</blockquote>
<h4 id="自定义嵌入式Servlet容器"><a href="#自定义嵌入式Servlet容器" class="headerlink" title="自定义嵌入式Servlet容器"></a>自定义嵌入式Servlet容器</h4><p>可以使用Spring <code>Environment</code> 属性配置公共servlet容器设置。通常，您将在<code>application.properties</code> 文件中定义属性。</p>
<p>常用服务器设置包括：</p>
<ul>
<li>网络设置：侦听传入HTTP请求的端口（<code>server.port</code>），要绑定的接口地址<code>server.address</code>等等。</li>
<li>会话设置：会话是持久性（<code>server.servlet.session.persistence</code>），会话超时（<code>server.servlet.session.timeout</code>），会话数据（<code>server.servlet.session.store-dir</code>）的位置以及会话cookie配置（<code>server.servlet.session.cookie.*</code>）。</li>
<li>错误管理：错误页面的位置（<code>server.error.path</code>）等。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-ssl" target="_blank" rel="noopener">SSL</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#how-to-enable-http-response-compression" target="_blank" rel="noopener">HTTP compression</a></li>
</ul>
<p>Spring Boot尽可能尝试公开常见设置，但这并不总是可行。对于这些情况，专用命名空间提供特定于服务器的自定义（请参阅 <code>server.tomcat</code>和<code>server.undertow</code>）。例如， 可以使用嵌入式servlet容器的特定功能配置<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-accesslogs" target="_blank" rel="noopener">访问日志</a>。</p>
<blockquote>
<p>请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java" target="_blank" rel="noopener"><code>ServerProperties</code></a>课程以获取完整列表。</p>
</blockquote>
<p><strong>程序化定制</strong></p>
<p>如果需要以编程方式配置嵌入式servlet容器，可以注册实现该<code>WebServerFactoryCustomizer</code>接口的Spring bean 。 <code>WebServerFactoryCustomizer</code>提供对其的访问 <code>ConfigurableServletWebServerFactory</code>，其中包括许多自定义setter方法。以下示例以编程方式设置端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationBean</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">		server.setPort(<span class="number">9000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>并且<code>UndertowServletWebServerFactory</code> 是专用变体，<code>ConfigurableServletWebServerFactory</code>分别为Tomcat，Jetty和Undertow提供了额外的自定义setter方法。</p>
</blockquote>
<p><strong>直接自定义ConfigurableServletWebServerFactory</strong></p>
<p>如果前面的定制技术太有限，你可以注册 <code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或 <code>UndertowServletWebServerFactory</code> bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableServletWebServerFactory <span class="title">webServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">	factory.setPort(<span class="number">9000</span>);</span><br><span class="line">	factory.setSessionTimeout(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">	factory.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/notfound.html"</span>));</span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为许多配置选项提供了Setter。如果您需要做一些更具异国情调的事情，还会提供一些受保护的方法“挂钩”。有关详细信息，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html" target="_blank" rel="noopener">源代码文档</a>。</p>
<h4 id="JSP限制"><a href="#JSP限制" class="headerlink" title="JSP限制"></a>JSP限制</h4><p>运行使用嵌入式servlet容器的Spring Boot应用程序（并打包为可执行存档）时，JSP支持存在一些限制。</p>
<ul>
<li>使用Jetty和Tomcat，如果使用war包装，它应该可以工作。可执行的war将在启动时运行<code>java -jar</code>，并且也可以部署到任何标准容器。使用可执行jar时不支持JSP。</li>
<li>Undertow不支持JSP。</li>
<li>创建自定义<code>error.jsp</code>页面不会覆盖<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-error-handling" target="_blank" rel="noopener">错误处理</a>的默认视图 。 应该使用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-error-handling-custom-error-pages" target="_blank" rel="noopener">自定义错误页面</a>。</li>
</ul>
<p>有一个<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp" target="_blank" rel="noopener">JSP示例</a>以便您可以看到如何设置。</p>
<h3 id="嵌入式Reactive-Server支持"><a href="#嵌入式Reactive-Server支持" class="headerlink" title="嵌入式Reactive Server支持"></a>嵌入式Reactive Server支持</h3><p>Spring Boot包括对以下嵌入式响应式Web服务器的支持：Reactor Netty，Tomcat，Jetty和Undertow。大多数开发人员使用适当的“Starter”来获取完全配置的实例。默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p>
<h3 id="Reactive-Server资源配置"><a href="#Reactive-Server资源配置" class="headerlink" title="Reactive Server资源配置"></a>Reactive Server资源配置</h3><p>在自动配置Reactor Netty或Jetty服务器时，Spring Boot将创建特定的bean，为服务器实例提供HTTP资源：<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>。</p>
<p>默认情况下，这些资源也将与Reactor Netty和Jetty客户端共享，以获得最佳性能，具体如下：</p>
<ul>
<li>相同的技术用于服务器和客户端</li>
<li>客户端实例是使用<code>WebClient.Builder</code>Spring Boot自动配置的bean 构建的</li>
</ul>
<p>开发人员可以通过提供自定义<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>bean 来覆盖Jetty和Reactor Netty的资源配置- 这将应用于客户端和服务器。</p>
<p>您可以在<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webclient-runtime" target="_blank" rel="noopener">WebClient Runtime</a>部分中了解有关客户端资源配置的更多信息 。</p>
</div></div><a class="button-hover more" href="/2019/03/20/使用SpringBoot-开发Web应用程序/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/20/使用SpringBoot-JSON/">使用SpringBoot-JSON</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-20</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/json/">json</a></div></div><div class="post-content"><div class="main-content content"><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>Spring Boot提供了与三个JSON映射库的集成：</p>
<ul>
<li>GSON</li>
<li>Jackson</li>
<li>JSON-B</li>
</ul>
<p>Jackson是首选的默认库</p>
<h3 id="jackson"><a href="#jackson" class="headerlink" title="jackson"></a>jackson</h3><p>提供杰克逊的自动配置，杰克逊是其中的一部分 <code>spring-boot-starter-json</code>。当Jackson在类路径上时，<code>ObjectMapper</code> 会自动配置bean。提供了几个配置属性来自 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-customize-the-jackson-objectmapper" target="_blank" rel="noopener">定义配置 <code>ObjectMapper</code></a>。</p>
<h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>提供Gson的自动配置。当Gson在类路径上时，<code>Gson</code>会自动配置bean。<code>spring.gson.*</code>提供了几个配置属性来自定义配置。为了获得更多控制，<code>GsonBuilderCustomizer</code>可以使用一个或多个 bean。</p>
<h3 id="JSON-B"><a href="#JSON-B" class="headerlink" title="JSON-B"></a>JSON-B</h3><p>提供Gson的自动配置。当Gson在类路径上时，<code>Gson</code>会自动配置bean。<code>spring.gson.*</code>提供了几个配置属性来自定义配置。为了获得更多控制，<code>GsonBuilderCustomizer</code>可以使用一个或多个 bean。</p>
</div></div><a class="button-hover more" href="/2019/03/20/使用SpringBoot-JSON/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/20/使用SpringBoot-国际化/">使用SpringBoot-国际化</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-20</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/i18n/">i18n</a></div></div><div class="post-content"><div class="main-content content"><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>Spring Boot支持本地化消息，以便您的应用程序可以满足不同语言首选项的用户。默认情况下，Spring Boot会<code>messages</code>在类路径的根目录中查找资源包的存在。</p>
<blockquote>
<p>当配置的资源包的默认属性文件可用时（即<code>messages.properties</code>默认情况下），将应用自动配置。如果资源包仅包含特定于语言的属性文件，则需要添加默认值。</p>
</blockquote>
<p>可以使用<code>spring.messages</code>命名空间配置资源包的基本名称以及其他几个属性，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.basename = messages，config.i18n.messages</span><br><span class="line">spring.messages.fallback-to-system-locale = false</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>spring.messages.basename</code> 支持以逗号分隔的位置列表，包括限定符或从类路径根解析的资源。</p>
</blockquote>
<p>有关更多支持选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.java" target="_blank" rel="noopener"> <code>MessageSourceProperties</code></a></p>
</div></div><a class="button-hover more" href="/2019/03/20/使用SpringBoot-国际化/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2019 By YoungDream</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/clicklove.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>