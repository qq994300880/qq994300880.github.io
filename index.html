<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="正忙着优秀~~~"><meta name="keywords" content><meta name="author" content="YoungDream,undefined"><meta name="copyright" content="YoungDream"><title>小小搬砖工【YD Blog】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon-16x16-user.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!--link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!--link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!--script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"0BGAOITLJQ","apiKey":"2c864a8b4720c83c2ddfc7e53d4c1711","indexName":"article_NAME","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/user.jpg"></div><div class="author-info-name">YoungDream</div><div class="author-info-description">正忙着优秀~~~</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/qq994300880" target="_blank">GitHub<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="http://wpa.qq.com/msgrd?v=3&amp;uin=994300880&amp;site=qq&amp;menu=yes" target="_blank">QQ<i class="icon-dot bg-color5"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">47</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">57</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">5</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">YD Blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2019/03/23/Java11尝鲜/">Java11尝鲜</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-23</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/java/">java</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java11/">java11</a></div></div><div class="post-content"><div class="main-content content"><h2 id="Java11新工具"><a href="#Java11新工具" class="headerlink" title="Java11新工具"></a>Java11新工具</h2><h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>​    用过Python的童鞋都知道读取-求值-打印循环(Read-Evaluation-Print Loop)很方便。他的目的在于以即时结果和反馈的形式。java9引入了JShell这个交互性工具，让Java也可以像脚本语言一样来运行，可以从控制台启动JShell，在JShell中直接输入表达式并查看其执行结果。当需要测试一个方法的运行效果或者是快速的对表达式进行求值时，JShell都十分方便。除了表达式之外，还可以创建 Java 类和方法。jshell 也有基本的代码完成功能。我们在教人们如何编写 Java 的过程中，不再需要解释 “public static void main（String [] args）” 这句废话。</p>
<h3 id="Dynamic-Class-File-Constants类文件新添的一种结构"><a href="#Dynamic-Class-File-Constants类文件新添的一种结构" class="headerlink" title="Dynamic Class-File Constants类文件新添的一种结构"></a>Dynamic Class-File Constants类文件新添的一种结构</h3><p>Java的类型文件格式将被拓展，支持一种新的常量池格式：CONSTANT_Dynamic，加载CONSTANT_Dynamic会将创建委托给bootstrap方法。</p>
<p>目的<br>其目的是降低开发新形式的可实现类文件约束带来的成本和干扰。</p>
<h3 id="局部变量类型推断（var-”关键字”）"><a href="#局部变量类型推断（var-”关键字”）" class="headerlink" title="局部变量类型推断（var ”关键字”）"></a>局部变量类型推断（var ”关键字”）</h3><p>什么是局部变量类型推断？</p>
<p>var javastack = “javastack”;<br>System.out.println(javastack);<br>大家看出来了，局部变量类型推断就是左边的类型直接使用 var 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 String 。</p>
<p>var javastack = “javastack”;<br>就等于：<br>String javastack = “javastack”;</p>
<p>在声明隐式类型的lambda表达式的形参时允许使用var<br>使用var的好处是在使用lambda表达式时给参数加上注解<br>(@Deprecated var x, @Nullable var y) -&gt; x.process(y);</p>
<blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li>var a; 这样不可以, 因为无法推断</li>
<li>类的属性的数据类型不可以使用var</li>
</ol>
<p><strong>有参数的lambda表达式使用</strong><br>函数式接口 :<br>    Consumer<t> : 消费型函数式接口.<br>        public void accept(T t);</t></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = t -&gt; System.out.println(t.toUpperCase());</span><br><span class="line">Consumer&lt;String&gt; consumer = (<span class="keyword">var</span> t) -&gt; System.out.println(t.toUpperCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的形式: 必须要有类型, 可以加上var</span></span><br><span class="line">Consumer&lt;String&gt; consumer = (<span class="meta">@Deprecated</span> t) -&gt; System.out.println(t.toUpperCase());</span><br><span class="line"><span class="comment">//正确的形式:</span></span><br><span class="line">Consumer&lt;String&gt; consumer = (<span class="meta">@Deprecated</span> <span class="keyword">var</span> t) -&gt; System.out.println(t.toUpperCase());</span><br></pre></td></tr></table></figure>
<h2 id="Java11新API-实用"><a href="#Java11新API-实用" class="headerlink" title="Java11新API(实用)"></a>Java11新API(实用)</h2><h3 id="新的本机不可修改集合API"><a href="#新的本机不可修改集合API" class="headerlink" title="新的本机不可修改集合API"></a>新的本机不可修改集合API</h3><p>自 Java 9 开始，Jdk 里面为集合（List/ Set/ Map）都添加了 of 和 copyOf 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。</p>
<p>示例1：</p>
<p>var list = List.of(“Java”, “Python”, “C”);<br>var copy = List.copyOf(list);<br>System.out.println(list == copy); // true<br>示例2：</p>
<p>var list = new ArrayList<string>();<br>var copy = List.copyOf(list);<br>System.out.println(list == copy); // false<br>示例1和2代码差不多，为什么一个为true,一个为false?</string></p>
<p>来看下它们的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E... elements)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (elements.length) &#123; <span class="comment">// implicit null check of elements</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ImmutableCollections.emptyList();</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(elements[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(elements[<span class="number">0</span>], elements[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(elements);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">listCopy</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coll <span class="keyword">instanceof</span> AbstractImmutableList &amp;&amp; coll.getClass() != SubList.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;)coll;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;)List.of(coll.toArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 copyOf 方法会先判断来源集合是不是 AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创建一个新的集合。</p>
<p>示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类，所以 copyOf 方法又创建了一个新的实例，所以为false.</p>
<p>注意：使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 java.lang.UnsupportedOperationException 异常。</p>
<p>上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</p>
<p>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</p>
<h3 id="Stream-加强"><a href="#Stream-加强" class="headerlink" title="Stream 加强"></a>Stream 加强</h3><p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p>
<ol>
<li><p>增加单个参数构造方法，可为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.ofNullable(<span class="keyword">null</span>).count(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增加 takeWhile 和 dropWhile 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从开始计算，当 n &lt; 3 时就截止。终止后，不管之后的元素满不满足条件，都不再进行判断</span></span><br><span class="line">ream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>).takeWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个和上面的相反，一旦 n &lt; 3 不成立就开始计算。</span></span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>).dropWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>iterate重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老版本的使用方法</span></span><br><span class="line">Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="number">1</span>, t -&gt; (<span class="number">2</span> * t) + <span class="number">1</span>);</span><br><span class="line">iterate.forEach(System.out::println);<span class="comment">//无限流，原因：溢出了</span></span><br><span class="line">iterate.limit(<span class="number">200</span>).forEach(System.out::println);<span class="comment">//限制条数</span></span><br><span class="line"><span class="comment">//这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</span></span><br><span class="line">Stream&lt;Integer&gt; newIterate = Stream.iterate(<span class="number">1</span>, t -&gt; t &gt; <span class="number">200</span>, t -&gt; (<span class="number">2</span> * t) + <span class="number">1</span>);</span><br><span class="line">newIterate.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="增加了一系列的字符串处理方法"><a href="#增加了一系列的字符串处理方法" class="headerlink" title="增加了一系列的字符串处理方法"></a>增加了一系列的字符串处理方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为空白</span></span><br><span class="line"><span class="string">" "</span>.isBlank(); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 去除首尾空白</span></span><br><span class="line"><span class="string">" Javastack "</span>.strip(); <span class="comment">// "Javastack"</span></span><br><span class="line"><span class="comment">// 去除尾部空格</span></span><br><span class="line"><span class="string">" Javastack "</span>.stripTrailing(); <span class="comment">// " Javastack"</span></span><br><span class="line"><span class="comment">// 去除首部空格</span></span><br><span class="line"><span class="string">" Javastack "</span>.stripLeading(); <span class="comment">// "Javastack "</span></span><br><span class="line"><span class="comment">// 复制字符串</span></span><br><span class="line"><span class="string">"Java"</span>.repeat(<span class="number">3</span>);<span class="comment">// "JavaJavaJava"</span></span><br><span class="line"><span class="comment">// 行数统计</span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().count(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="Optional-加强"><a href="#Optional-加强" class="headerlink" title="Optional 加强"></a>Optional 加强</h3><p>Opthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(<span class="string">"javastack"</span>).orElseThrow(); <span class="comment">// javastack</span></span><br><span class="line">Optional.of(<span class="string">"javastack"</span>).stream().count(); <span class="comment">// 1</span></span><br><span class="line">Optional.ofNullable(<span class="keyword">null</span>).or(() -&gt; Optional.of(<span class="string">"javastack"</span>)).get(); <span class="comment">// javastack</span></span><br></pre></td></tr></table></figure>
<h3 id="改进的文件API"><a href="#改进的文件API" class="headerlink" title="改进的文件API"></a>改进的文件API</h3><p>InputStream 加强</p>
<p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="keyword">var</span> inputStream = classLoader.getResourceAsStream(<span class="string">"javastack.txt"</span>);</span><br><span class="line"><span class="keyword">var</span> javastack = File.createTempFile(<span class="string">"javastack2"</span>, <span class="string">"txt"</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> outputStream = <span class="keyword">new</span> FileOutputStream(javastack)) &#123;</span><br><span class="line">    inputStream.transferTo(outputStream);<span class="comment">//把输入流中的所有数据直接自动地复制到输出流中</span></span><br><span class="line">&#125;</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure>
<h3 id="移除的一些其他内容"><a href="#移除的一些其他内容" class="headerlink" title="移除的一些其他内容"></a>移除的一些其他内容</h3><p><strong>移除项</strong>：</p>
<ol>
<li><p>移除了com.sun.awt.AWTUtilities</p>
</li>
<li><p>移除了sun.misc.Unsafe.defineClass，</p>
<p>使用java.lang.invoke.MethodHandles.Lookup.defineClass来替代</p>
</li>
<li><p>移除了Thread.destroy()以及 Thread.stop(Throwable)方法</p>
</li>
<li><p>移除了sun.nio.ch.disableSystemWideOverlappingFileLockCheck</p>
<p>sun.locale.formatasdefault属性</p>
</li>
<li><p>移除了jdk.snmp模块</p>
</li>
<li><p>移除了javafx，openjdk估计是从java10版本就移除了，oracle jdk10还尚未移除javafx，而java11版本则oracle的jdk版本也移除了javafx</p>
</li>
<li><p>移除了Java Mission Control，从JDK中移除之后，需要自己单独下载</p>
</li>
<li><p>移除了这些Root Certificates ：Baltimore Cybertrust Code Signing CA，SECOM ，AOL and Swisscom</p>
</li>
</ol>
<p><strong>废弃项</strong>：</p>
<ol>
<li>-XX+AggressiveOpts选项</li>
<li>-XX:+UnlockCommercialFeatures</li>
<li>-XX:+LogCommercialFeatures选项也不再需要</li>
</ol>
<h3 id="标准Java异步HTTP客户端"><a href="#标准Java异步HTTP客户端" class="headerlink" title="标准Java异步HTTP客户端"></a>标准Java异步HTTP客户端</h3><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 java.net 包中找到这个 API。</p>
<p>来看一下 HTTP Client 的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(<span class="string">"https://javastack.cn"</span>))</span><br><span class="line">    .GET()</span><br><span class="line">    .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, </span><br><span class="line">                                            HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(HttpResponse::body)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>
<p>上面的 .GET() 可以省略，默认请求方式为 Get！</p>
<p>更多使用示例可以看这个 API，后续再做演示。</p>
<p>现在 Java 自带了这个 HTTP Client API，我们以后还有必要用 Apache 的 HttpClient 工具包吗？</p>
<h3 id="更简化的编译运行程序"><a href="#更简化的编译运行程序" class="headerlink" title="更简化的编译运行程序"></a>更简化的编译运行程序</h3><p>JEP 330 : 增强java启动器支持运行单个java源代码文件的程序.</p>
<blockquote>
<p><strong>注意点</strong> :</p>
<ol>
<li>执行源文件中的第一个类, 第一个类必须包含主方法</li>
<li>并且不可以使用别源文件中的自定义类, 本文件中的自定义类是可以使用的.</li>
</ol>
</blockquote>
<p>一个命令编译运行源代码</p>
<p>看下面的代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 编译</span><br><span class="line">javac Javastack.java</span><br><span class="line">// 运行</span><br><span class="line">java Javastack</span><br></pre></td></tr></table></figure>
<p>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Javastack.java</span><br></pre></td></tr></table></figure>
<h3 id="Unicode-10"><a href="#Unicode-10" class="headerlink" title="Unicode 10"></a>Unicode 10</h3><p>Unicode 10 增加了8518个字符, 总计达到了136690个字符. 并且增加了4个脚本.同时还有56个新的emoji表情符号.</p>
<h3 id="Remove-the-JavaEE-and-CORBA-Moudles"><a href="#Remove-the-JavaEE-and-CORBA-Moudles" class="headerlink" title="Remove the JavaEE and CORBA Moudles"></a>Remove the JavaEE and CORBA Moudles</h3><p>在java11中移除了不太使用的JavaEE模块和CORBA技术<br>CORBA来自于二十世纪九十年代，Oracle说，现在用CORBA开发现代Java应用程序已经没有意义了，维护CORBA的成本已经超过了保留它带来的好处。</p>
<p>但是删除CORBA将使得那些依赖于JDK提供部分CORBA API的CORBA实现无法运行。目前还没有第三方CORBA版本，也不确定是否会有第三方愿意接手CORBA API的维护工作。</p>
<p>在java11中将java9标记废弃的Java EE及CORBA模块移除掉，具体如下：</p>
<ol>
<li>xml相关的，<br>java.xml.ws,<br>java.xml.bind，<br>java.xml.ws，<br>java.xml.ws.annotation，<br>jdk.xml.bind，<br>jdk.xml.ws被移除，<br>只剩下java.xml，java.xml.crypto,jdk.xml.dom这几个模块；</li>
<li>java.corba，<br>java.se.ee，<br>java.activation，<br>java.transaction被移除，<br>但是java11新增一个java.transaction.xa模块</li>
</ol>
<h3 id="JEP-335-Deprecate-the-Nashorn-JavaScript-Engine"><a href="#JEP-335-Deprecate-the-Nashorn-JavaScript-Engine" class="headerlink" title="JEP : 335 : Deprecate the Nashorn JavaScript Engine"></a>JEP : 335 : Deprecate the Nashorn JavaScript Engine</h3><p>废除Nashorn javascript引擎，在后续版本准备移除掉，有需要的可以考虑使用GraalVM</p>
<h3 id="JEP-336-Deprecate-the-Pack200-Tools-and-API"><a href="#JEP-336-Deprecate-the-Pack200-Tools-and-API" class="headerlink" title="JEP : 336 : Deprecate the Pack200 Tools and API"></a>JEP : 336 : Deprecate the Pack200 Tools and API</h3><p>Java5中带了一个压缩工具:Pack200，这个工具能对普通的jar文件进行高效压缩。其实现原理是根据Java类特有的结构，合并常数池，去掉无用信息等来实现对java类的高效压缩。由于是专门对Java类进行压缩的，所以对普通文件的压缩和普通压缩软件没有什么两样，但是对于Jar  文件却能轻易达到10-40%的压缩率。这在Java应用部署中很有用，尤其对于移动Java计算，能够大大减小代码下载量。<br>Java5中还提供了这一技术的API接口，你可以将其嵌入到你的程序中使用。使用的方法很简单，下面的短短几行代码即可以实现jar的压缩和解压：</p>
<ol>
<li>压缩<br>Packer packer=Pack200.newPacker();<br>OutputStream output=new BufferedOutputStream(new  FileOutputStream(outfile));<br>packer.pack(new JarFile(jarFile), output);<br>output.close(); </li>
<li>解压<br>Unpacker unpacker=Pack200.newUnpacker();<br>output=new JarOutputStream(new FileOutputStream(jarFile));<br>unpacker.unpack(pack200File, output);<br>output.close(); </li>
</ol>
<p>Pack200的压缩和解压缩速度是比较快的，而且压缩率也是很惊人的，在我是使用  的包4.46MB压缩后成了1.44MB（0.322%），而且随着包的越大压缩率会更加明显，据说如果jar包都是class类可以压缩到1/9的大  小。其实JavaWebStart还有很多功能，例如可以按不同的jar包进行lazy下载和 单独更新，设置可以根据jar中的类变动进行class粒度的下载。</p>
<p>但是在java11中废除了pack200以及unpack200工具以及java.util.jar中的Pack200 API。因为Pack200主要是用来压缩jar包的工具，由于网络下载速度的提升以及java9引入模块化系统之后不再依赖Pack200，因此这个版本将其移除掉。</p>
<h3 id="新的Epsilon垃圾收集器"><a href="#新的Epsilon垃圾收集器" class="headerlink" title="新的Epsilon垃圾收集器"></a>新的Epsilon垃圾收集器</h3><p>A NoOp Garbage Collector<br>JDK上对这个特性的描述是: 开发一个处理内存分配但不实现任何实际内存回收机制的GC, 一旦可用堆内存用完, JVM就会退出.<br>如果有System.gc()调用, 实际上什么也不会发生(这种场景下和-XX:+DisableExplicitGC效果一样), 因为没有内存回收, 这个实现可能会警告用户尝试强制GC是徒劳.</p>
<p>用法 : <code>-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Garbage</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>);</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span> + <span class="string">" : "</span> + n + <span class="string">" is dying"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EpsilonTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">		List&lt;Garbage&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			list.add(<span class="keyword">new</span> Garbage());</span><br><span class="line">			<span class="keyword">if</span> (list.size() == <span class="number">1000000</span> &amp;&amp; count == <span class="number">0</span>) &#123;</span><br><span class="line">				list.clear();</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"程序结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用选项-XX:+UseEpsilonGC, 程序很快就因为堆空间不足而退出</p>
<p>使用这个选项的原因 :<br>提供完全被动的GC实现, 具有有限的分配限制和尽可能低的延迟开销,但代价是内存占用和内存吞吐量.<br>众所周知, java实现可广泛选择高度可配置的GC实现. 各种可用的收集器最终满足不同的需求, 即使它们的可配置性使它们的功能相交. 有时更容易维护单独的实现, 而不是在现有GC实现上堆积另一个配置选项.</p>
<p>主要用途如下 :</p>
<pre><code>1. 性能测试(它可以帮助过滤掉GC引起的性能假象)
2. 内存压力测试(例如,知道测试用例 应该分配不超过1GB的内存, 我们可以使用-Xmx1g –XX:+UseEpsilonGC, 如果程序有问题, 则程序会崩溃)
3. 非常短的JOB任务(对象这种任务, 接受GC清理堆那都是浪费空间)
4. VM接口测试
5. Last-drop 延迟&amp;吞吐改进
</code></pre><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>这应该是JDK11最为瞩目的特性, 没有之一. 但是后面带了Experimental, 说明这还不建议用到生产环境</p>
<ol>
<li>GC暂停时间不会超过10ms</li>
<li>既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)</li>
<li>和G1相比, 应用吞吐能力不会下降超过15%</li>
<li>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础</li>
<li>初始只支持64位系统</li>
</ol>
<p>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。</p>
<p>GC是java主要优势之一. 然而, 当GC停顿太长, 就会开始影响应用的响应时间.消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力的平台. 此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高效的方式充分利用这些内存, 并且无需长时间的GC暂停时间.</p>
<p>STW – stop the world</p>
<p>ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会STW, 因此GC停顿时间不会随着堆的增长和存活对象的增长而变长.</p>
<p>ZGC : avg 1.091ms    max:1.681<br>G1   : avg 156.806  max:543.846</p>
<p>用法 : -XX:+UnlockExperimentalVMOptions –XX:+UseZGC, 因为ZGC还处于实验阶段, 所以需要通过JVM参数来解锁这个特性</p>
<h3 id="完全支持Linux容器（包括Docker）"><a href="#完全支持Linux容器（包括Docker）" class="headerlink" title="完全支持Linux容器（包括Docker）"></a>完全支持Linux容器（包括Docker）</h3><p>许多运行在Java虚拟机中的应用程序（包括Apache Spark和Kafka等数据服务以及传统的企业应用程序）都可以在Docker容器中运行。但是在Docker容器中运行Java应用程序一直存在一个问题，那就是在容器中运行JVM程序在设置内存大小和CPU使用率后，会导致应用程序的性能下降。这是因为Java应用程序没有意识到它正在容器中运行。随着Java 10的发布，这个问题总算得以解决，JVM现在可以识别由容器控制组（cgroups）设置的约束。可以在容器中使用内存和CPU约束来直接管理Java应用程序，其中包括：</p>
<p>遵守容器中设置的内存限制<br>在容器中设置可用的CPU<br>在容器中设置CPU约束<br>Java 10的这个改进在Docker for Mac、Docker for Windows以及Docker Enterprise Edition等环境均有效。</p>
<p>容器的内存限制<br>在Java 9之前，JVM无法识别容器使用标志设置的内存限制和CPU限制。而在Java 10中，内存限制会自动被识别并强制执行。</p>
<p>Java将服务器类机定义为具有2个CPU和2GB内存，以及默认堆大小为物理内存的1/4。例如，Docker企业版安装设置为2GB内存和4个CPU的环境，我们可以比较在这个Docker容器上运行Java 8和Java 10的区别。</p>
<p>首先，对于Java 8：</p>
<p>docker container run -it -m512 –entrypoint bash openjdk:latest<br>$ docker-java-home/bin/java -XX:+PrintFlagsFinal -version | grep MaxHeapSize<br>uintx MaxHeapSize                              := 524288000                          {product}<br>openjdk version “1.8.0_162”<br>1<br>2<br>3<br>4<br>最大堆大小为512M或Docker EE安装设置的2GB的1/4，而不是容器上设置的512M限制。</p>
<p>相比之下，在Java 10上运行相同的命令表明，容器中设置的内存限制与预期的128M非常接近：</p>
<p>docker container run -it -m512M –entrypoint bash openjdk:10-jdk<br>$ docker-java-home/bin/java -XX:+PrintFlagsFinal -version | grep MaxHeapSize<br>size_t MaxHeapSize                              = 134217728                          {product} {ergonomic}<br>openjdk version “10” 2018-03-20<br>1<br>2<br>3<br>4<br>设置可用的CPU<br>默认情况下，每个容器对主机CPU周期的访问是无限的。可以设置各种约束来限制给定容器对主机CPU周期的访问。Java 10可以识别这些限制：</p>
<p>docker container run -it –cpus 2 openjdk:10-jdk<br>jshell&gt; Runtime.getRuntime().availableProcessors()<br>$1 ==&gt; 2<br>1<br>2<br>3<br>分配给Docker EE的所有CPU会获得相同比例的CPU周期。这个比例可以通过修改容器的CPU share权重来调整，而CPU share权重与其它所有运行在容器中的权重相关。此比例仅适用于正在运行的CPU密集型的进程。当某个容器中的任务空闲时，其他容器可以使用余下的CPU时间。实际的CPU时间的数量取决于系统上运行的容器的数量。这些可以在Java 10中设置：</p>
<p>docker container run -it –cpu-shares 2048 openjdk:10-jdk<br>jshell&gt; Runtime.getRuntime().availableProcessors()<br>$1 ==&gt; 2<br>1<br>2<br>3<br>cpuset约束设置了哪些CPU允许在Java 10中执行。</p>
<p>docker run -it –cpuset-cpus=”1,2,3” openjdk:10-jdk<br>jshell&gt; Runtime.getRuntime().availableProcessors()<br>$1 ==&gt; 3<br>1<br>2<br>3<br>分配内存和CPU<br>使用Java 10，可以使用容器设置来估算部署应用程序所需的内存和CPU的分配。我们假设已经确定了容器中运行的每个进程的内存堆和CPU需求，并设置了JAVA_OPTS配置。例如，如果有一个跨10个节点分布的应用程序，其中五个节点每个需要512Mb的内存和1024个CPU-shares，另外五个节点每个需要256Mb和512个CPU-shares。</p>
<p>请注意，1个CPU share比例由1024表示。</p>
<p>对于内存，应用程序至少需要分配5Gb。</p>
<p>512Mb × 5 = 2.56Gb<br>256Mb × 5 = 1.28Gb<br>该应用程序需要8个CPU才能高效运行。</p>
<p>1024 x 5 = 5个CPU<br>512 x 5 = 3个CPU<br>最佳实践是建议分析应用程序以确定运行在JVM中的每个进程实际需要多少内存和分配多少CPU。但是，Java 10消除了这种猜测，可以通过调整容器大小以防止Java应用程序出现内存不足的错误以及分配足够的CPU来处理工作负载。</p>
<h3 id="支持G1上的并行完全垃圾收集"><a href="#支持G1上的并行完全垃圾收集" class="headerlink" title="支持G1上的并行完全垃圾收集"></a>支持G1上的并行完全垃圾收集</h3><p>对于 G1 GC，相比于 JDK 8，升级到 JDK 11 即可免费享受到：并行的 Full GC，快速的 CardTable 扫描，自适应的堆占用比例调整（IHOP），在并发标记阶段的类型卸载等等。这些都是针对 G1 的不断增强，其中串行 Full GC 等甚至是曾经被广泛诟病的短板，你会发现 GC 配置和调优在 JDK11 中越来越方便。</p>
<h3 id="JEP-331-Low-Overhead-Heap-Profiling免费的低耗能飞行记录仪和堆分析仪"><a href="#JEP-331-Low-Overhead-Heap-Profiling免费的低耗能飞行记录仪和堆分析仪" class="headerlink" title="JEP 331 : Low-Overhead Heap Profiling免费的低耗能飞行记录仪和堆分析仪"></a>JEP 331 : Low-Overhead Heap Profiling免费的低耗能飞行记录仪和堆分析仪</h3><p>通过JVMTI的SampledObjectAlloc回调提供了一个开销低的heap分析方式</p>
<p>提供一个低开销的, 为了排错java应用问题, 以及JVM问题的数据收集框架, 希望达到的目标如下 :</p>
<ol>
<li>提供用于生产和消费数据作为事件的API</li>
<li>提供缓存机制和二进制数据格式</li>
<li>允许事件配置和事件过滤</li>
<li>提供OS,JVM和JDK库的事件</li>
</ol>
<h3 id="JEP-329-实现RFC7539中指定的ChaCha20和Poly1305两种加密算法-代替RC4"><a href="#JEP-329-实现RFC7539中指定的ChaCha20和Poly1305两种加密算法-代替RC4" class="headerlink" title="JEP 329 : 实现RFC7539中指定的ChaCha20和Poly1305两种加密算法, 代替RC4"></a>JEP 329 : 实现RFC7539中指定的ChaCha20和Poly1305两种加密算法, 代替RC4</h3><p>实现 RFC 7539的ChaCha20 and ChaCha20-Poly1305加密算法</p>
<p>RFC7748定义的秘钥协商方案更高效, 更安全. JDK增加两个新的接口<br>XECPublicKey 和 XECPrivateKey</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator kpg = KeyPairGenerator.getInstance(“XDH”);</span><br><span class="line">NamedParameterSpec paramSpec = <span class="keyword">new</span> NamedParameterSpec(“X25519”);</span><br><span class="line">kpg.initialize(paramSpec);</span><br><span class="line">KeyPair kp = kgp.generateKeyPair();</span><br><span class="line"></span><br><span class="line">KeyFactory kf = KeyFactory.getInstance(“XDH”);</span><br><span class="line">BigInteger u = <span class="keyword">new</span> BigInteger(“xxx”);</span><br><span class="line">XECPublicKeySpec pubSpec = <span class="keyword">new</span> XECPublicKeySpec(paramSpec, u);</span><br><span class="line">PublicKey pubKey = kf.generatePublic(pubSpec);</span><br><span class="line"></span><br><span class="line">KeyAgreement ka = KeyAgreement.getInstance(“XDH”);</span><br><span class="line">ka.init(kp.getPrivate());</span><br><span class="line">ka.doPhase(pubKey, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">byte</span>[] secret = ka.generateSecret();</span><br></pre></td></tr></table></figure>
<h3 id="新的默认根权限证书集"><a href="#新的默认根权限证书集" class="headerlink" title="新的默认根权限证书集"></a>新的默认根权限证书集</h3><h3 id="JEP-332最新的HTTPS安全协议TLS-1-3"><a href="#JEP-332最新的HTTPS安全协议TLS-1-3" class="headerlink" title="JEP 332最新的HTTPS安全协议TLS 1.3"></a>JEP 332最新的HTTPS安全协议TLS 1.3</h3><p>实现TLS协议1.3版本, TLS允许客户端和服务器端通过互联网以一种防止窃听, 篡改以及消息伪造的方式进行通信.</p>
<h3 id="Java-Flight-Recorder"><a href="#Java-Flight-Recorder" class="headerlink" title="Java Flight Recorder"></a>Java Flight Recorder</h3><p>Flight Recorder源自飞机的黑盒子</p>
<p>Flight Recorder以前是商业版的特性，在java11当中开源出来，它可以导出事件到文件中，之后可以用Java Mission Control来分析。可以在应用启动时配置java -XX:StartFlightRecording，或者在应用启动之后，使用jcmd来录制，比如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jcmd &lt;pid&gt; JFR.start</span><br><span class="line"><span class="meta">$</span> jcmd &lt;pid&gt; JFR.dump filename=recording.jfr</span><br><span class="line"><span class="meta">$</span> jcmd &lt;pid&gt; JFR.stop</span><br></pre></td></tr></table></figure>
<p>是 Oracle 刚刚开源的强大特性。我们知道在生产系统进行不同角度的 Profiling，有各种工具、框架，但是能力范围、可靠性、开销等，大都差强人意，要么能力不全面，要么开销太大，甚至不可靠可能导致 Java 应用进程宕机。<br>而 JFR 是一套集成进入 JDK、JVM 内部的事件机制框架，通过良好架构和设计的框架，硬件层面的极致优化，生产环境的广泛验证，它可以做到极致的可靠和低开销。在 SPECjbb2015 等基准测试中，JFR 的性能开销最大不超过 1%，所以，工程师可以基本没有心理负担地在大规模分布式的生产系统使用，这意味着，我们既可以随时主动开启 JFR 进行特定诊断，也可以让系统长期运行 JFR，用以在复杂环境中进行“After-the-fact”分析。还需要苦恼重现随机问题吗？JFR 让问题简化了很多。<br>在保证低开销的基础上，JFR 提供的能力也令人眼前一亮，例如：我们无需 BCI 就可以进行 Object Allocation Profiling，终于不用担心 BTrace 之类把进程搞挂了。对锁竞争、阻塞、延迟，JVM GC、SafePoint 等领域，进行非常细粒度分析。甚至深入 JIT Compiler 内部，全面把握热点方法、内联、逆优化等等。JFR 提供了标准的 Java、C++ 等扩展 API，可以与各种层面的应用进行定制、集成，为复杂的企业应用栈或者复杂的分布式应用，提供 All-in-One 解决方案。而这一切都是内建在 JDK 和 JVM 内部的，并不需要额外的依赖，开箱即用。</p>
</div></div><a class="button-hover more" href="/2019/03/23/Java11尝鲜/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-附录A/">使用SpringBoot-附录A</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/properties/">properties</a></div></div><div class="post-content"><div class="main-content content"><h1 id="附录A-常用应用程序属性"><a href="#附录A-常用应用程序属性" class="headerlink" title="附录A.常用应用程序属性"></a>附录A.常用应用程序属性</h1><p>可以在<code>application.properties</code>文件内部<code>application.yml</code>，文件内部或命令行开关中指定各种属性。本附录提供了常见Spring Boot属性的列表以及对使用它们的基础类的引用。</p>
<blockquote>
<p>Spring Boot提供了各种具有高级值格式的转换机制，请务必查看<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-conversion" target="_blank" rel="noopener">属性转换部分</a>。</p>
</blockquote>
<blockquote>
<p>属性贡献可以来自类路径上的其他jar文件，因此您不应将此视为详尽的列表。此外，您可以定义自己的属性。</p>
</blockquote>
<blockquote>
<p>此示例文件仅供参考。千万<strong>不能</strong>复制和粘贴的全部内容到应用程序中。相反，只选择您需要的属性。</p>
</blockquote>
<h2 id="CORE-PROPERTIES"><a href="#CORE-PROPERTIES" class="headerlink" title="CORE PROPERTIES"></a>CORE PROPERTIES</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">＃---------------------------------------- </span><br><span class="line">#CORE PROPERTIES </span><br><span class="line">＃----- ----------------------------------- </span><br><span class="line">debug = false ＃启用调试日志。</span><br><span class="line">trace = false ＃启用跟踪日志。</span><br></pre></td></tr></table></figure>
<h3 id="LOGGING"><a href="#LOGGING" class="headerlink" title="LOGGING"></a>LOGGING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#logGING </span><br><span class="line">logging.config = ＃日志配置文件的位置。例如，Logback的`classpath：logback.xml`。</span><br><span class="line">logging.exception-conversion-word =％wEx ＃记录异常时使用的转换字。</span><br><span class="line">logging.file = ＃日志文件名（例如，`myapp.log`）。名称可以是精确位置或相对于当前目录。</span><br><span class="line">logging.file.max-history = 0 ＃要保留的归档日志文件的最大值。仅支持默认的logback设置。</span><br><span class="line">logging.file.max-size = 10MB ＃最大日志文件大小。仅支持默认的logback设置。</span><br><span class="line">logging.group。* =＃记录组以同时快速更改多个记录器。例如，`logging.level.db = org.hibernate，org.springframework.jdbc`。</span><br><span class="line">logging.level。* = ＃日志级别严重性映射。例如，`logging.level.org.springframework = DEBUG`。</span><br><span class="line">logging.path = ＃日志文件的位置。例如，`/ var / log`。</span><br><span class="line">logging.pattern.console = ＃用于输出到控制台的Appender模式。仅支持默认的Logback设置。</span><br><span class="line">logging.pattern.dateformat = yyyy-MM-dd HH：mm：ss.SSS ＃日志日期格式的Appender模式。仅支持默认的Logback设置。</span><br><span class="line">logging.pattern.file =＃用于输出到文件的Appender模式。仅支持默认的Logback设置。</span><br><span class="line">logging.pattern.level =％5p ＃日志级别的Appender模式。仅支持默认的Logback设置。</span><br><span class="line">logging.register-shutdown-hook = false ＃在日志记录系统初始化时注册一个关闭钩子。</span><br></pre></td></tr></table></figure>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">＃AOP </span><br><span class="line">spring.aop.auto = true ＃添加@EnableAspectJAutoProxy。</span><br><span class="line">spring.aop.proxy-target-class = true ＃是否要创建基于子类的（CGLIB）代理（true），而不是基于标准Java接口的代理（false）。</span><br></pre></td></tr></table></figure>
<h3 id="IDENTITY-（ContextIdApplicationContextInitializer）"><a href="#IDENTITY-（ContextIdApplicationContextInitializer）" class="headerlink" title="IDENTITY （ContextIdApplicationContextInitializer）"></a>IDENTITY （ContextIdApplicationContextInitializer）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name = #应用名</span><br></pre></td></tr></table></figure>
<h3 id="DINAND-（SpringApplicationAdminJmxAutoConfiguration）"><a href="#DINAND-（SpringApplicationAdminJmxAutoConfiguration）" class="headerlink" title="DINAND （SpringApplicationAdminJmxAutoConfiguration）"></a>DINAND （SpringApplicationAdminJmxAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.admin.enabled = false ＃是否为应用程序启用管理功能。</span><br><span class="line">spring.application.admin.jmx-name = org.springframework.boot：type = Admin，name = SpringApplication #JMX 应用程序管理员MBean的名称。</span><br></pre></td></tr></table></figure>
<h3 id="AUTO-CONFIGURATION"><a href="#AUTO-CONFIGURATION" class="headerlink" title="AUTO-CONFIGURATION"></a>AUTO-CONFIGURATION</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.autoconfigure.exclude = ＃要排除的自动配置类</span><br></pre></td></tr></table></figure>
<h3 id="BANNER"><a href="#BANNER" class="headerlink" title="BANNER"></a>BANNER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.banner.charset = UTF-8 ＃横幅文件编码。</span><br><span class="line">spring.banner.location = classpath：banner.txt ＃横幅文本资源位置。</span><br><span class="line">spring.banner.image.location = classpath：banner.gif ＃横幅图像文件位置（也可以使用jpg或png）。</span><br><span class="line">spring.banner.image.width = 76 ＃字符中的横幅图像的宽度。</span><br><span class="line">spring.banner.image.height = #crs 中横幅图像的高度（默认基于图像高度）。</span><br><span class="line">spring.banner.image.margin = 2 ＃字符中的左手图像边距。</span><br><span class="line">spring.banner.image.invert = false ＃是否应针对暗终端主题反转图像。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-CORE"><a href="#SPRING-CORE" class="headerlink" title="SPRING CORE"></a>SPRING CORE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.beaninfo.ignore = true ＃是否跳过BeanInfo类的搜索</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-CACHE（CacheProperties）"><a href="#SPRING-CACHE（CacheProperties）" class="headerlink" title="SPRING CACHE（CacheProperties）"></a>SPRING CACHE（CacheProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names = #Cmama 分隔的要创建的缓存名称列表（如果底层缓存管理器支持）。</span><br><span class="line">spring.cache.caffeine.spec = ＃用于创建缓存的规范。有关规格格式的更多详细信息，请参阅CaffeineSpec。</span><br><span class="line">spring.cache.couchbase.expiration = ＃条目到期。默认情况下，条目永不过期。请注意，此值最终会转换为秒。</span><br><span class="line">spring.cache.ehcache.config = ＃用于初始化EhCache的配置文件的位置。</span><br><span class="line">spring.cache.infinispan.config = ＃用于初始化Infinispan的配置文件的位置。</span><br><span class="line">spring.cache.jcache.config = ＃用于初始化缓存管理器的配置文件的位置。</span><br><span class="line">spring.cache.jcache.provider = #CachingProvider实现的完全限定名称，用于检索符合JSR-107的缓存管理器。仅当类路径上有多个JSR-107实现时才需要。</span><br><span class="line">spring.cache.redis.cache-null-values = true ＃允许缓存空值。</span><br><span class="line">spring.cache.redis.key-prefix = ＃键前缀。</span><br><span class="line">spring.cache.redis.time-to-live = ＃条目到期。默认情况下，条目永不过期。</span><br><span class="line">spring.cache.redis.use-key-prefix = true＃写入Redis时是否使用密钥前缀。</span><br><span class="line">spring.cache.type = #Cache 类型。默认情况下，根据环境自动检测。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-CONFIG-仅使用环境属性（ConfigFileApplicationListener）"><a href="#SPRING-CONFIG-仅使用环境属性（ConfigFileApplicationListener）" class="headerlink" title="SPRING CONFIG  - 仅使用环境属性（ConfigFileApplicationListener）"></a>SPRING CONFIG  - 仅使用环境属性（ConfigFileApplicationListener）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.config.additional-location = ＃配置除默认值之外使用的文件位置。</span><br><span class="line">spring.config.location = ＃配置替换默认值的文件位置。</span><br><span class="line">spring.config.name = application ＃配置文件名</span><br></pre></td></tr></table></figure>
<h3 id="HAZELCAST（HazelcastProperties）"><a href="#HAZELCAST（HazelcastProperties）" class="headerlink" title="HAZELCAST（HazelcastProperties）"></a>HAZELCAST（HazelcastProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.hazelcast.config = ＃用于初始化Hazelcast的配置文件的位置</span><br></pre></td></tr></table></figure>
<h3 id="PROJECT-INFORMATION（ProjectInfoProperties）"><a href="#PROJECT-INFORMATION（ProjectInfoProperties）" class="headerlink" title="PROJECT INFORMATION（ProjectInfoProperties）"></a>PROJECT INFORMATION（ProjectInfoProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.info.build.encoding = UTF-8 ＃文件编码。</span><br><span class="line">spring.info.build.location = classpath：META-INF / build-info.properties ＃生成的build-info.properties文件的位置。</span><br><span class="line">spring.info.git.encoding = UTF-8 ＃文件编码。</span><br><span class="line">spring.info.git.location =类路径：git.properties 生成的git.properties文件＃所在</span><br></pre></td></tr></table></figure>
<h3 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.jmx.default域 = ＃JMX域名。</span><br><span class="line">spring.jmx.enabled = true ＃将管理bean公开给JMX域。</span><br><span class="line">spring.jmx.server = mbeanServer ＃MBeanServer bean name。</span><br><span class="line">spring.jmx.unique-names = false ＃是否应确保唯一的运行时对象名称</span><br></pre></td></tr></table></figure>
<h3 id="Email-（MailProperties）"><a href="#Email-（MailProperties）" class="headerlink" title="Email （MailProperties）"></a>Email （MailProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.default-encoding = UTF-8 ＃默认MimeMessage编码。</span><br><span class="line">spring.mail.host = #SMTP 服务器主机。例如，`smtp.example.com`。</span><br><span class="line">spring.mail.jndi-name = ＃会话JNDI名称。设置时，优先于其他会话设置。</span><br><span class="line">spring.mail.password = #SMTP 服务器的登录密码。</span><br><span class="line">spring.mail.port = #SMTP 服务器端口。</span><br><span class="line">spring.mail.properties。* = ＃其他JavaMail会话属性。</span><br><span class="line">spring.mail.protocol = smtp ＃SMTP服务器使用的协议。</span><br><span class="line">spring.mail.test-connection = false＃是否在启动时测试邮件服务器是否可用。</span><br><span class="line">spring.mail.username = #SMTP 服务器的登录用户</span><br></pre></td></tr></table></figure>
<h3 id="APICING-SETTINGS（SpringApplication）"><a href="#APICING-SETTINGS（SpringApplication）" class="headerlink" title="APICING SETTINGS（SpringApplication）"></a>APICING SETTINGS（SpringApplication）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.main.allow-bean-definition-overriding = false ＃是否允许通过注册与现有定义同名的定义来覆盖bean定义。</span><br><span class="line">spring.main.banner-mode = console ＃模式用于在应用程序运行时显示横幅。</span><br><span class="line">spring.main.sources = 要包含在ApplicationContext中的</span><br></pre></td></tr></table></figure>
<h3 id="Sources-（类名，包名或XML资源位置）"><a href="#Sources-（类名，包名或XML资源位置）" class="headerlink" title="Sources （类名，包名或XML资源位置）"></a>Sources （类名，包名或XML资源位置）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.main.web-application-type = ＃用于显式请求特定类型的Web应用程序的标志。如果未设置，则基于类路径自动检测。</span><br></pre></td></tr></table></figure>
<h3 id="FILE-ENCODING（FileEncodingApplicationListener）"><a href="#FILE-ENCODING（FileEncodingApplicationListener）" class="headerlink" title="FILE ENCODING（FileEncodingApplicationListener）"></a>FILE ENCODING（FileEncodingApplicationListener）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mandatory-file-encoding = ＃应用程序必须使用的预期字符编码</span><br></pre></td></tr></table></figure>
<h3 id="INTERINGIZATION-（MessageSourceProperties）"><a href="#INTERINGIZATION-（MessageSourceProperties）" class="headerlink" title="INTERINGIZATION （MessageSourceProperties）"></a>INTERINGIZATION （MessageSourceProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.always-use-message-format = false ＃是否始终应用MessageFormat规则，甚至解析不带参数的消息。</span><br><span class="line">spring.messages.basename = messages ＃逗号分隔的basenames列表（本质上是一个完全限定的类路径位置），每个都遵循ResourceBundle约定，轻松支持基于斜杠的位置。</span><br><span class="line">spring.messages.cache-duration = ＃加载的资源包文件缓存持续时间。未设置时，捆绑包将永久缓存。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.messages.encoding = UTF-8 ＃消息包编码。</span><br><span class="line">spring.messages.fallback-to-system-locale = true ＃如果找不到特定区域设置的文件，是否回退到系统区域设置。</span><br><span class="line">spring.messages.use-code-as-default-message = false ＃是否使用消息代码作为默认消息而不是抛出“NoSuchMessageException”。仅在开发期间推荐。</span><br></pre></td></tr></table></figure>
<h3 id="OUTPUT"><a href="#OUTPUT" class="headerlink" title="OUTPUT"></a>OUTPUT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.output.ansi.enabled =检测＃配置的ANSI输出</span><br></pre></td></tr></table></figure>
<h3 id="PID-FILE（ApplicationPidFileWriter）"><a href="#PID-FILE（ApplicationPidFileWriter）" class="headerlink" title="PID FILE（ApplicationPidFileWriter）"></a>PID FILE（ApplicationPidFileWriter）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.pid.fail-on-write-error = ＃如果使用ApplicationPidFileWriter但它无法写入PID文件，则失败。</span><br><span class="line">spring.pid.file = ＃要写入的PID文件的位置（如果使用ApplicationPidFileWriter）</span><br></pre></td></tr></table></figure>
<h3 id="PROFILES"><a href="#PROFILES" class="headerlink" title="PROFILES"></a>PROFILES</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active = ＃逗号分隔的有源配置文件列表。可以通过命令行开关覆盖。</span><br><span class="line">spring.profiles.include = ＃无条件地激活指定的逗号分隔的配置文件列表（如果使用YAML，则激活配置文件列表）。</span><br></pre></td></tr></table></figure>
<h3 id="Quartz调度器（QuartzProperties）"><a href="#Quartz调度器（QuartzProperties）" class="headerlink" title="Quartz调度器（QuartzProperties）"></a>Quartz调度器（QuartzProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.auto-启动 =真＃是否自动启动初始化后的调度。</span><br><span class="line">spring.quartz.jdbc.comment-prefix =  - #SQL 初始化脚本中单行注释的前缀。</span><br><span class="line">spring.quartz.jdbc.initialize-schema = embedded ＃数据库模式初始化模式。</span><br><span class="line">spring.quartz.jdbc.schema = classpath：org / quartz / impl / jdbcjobstore / tables_ @ @ platform @@ .sql ＃用于初始化数据库模式的SQL文件的路径。</span><br><span class="line">spring.quartz.job-store-type = memory ＃Quartz作业存储类型。</span><br><span class="line">spring.quartz.overwrite-existing-jobs = false ＃配置的作业是否应覆盖现有的作业定义。</span><br><span class="line">spring.quartz.properties。* = ＃其他Quartz Scheduler属性。</span><br><span class="line">spring.quartz.scheduler-name = quartzScheduler ＃调度程序的名称。</span><br><span class="line">spring.quartz.startup-delay = 0s ＃一旦初始化完成，调度程序启动之后的延迟。</span><br><span class="line">spring.quartz.wait-for-jobs-to-complete-on-shutdown = false ＃是否等待在关闭时运行的作业完成。</span><br></pre></td></tr></table></figure>
<h3 id="REACTOR-（ReactorCoreProperties）"><a href="#REACTOR-（ReactorCoreProperties）" class="headerlink" title="REACTOR （ReactorCoreProperties）"></a>REACTOR （ReactorCoreProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.reactor.stacktrace -mode.enabled = false #Reactor 是否应该在运行时收集堆栈跟踪信息。</span><br></pre></td></tr></table></figure>
<h3 id="SENDGRID（SendGridAutoConfiguration）"><a href="#SENDGRID（SendGridAutoConfiguration）" class="headerlink" title="SENDGRID（SendGridAutoConfiguration）"></a>SENDGRID（SendGridAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.sendgrid.api-key = ＃SendGrid API密钥。</span><br><span class="line">spring.sendgrid.proxy.host = ＃SendGrid代理主机。</span><br><span class="line">spring.sendgrid.proxy.port = ＃SendGrid代理端口。</span><br></pre></td></tr></table></figure>
<h3 id="TASK-EXECUTION（TaskExecutionProperties）"><a href="#TASK-EXECUTION（TaskExecutionProperties）" class="headerlink" title="TASK EXECUTION（TaskExecutionProperties）"></a>TASK EXECUTION（TaskExecutionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.task.execution.pool.allow-core-thread-timeout = true ＃是否允许核心线程超时。这可以实现池的动态增长和收缩。</span><br><span class="line">spring.task.execution.pool.core-size = 8 ＃核心线程数。</span><br><span class="line">spring.task.execution.pool.keep-alive = 60s ＃终止之前线程可能保持空闲的时间限制。</span><br><span class="line">spring.task.execution.pool.max-size = ＃允许的最大线程数。如果任务正在填满队列，则池可以扩展到该大小以适应负载。如果队列无限制，则忽略。</span><br><span class="line">spring.task.execution.pool.queue-capacity =＃队列容量。无限制的容量不会增加池，因此会忽略“max-size”属性。</span><br><span class="line">spring.task.execution.thread-name-prefix = task- ＃用于新创建的线程名称的前缀。</span><br></pre></td></tr></table></figure>
<h3 id="TASK-SCHEDULING（TaskSchedulingProperties）"><a href="#TASK-SCHEDULING（TaskSchedulingProperties）" class="headerlink" title="TASK SCHEDULING（TaskSchedulingProperties）"></a>TASK SCHEDULING（TaskSchedulingProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.task.scheduling.pool.size = 1 ＃允许的最大线程数。</span><br><span class="line">spring.task.scheduling.thread-name-prefix = scheduling- ＃用于新创建的线程名称的前缀。</span><br></pre></td></tr></table></figure>
<h2 id="WEB-PROPERTIES"><a href="#WEB-PROPERTIES" class="headerlink" title="WEB PROPERTIES"></a>WEB PROPERTIES</h2><h3 id="EmbEDDED-SERVER-CONFIGURATION（ServerProperties）"><a href="#EmbEDDED-SERVER-CONFIGURATION（ServerProperties）" class="headerlink" title="EmbEDDED SERVER CONFIGURATION（ServerProperties）"></a>EmbEDDED SERVER CONFIGURATION（ServerProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">server.address = ＃服务器应绑定到的网络地址。</span><br><span class="line">server.compression.enabled = false ＃是否启用了响应压缩。</span><br><span class="line">server.compression.excluded-user-agents = ＃逗号分隔的用户代理列表，不应压缩响应。</span><br><span class="line">server.compression.mime-types = text / html，text / xml，text / plain，text / css，text / javascript，application / javascript，application / json，application / xml ＃逗号分隔的MIME类型列表应该是压缩。</span><br><span class="line">server.compression.min-response-size = 2KB＃执行压缩所需的最小“Content-Length”值。</span><br><span class="line">server.connection-timeout = ＃连接器在关闭连接之前等待另一个HTTP请求的时间。未设置时，将使用连接器的特定于容器的默认值。使用值-1表示没有（即无限）超时。</span><br><span class="line">server.error.include-exception = false ＃包含“exception”属性。</span><br><span class="line">server.error.include-stacktrace = never ＃何时包含“stacktrace”属性。</span><br><span class="line">server.error.path = / error ＃错误控制器的路径。</span><br><span class="line">server.error.whitelabel.enabled = true＃是否在服务器出错时启用浏览器中显示的默认错误页面。</span><br><span class="line">server.http2.enabled = false ＃是否启用HTTP / 2支持，如果当前环境支持它。</span><br><span class="line">server.jetty.acceptors = -1 ＃要使用的接受者线程数。当值为-1（默认值）时，接受器的数量是从操作环境派生的。</span><br><span class="line">server.jetty.accesslog.append = false ＃追加到日志。</span><br><span class="line">server.jetty.accesslog.date-format = dd / MMM / yyyy：HH：mm：ss Z ＃请求日志的时间戳格式。</span><br><span class="line">server.jetty.accesslog.enabled = false ＃启用访问日志。</span><br><span class="line">server.jetty.accesslog.extended-format = false＃启用扩展NCSA格式。</span><br><span class="line">server.jetty.accesslog.file-date-format = ＃日期文件名中的日期格式。</span><br><span class="line">server.jetty.accesslog.filename = ＃日志文件名。如果未指定，则日志重定向到“System.err”。</span><br><span class="line">server.jetty.accesslog.locale = ＃请求日志的区域设置。</span><br><span class="line">server.jetty.accesslog.log-cookies = false ＃启用请求cookie的记录。</span><br><span class="line">server.jetty.accesslog.log-latency = false ＃启用请求处理时间的记录。</span><br><span class="line">server.jetty.accesslog.log-server = false ＃启用请求主机名的日志记录。</span><br><span class="line">server.jetty.accesslog.retention-period = 31＃删除旋转日志文件之前的天数。</span><br><span class="line">server.jetty.accesslog.time-zone = GMT ＃请求日志的时区。</span><br><span class="line">server.jetty.max-http-post-size = 200000B #HTTP post或put内容的最大大小。</span><br><span class="line">server.jetty.selectors = -1 ＃要使用的选择器线程数。当值为-1（默认值）时，选择器的数量是从操作环境派生的。</span><br><span class="line">server.max-http-header-size = 8KB #HTTP 邮件头的最大大小。</span><br><span class="line">server.port = 8080 ＃服务器HTTP端口。</span><br><span class="line">server.server-header = ＃用于Server响应头的值（如果为空，则不发送头）。</span><br><span class="line">server.use-forward-headers = ＃是否应将X-Forwarded- *标头应用于HttpRequest。</span><br><span class="line">server.servlet.context-parameters。* = ＃Servlet context init参数。</span><br><span class="line">server.servlet.context-path = ＃应用程序的上下文路径。</span><br><span class="line">server.servlet.application-display-name = application ＃显示</span><br><span class="line">应用程序的名称。server.servlet.jsp.class-name = org.apache.jasper.servlet.JspServlet ＃用于JSP的servlet的类名。</span><br><span class="line">server.servlet.jsp.init-parameters。* = ＃用于配置JSP servlet的Init参数。</span><br><span class="line">server.servlet.jsp.registered = true＃是否已注册JSP servlet。</span><br><span class="line">server.servlet.session.cookie.comment = ＃会话cookie的评论。</span><br><span class="line">server.servlet.session.cookie.domain = ＃会话cookie的域名。</span><br><span class="line">server.servlet.session.cookie.http-only = ＃是否对会话cookie使用“HttpOnly”cookie。</span><br><span class="line">server.servlet.session.cookie.max-age = ＃会话cookie的最大年龄。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">server.servlet.session.cookie.name = ＃会话cookie名称。</span><br><span class="line">server.servlet.session.cookie.path = ＃会话cookie的路径。</span><br><span class="line">server.servlet.session.cookie.secure =＃是否始终将会话cookie标记为安全。</span><br><span class="line">server.servlet.session.persistent = false ＃是否在重新启动之间保留会话数据。</span><br><span class="line">server.servlet.session.store-dir = ＃用于存储会话数据的目录。</span><br><span class="line">server.servlet.session.timeout = 30m ＃会话超时。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">server.servlet.session.tracking-modes = ＃会话跟踪模式。</span><br><span class="line">server.ssl.ciphers = ＃支持的SSL密码。</span><br><span class="line">server.ssl.client-auth = ＃客户端身份验证模式。</span><br><span class="line">server.ssl.enabled = true ＃是否启用SSL支持。</span><br><span class="line">server.ssl.enabled-protocols = ＃启用SSL协议。</span><br><span class="line">server.ssl.key-alias = ＃标识密钥库中密钥的别名。</span><br><span class="line">server.ssl.key-password = ＃用于访问密钥库中密钥的密码。</span><br><span class="line">server.ssl.key-store = ＃保存SSL证书的密钥库的路径（通常是jks文件）。</span><br><span class="line">server.ssl.key-store-password = ＃用于访问密钥库的密码。</span><br><span class="line">server.ssl.key-store-provider = ＃密钥库的提供者。</span><br><span class="line">server.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">server.ssl.protocol = TLS ＃要使用的SSL协议。</span><br><span class="line">server.ssl.trust-store = ＃持有SSL证书的信任存储。</span><br><span class="line">server.ssl.trust-store-password = ＃用于访问信任库的密码。</span><br><span class="line">server.ssl.trust-store-provider = ＃信任存储的提供者。</span><br><span class="line">server.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">server.tomcat.accept-count = 100 ＃当所有可能的请求处理线程都在使用时，传入连接请求的最大队列长度。</span><br><span class="line">server.tomcat.accesslog.buffered = true ＃是否缓冲输出，使其仅定期刷新。</span><br><span class="line">server.tomcat.accesslog.directory = logs＃创建日志文件的目录。可以绝对或相对于Tomcat基础目录。</span><br><span class="line">server.tomcat.accesslog.enabled = false ＃启用访问日志。</span><br><span class="line">server.tomcat.accesslog.file-date-format = .yyyy-MM-dd ＃要放在日志文件名中的日期格式。</span><br><span class="line">server.tomcat.accesslog.pattern = common ＃访问日志的格式模式。</span><br><span class="line">server.tomcat.accesslog.prefix = access_log ＃日志文件名前缀。</span><br><span class="line">server.tomcat.accesslog.rename-on-rotate = false ＃是否延迟在文件名中包含日期戳，直到旋转时间。</span><br><span class="line">server.tomcat.accesslog.request-attributes-enabled = false＃设置请求的IP地址，主机名，协议和端口的请求属性。</span><br><span class="line">server.tomcat.accesslog.rotate = true ＃是否启用访问日志轮换。</span><br><span class="line">server.tomcat.accesslog.suffix = .log ＃日志文件名后缀。</span><br><span class="line">server.tomcat.additional-tld-skip-patterns = ＃逗号分隔的其他模式列表，这些模式匹配要忽略的TLD扫描的jar。</span><br><span class="line">server.tomcat.background-processor-delay = 10s #backgroundProcess 方法调用之间的延迟。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">server.tomcat.basedir = #Tomcat 基目录。如果未指定，则使用临时目录。</span><br><span class="line">server.tomcat.internal-proxies = 10 \\.\\ d &#123;1,3&#125; \\.\\ d &#123;1,3&#125; \\.\\ d &#123;1,3&#125; | \\</span><br><span class="line">		.192 \\ 168 \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; | \\</span><br><span class="line">		.169 \\ 254 \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; | \\</span><br><span class="line">		.127 \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; | \\</span><br><span class="line">		172 \\ 1 [6-9] &#123;1&#125; \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; |..\\</span><br><span class="line">		172 \\ 2 [0-9] &#123;1&#125; \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; |..\\</span><br><span class="line">		172 \\.3 [0-1] &#123;1&#125; \\.\\ d &#123;1,3&#125; \\.\\ d &#123;1,3&#125; \\</span><br><span class="line">		0：0：0：0：0：0：0：1 \\</span><br><span class="line"> 		:: 1 ＃正则表达式匹配要信任的代理。</span><br><span class="line">server.tomcat.max-connections = 10000 ＃服务器在任何给定时间接受和处理的最大连接数。</span><br><span class="line">server.tomcat.max-http-post-size = 2MB #HTTP 帖子内容的最大大小。</span><br><span class="line">server.tomcat.max-swallow-size = 2MB ＃要吞咽的请求正文的最大数量。</span><br><span class="line">server.tomcat.max-threads = 200 ＃最大工作线程数。</span><br><span class="line">server.tomcat.min-spare-threads = 10 ＃最小工作线程数。</span><br><span class="line">server.tomcat.port-header = X-Forwarded-Port＃用于覆盖原始端口值的HTTP头的名称。</span><br><span class="line">server.tomcat.protocol-header = ＃包含传入协议的头文件，通常命名为“X-Forwarded-Proto”。</span><br><span class="line">server.tomcat.protocol-header-https-value = https ＃协议标头的值，指示传入请求是否使用SSL。</span><br><span class="line">server.tomcat.redirect-context-root = true ＃是否应通过在路径中附加/来重定向对上下文根的请求。</span><br><span class="line">server.tomcat.remote-ip-header = ＃从中提取远程IP的HTTP头的名称。例如，`X-FORWARDED-FOR`。</span><br><span class="line">server.tomcat.resource.allow-caching = true＃是否允许此Web应用程序使用静态资源缓存。</span><br><span class="line">server.tomcat.resource.cache-ttl = ＃静态资源缓存的生存时间。</span><br><span class="line">server.tomcat.uri-encoding = UTF-8 ＃用于解码URI的字符编码。</span><br><span class="line">server.tomcat.use-relative-redirects = ＃通过调用sendRedirect生成的HTTP 1.1和更高版本的位置标头是使用相对还是绝对重定向。</span><br><span class="line">server.undertow.accesslog.dir = #Undertow 访问日志目录。</span><br><span class="line">server.undertow.accesslog.enabled = false ＃是否启用访问日志。</span><br><span class="line">server.undertow.accesslog.pattern = common ＃访问日志的格式模式。</span><br><span class="line">server.undertow.accesslog.prefix = access_log。＃日志文件名前缀。</span><br><span class="line">server.undertow.accesslog.rotate = true ＃是否启用访问日志轮换。</span><br><span class="line">server.undertow.accesslog.suffix = log ＃日志文件名后缀。</span><br><span class="line">server.undertow.buffer-size = ＃每个缓冲区的大小。</span><br><span class="line">server.undertow.direct-buffers = ＃是否在Java堆外部分配缓冲区。默认值源自JVM可用的最大内存量。</span><br><span class="line">server.undertow.eager-filter-init = true ＃是否应在启动时初始化servlet过滤器。</span><br><span class="line">server.undertow.io-threads =＃为worker创建的I / O线程数。默认值源自可用处理器的数量。</span><br><span class="line">server.undertow.max-http-post-size = -1B #HTTP 帖子内容的最大大小。当值为-1时，默认值为大小无限制。</span><br><span class="line">server.undertow.worker-threads = ＃工作线程数。默认值是I / O线程数的8倍。</span><br></pre></td></tr></table></figure>
<h3 id="FREEMARKER（FreeMarkerProperties）"><a href="#FREEMARKER（FreeMarkerProperties）" class="headerlink" title="FREEMARKER（FreeMarkerProperties）"></a>FREEMARKER（FreeMarkerProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring.freemarker.allow-request-override = false ＃是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.freemarker.allow-session-override = false ＃是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.freemarker.cache = false ＃是否启用模板缓存。</span><br><span class="line">spring.freemarker.charset = UTF-8 ＃模板编码。</span><br><span class="line">spring.freemarker.check-template-location = true ＃是否检查模板位置是否存在。</span><br><span class="line">spring.freemarker.content-type = text / html ＃Content-Type value。</span><br><span class="line">spring.freemarker.enabled = true ＃是否为此技术启用MVC视图分辨率。</span><br><span class="line">spring.freemarker.expose-request-attributes = false ＃是否应在与模板合并之前将所有请求属性添加到模型中。</span><br><span class="line">spring.freemarker.expose-session-attributes = false ＃是否应在与模板合并之前将所有HttpSession属性添加到模型中。</span><br><span class="line">spring.freemarker.expose-spring-macro-helpers = true ＃是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。</span><br><span class="line">spring.freemarker.prefer-file-system-access = true ＃是否更喜欢文件系统访问以进行模板加载。文件系统访问可以热检测模板更改。</span><br><span class="line">spring.freemarker.prefix = ＃在构建URL时添加前缀以查看名称的前缀。</span><br><span class="line">spring.freemarker.request-context-attribute = ＃所有视图的</span><br><span class="line">RequestContext属性的名称。spring.freemarker.settings。* = ＃众所周知的FreeMarker密钥，传递给FreeMarker的配置。</span><br><span class="line">spring.freemarker.suffix = .ftl ＃在构建URL时附加到视图名称的后缀。</span><br><span class="line">spring.freemarker.template-loader-path = classpath：/ templates /＃逗号分隔的模板路径列表。</span><br><span class="line">spring.freemarker.view-names = ＃可以解析的视图名称的白名单。</span><br></pre></td></tr></table></figure>
<h3 id="GLOVY-TEMPLATES（GroovyTemplateProperties）"><a href="#GLOVY-TEMPLATES（GroovyTemplateProperties）" class="headerlink" title="GLOVY TEMPLATES（GroovyTemplateProperties）"></a>GLOVY TEMPLATES（GroovyTemplateProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring.groovy.template.allow-request-override = false ＃是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.groovy.template.allow-session-override = false ＃是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.groovy.template.cache = false ＃是否启用模板缓存。</span><br><span class="line">spring.groovy.template.charset = UTF-8 ＃模板编码。</span><br><span class="line">spring.groovy.template.check-template-location = true＃是否检查模板位置是否存在。</span><br><span class="line">spring.groovy.template.configuration。* = ＃请参阅GroovyMarkupConfigurer </span><br><span class="line">spring.groovy.template.content-type = text / html ＃Content-Type value。</span><br><span class="line">spring.groovy.template.enabled = true ＃是否为此技术启用MVC视图分辨率。</span><br><span class="line">spring.groovy.template.expose-request-attributes = false ＃是否应在与模板合并之前将所有请求属性添加到模型中。</span><br><span class="line">spring.groovy.template.expose-session-attributes = false ＃在与模板合并之前是否应将所有HttpSession属性添加到模型中。</span><br><span class="line">spring.groovy.template.expose-spring-macro-helpers = true ＃是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。</span><br><span class="line">spring.groovy.template.prefix = ＃在构建URL时添加前缀以查看名称的前缀。</span><br><span class="line">spring.groovy.template.request-context-attribute = ＃所有视图的</span><br><span class="line">RequestContext属性的名称。spring.groovy.template.resource-loader-path = classpath：/ templates / ＃Template path。</span><br><span class="line">spring.groovy.template.suffix = .tpl ＃在构建URL时附加到视图名称的后缀。</span><br><span class="line">spring.groovy.template.view-names =＃可以解析的视图名称的白名单。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-HATEOAS（HateoasProperties）"><a href="#SPRING-HATEOAS（HateoasProperties）" class="headerlink" title="SPRING HATEOAS（HateoasProperties）"></a>SPRING HATEOAS（HateoasProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.hateoas.use-hal-as-default-json-media-type = true ＃是否应将application / hal + json响应发送给接受application / json的请求。</span><br></pre></td></tr></table></figure>
<h3 id="HTTP-（HttpProperties）"><a href="#HTTP-（HttpProperties）" class="headerlink" title="HTTP （HttpProperties）"></a>HTTP （HttpProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.http.converters.preferred-json-mapper = ＃用于HTTP消息转换的首选JSON映射器。默认情况下，根据环境自动检测。</span><br><span class="line">spring.http.encoding.charset = UTF-8 #HTTP 请求和响应的字符集。如果未明确设置，则添加到“Content-Type”标头。</span><br><span class="line">spring.http.encoding.enabled = true ＃是否启用http编码支持。</span><br><span class="line">spring.http.encoding.force = ＃是否在HTTP请求和响应上强制编码到已配置的字符集。</span><br><span class="line">spring.http.encoding.force-request =＃是否在HTTP请求中强制编码到配置的字符集。如果未指定“force”，则默认为true。</span><br><span class="line">spring.http.encoding.force-response = ＃是否在HTTP响应中强制编码到配置的字符集。</span><br><span class="line">spring.http.encoding.mapping = ＃用于编码映射的Locale。</span><br><span class="line">spring.http.log-request-details = false ＃是否允许在DEBUG和TRACE级别记录（可能敏感的）请求详细信息。</span><br></pre></td></tr></table></figure>
<h3 id="MULTIPART-（MultipartProperties）"><a href="#MULTIPART-（MultipartProperties）" class="headerlink" title="MULTIPART （MultipartProperties）"></a>MULTIPART （MultipartProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.servlet.multipart.enabled = true ＃是否启用分段上传支持。</span><br><span class="line">spring.servlet.multipart.file-size-threshold = 0B ＃将文件写入磁盘后的阈值。</span><br><span class="line">spring.servlet.multipart.location = ＃上传文件的中间位置。</span><br><span class="line">spring.servlet.multipart.max-file-size = 1MB ＃最大文件大小。</span><br><span class="line">spring.servlet.multipart.max-request-size = 10MB ＃最大请求大小。</span><br><span class="line">spring.servlet.multipart.resolve-lazily = false ＃是否在文件或参数访问时懒惰地解析多部分请求。</span><br></pre></td></tr></table></figure>
<h3 id="JACKSON-（JacksonProperties）"><a href="#JACKSON-（JacksonProperties）" class="headerlink" title="JACKSON （JacksonProperties）"></a>JACKSON （JacksonProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring.jackson.date-format = ＃日期格式字符串或完全限定的日期格式类名。例如，`yyyy-MM-dd HH：mm：ss`。</span><br><span class="line">spring.jackson.default-property-inclusion = ＃控制序列化期间包含的属性。配置了Jackson的JsonInclude.Include枚举中的一个值。</span><br><span class="line">spring.jackson.deserialization。* = #Jackson on / off功能会影响Java对象的反序列化方式。</span><br><span class="line">spring.jackson.generator。* = ＃Jackson开/关功能的发电机。</span><br><span class="line">spring.jackson.joda-date-time-format =#Joda日期时间格式字符串。如果未配置，如果使用格式字符串配置，则使用“date-format”作为后备。</span><br><span class="line">spring.jackson.locale = ＃用于格式化的区域设置。</span><br><span class="line">spring.jackson.mapper。* = #Jackson 通用开/关功能。</span><br><span class="line">spring.jackson.parser。* = ＃Jackson开启/关闭解析器的功能。</span><br><span class="line">spring.jackson.property-naming-strategy = #Jackson PropertyNamingStrategy的常数之一。也可以是PropertyNamingStrategy子类的完全限定类名。</span><br><span class="line">spring.jackson.serialization。* = #Jacker on / off功能会影响Java对象的序列化方式。</span><br><span class="line">spring.jackson.time-zone =＃格式化日期时使用的时区。例如，“America / Los_Angeles”或“GMT + 10”。</span><br><span class="line">spring.jackson.visibility。* = #Jackson 可见性阈值，可用于限制自动检测哪些方法（和字段）。</span><br></pre></td></tr></table></figure>
<h3 id="GSON（GsonProperties）"><a href="#GSON（GsonProperties）" class="headerlink" title="GSON（GsonProperties）"></a>GSON（GsonProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring.gson.date-format = ＃序列化Date对象时使用的格式。</span><br><span class="line">spring.gson.disable -html-escaping = ＃是否禁用HTML字符的转义，例如&apos;&lt;&apos;，&apos;&gt;&apos;等</span><br><span class="line">spring.gson.disable-inner-class-serialization = ＃是否在内容类中排除内部类序列化。</span><br><span class="line">spring.gson.enable-complex-map-key-serialization = ＃是否启用复杂映射键（即非基元）的序列化。</span><br><span class="line">spring.gson.exclude-fields-without-expose-annotation = ＃是否排除所有不考虑序列化或反序列化但没有“Expose”注释的字段。</span><br><span class="line">spring.gson.field-naming-policy = ＃在序列化和反序列化期间应该应用于对象字段的命名策略。</span><br><span class="line">spring.gson.generate-non-executable-json = ＃是否通过在输出前添加一些特殊文本来生成不可执行的JSON。</span><br><span class="line">spring.gson.lenient = ＃是否宽容解析不符合RFC 4627的</span><br><span class="line">JSON.chring.gson.long-serialization-policy = ＃长和长类型的序列化策略。</span><br><span class="line">spring.gson.pretty-printing = ＃是否输出适合页面的序列化JSON以进行漂亮的打印。</span><br><span class="line">spring.gson.serialize-nulls = ＃是否序列化空字段。</span><br></pre></td></tr></table></figure>
<h3 id="JERSEY-（JerseyProperties）"><a href="#JERSEY-（JerseyProperties）" class="headerlink" title="JERSEY （JerseyProperties）"></a>JERSEY （JerseyProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.jersey.application-path = ＃作为应用程序基URI的路径。如果指定，则覆盖“@ApplicationPath”的值。</span><br><span class="line">spring.jersey.filter.order = 0 ＃Jersey过滤链顺序。</span><br><span class="line">spring.jersey.init。* = ＃通过servlet或过滤器传递给Jersey的Init参数。</span><br><span class="line">spring.jersey.servlet.load-on-startup = -1 ＃加载Jersey servlet的启动优先级。</span><br><span class="line">spring.jersey.type = servlet ＃Jersey集成类型。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-LDAP（LdapProperties）"><a href="#SPRING-LDAP（LdapProperties）" class="headerlink" title="SPRING LDAP（LdapProperties）"></a>SPRING LDAP（LdapProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.anonymous-read-only = false ＃只读操作是否应使用匿名环境。</span><br><span class="line">spring.ldap.base = #Base 后缀，所有操作都应该来自该后缀。</span><br><span class="line">spring.ldap.base-environment。* = #LDAP 规范设置。</span><br><span class="line">spring.ldap.password = ＃服务器的登录密码。</span><br><span class="line">spring.ldap.urls = ＃服务器的LDAP URL。</span><br><span class="line">spring.ldap.username = ＃登录服务器的用户名。</span><br></pre></td></tr></table></figure>
<h3 id="EMBEDDED-LDAP（EmbeddedLdapProperties）"><a href="#EMBEDDED-LDAP（EmbeddedLdapProperties）" class="headerlink" title="EMBEDDED LDAP（EmbeddedLdapProperties）"></a>EMBEDDED LDAP（EmbeddedLdapProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.embedded.base-dn = ＃基本DN列表。</span><br><span class="line">spring.ldap.embedded.credential.username = ＃嵌入式LDAP用户名。</span><br><span class="line">spring.ldap.embedded.credential.password = ＃嵌入式LDAP密码。</span><br><span class="line">spring.ldap.embedded.ldif = classpath：schema.ldif #Schema （LDIF）脚本资源引用。</span><br><span class="line">spring.ldap.embedded.port = 0 ＃嵌入式LDAP端口。</span><br><span class="line">spring.ldap.embedded.validation.enabled = true ＃是否启用LDAP模式验证。</span><br><span class="line">spring.ldap.embedded.validation.schema = ＃自定义架构的路径。</span><br></pre></td></tr></table></figure>
<h3 id="MUSTACHE-TEMPLATES（MustacheAutoConfiguration）"><a href="#MUSTACHE-TEMPLATES（MustacheAutoConfiguration）" class="headerlink" title="MUSTACHE TEMPLATES（MustacheAutoConfiguration）"></a>MUSTACHE TEMPLATES（MustacheAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring.mustache.allow-request-override = false ＃是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.mustache.allow-session-override = false ＃是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.mustache.cache = false ＃是否启用模板缓存。</span><br><span class="line">spring.mustache.charset = UTF-8 ＃模板编码。</span><br><span class="line">spring.mustache.check-template-location = true ＃是否检查模板位置是否存在。</span><br><span class="line">spring.mustache.content-type = text / html ＃Content-Type value。</span><br><span class="line">spring.mustache.enabled = true ＃是否为此技术启用MVC视图分辨率。</span><br><span class="line">spring.mustache.expose-request-attributes = false ＃在与模板合并之前是否应将所有请求属性添加到模型中。</span><br><span class="line">spring.mustache.expose-session-attributes = false ＃在与模板合并之前是否应将所有HttpSession属性添加到模型中。</span><br><span class="line">spring.mustache.expose-spring-macro-helpers = true ＃是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。</span><br><span class="line">spring.mustache.prefix= classpath：/ templates / ＃适用于模板名称的前缀。</span><br><span class="line">spring.mustache.request-context-attribute = ＃所有视图的</span><br><span class="line">RequestContext属性的名称。spring.mustache.suffix = .mustache ＃后缀应用于模板名称。</span><br><span class="line">spring.mustache.view-names = ＃可以解析的视图名称的白名单。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-MVC（WebMvcProperties）"><a href="#SPRING-MVC（WebMvcProperties）" class="headerlink" title="SPRING MVC（WebMvcProperties）"></a>SPRING MVC（WebMvcProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.async.request-timeout = ＃异步请求处理超时之前的时间。</span><br><span class="line">spring.mvc.contentnegotiation.favor-parameter = false ＃是否应使用请求参数（默认为“format”）来确定请求的媒体类型。</span><br><span class="line">spring.mvc.contentnegotiation.favor-path-extension = false ＃是否应使用URL路径中的路径扩展来确定所请求的媒体类型。</span><br><span class="line">spring.mvc.contentnegotiation.media-types。* = ＃映射内容协商的媒体类型的文件扩展名。例如，yml到text / yaml。</span><br><span class="line">spring.mvc.contentnegotiation.parameter-name =＃启用“favor-parameter”时要使用的查询参数名称。</span><br><span class="line">spring.mvc.date-format = ＃要使用的日期格式。例如，`dd / MM / yyyy`。</span><br><span class="line">spring.mvc.dispatch-trace-request = false ＃是否将TRACE请求分派给FrameworkServlet doService方法。</span><br><span class="line">spring.mvc.dispatch-options-request = true ＃是否将OPTIONS请求分派给FrameworkServlet doService方法。</span><br><span class="line">spring.mvc.favicon.enabled = true ＃是否启用favicon.ico的解析。</span><br><span class="line">spring.mvc.formcontent.filter.enabled = true ＃是否启用Spring的FormContentFilter。</span><br><span class="line">spring.mvc.hiddenmethod.filter.enabled = true＃是否启用Spring的HiddenHttpMethodFilter。</span><br><span class="line">spring.mvc.ignore-default-model-on-redirect = true ＃在重定向场景中是否应忽略“默认”模型的内容。</span><br><span class="line">spring.mvc.locale = ＃要使用的语言环境。默认情况下，“Accept-Language”标头会覆盖此区域设置。</span><br><span class="line">spring.mvc.locale-resolver = accept-header ＃定义应如何解析语言环境。</span><br><span class="line">spring.mvc.log-resolved-exception = false ＃是否启用由“HandlerExceptionResolver”解析的异常的警告日志记录，“DefaultHandlerExceptionResolver”除外。</span><br><span class="line">spring.mvc.message-codes-resolver-format =＃格式化消息代码的策略。例如，`PREFIX_ERROR_CODE`。</span><br><span class="line">spring.mvc.pathmatch.use-registered-suffix-pattern = false ＃后缀模式匹配是否仅适用于使用“spring.mvc.contentnegotiation.media-types。*”注册的扩展。</span><br><span class="line">spring.mvc.pathmatch.use-suffix-pattern = false ＃将模式与请求匹配时是否使用后缀模式匹配（“。*”）。</span><br><span class="line">spring.mvc.servlet.load-on-startup = -1 ＃加载调度程序servlet的启动优先级。</span><br><span class="line">spring.mvc.servlet.path = / ＃调度程序servlet的路径。</span><br><span class="line">spring.mvc.static-path-pattern = / ** ＃用于静态资源的路径模式。</span><br><span class="line">spring.mvc.throw-exception-if-no-handler-found = false ＃如果没有找到Handler来处理请求，是否应该抛出“NoHandlerFoundException”。</span><br><span class="line">spring.mvc.view.prefix = #Spring MVC视图前缀。</span><br><span class="line">spring.mvc.view.suffix = #Spring MVC视图后缀。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-RESOURCES-HANDLING（ResourceProperties）"><a href="#SPRING-RESOURCES-HANDLING（ResourceProperties）" class="headerlink" title="SPRING RESOURCES HANDLING（ResourceProperties）"></a>SPRING RESOURCES HANDLING（ResourceProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.add-mappings = true ＃是否启用默认资源处理。</span><br><span class="line">spring.resources.cache.cachecontrol.cache-private = ＃表示响应消息仅供单个用户使用，不得由共享高速缓存存储。</span><br><span class="line">spring.resources.cache.cachecontrol.cache-public = ＃表示任何缓存都可以存储响应。</span><br><span class="line">spring.resources.cache.cachecontrol.max-age = ＃应该缓存响应的最长时间，如果未指定持续时间后缀，则以秒为单位。</span><br><span class="line">spring.resources.cache.cachecontrol.must-revalidate =＃表示一旦它变得陈旧，缓存一定不能使用响应而不用服务器重新验证它。</span><br><span class="line">spring.resources.cache.cachecontrol.no-cache = ＃表示只有在与服务器重新验证时才能重用缓存的响应。</span><br><span class="line">spring.resources.cache.cachecontrol.no-store = ＃表示在任何情况下都不缓存响应。</span><br><span class="line">spring.resources.cache.cachecontrol.no-transform = ＃表明他们不应该转换响应内容的中介（缓存和其他人）。</span><br><span class="line">spring.resources.cache.cachecontrol.proxy-revalidate = ＃与“must-revalidate”指令的含义相同，但它不适用于私有缓存。</span><br><span class="line">spring.resources.cache.cachecontrol.s-max-age = ＃共享缓存应缓存响应的最长时间，如果未指定持续时间后缀，则以秒为单位。</span><br><span class="line">spring.resources.cache.cachecontrol.stale-if-error = ＃遇到错误时可以使用响应的最长时间，如果未指定持续时间后缀，则以秒为单位。</span><br><span class="line">spring.resources.cache.cachecontrol.stale-while-revalidate = ＃响应变为失效后可以响应的最长时间，如果未指定持续时间后缀，则以秒为单位。</span><br><span class="line">spring.resources.cache.period = ＃资源处理程序所服务资源的缓存周期。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.resources.chain.cache= true ＃是否在资源链中启用缓存。</span><br><span class="line">spring.resources.chain.compressed = false ＃是否启用已压缩资源的解析（gzip，brotli）。</span><br><span class="line">spring.resources.chain.enabled = ＃是否启用Spring资源处理链。默认情况下，禁用，除非至少启用了一个策略。</span><br><span class="line">spring.resources.chain.html-application-cache = false ＃是否启用HTML5应用程序缓存清单重写。</span><br><span class="line">spring.resources.chain.strategy.content.enabled = false ＃是否启用内容版本策略。</span><br><span class="line">spring.resources.chain.strategy.content.paths = / **＃逗号分隔的模式列表，应用于内容版本策略。</span><br><span class="line">spring.resources.chain.strategy.fixed.enabled = false ＃是否启用固定版本策略。</span><br><span class="line">spring.resources.chain.strategy.fixed.paths = / ** ＃以逗号分隔的模式列表应用于固定版本策略。</span><br><span class="line">spring.resources.chain.strategy.fixed.version = ＃用于固定版本策略的版本字符串。</span><br><span class="line">spring.resources.static-locations = classpath：/ META-INF / resources /，classpath：/ resources /，classpath：/ static /，classpath：/ public / ＃静态资源的位置。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-SESSION（SessionProperties）"><a href="#SPRING-SESSION（SessionProperties）" class="headerlink" title="SPRING SESSION（SessionProperties）"></a>SPRING SESSION（SessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.session.store-type = ＃会话存储类型。</span><br><span class="line">spring.session.timeout = ＃会话超时。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.session.servlet.filter-order = -2147483598 ＃会话存储库过滤顺序。</span><br><span class="line">spring.session.servlet.filter-dispatcher-types = async，error，request ＃会话存储库过滤器调度程序类型。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-SESSION-HAZELCAST（HazelcastSessionProperties）"><a href="#SPRING-SESSION-HAZELCAST（HazelcastSessionProperties）" class="headerlink" title="SPRING SESSION HAZELCAST（HazelcastSessionProperties）"></a>SPRING SESSION HAZELCAST（HazelcastSessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.session.hazelcast.flush-mode = on-save #sessions flush mode。</span><br><span class="line">spring.session.hazelcast.map-name = spring：session：sessions ＃用于存储会话的地图的名称。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-SESSION-JDBC（JdbcSessionProperties）"><a href="#SPRING-SESSION-JDBC（JdbcSessionProperties）" class="headerlink" title="SPRING SESSION JDBC（JdbcSessionProperties）"></a>SPRING SESSION JDBC（JdbcSessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.session.jdbc.cleanup-cron = 0 * * * * * #cron 表达式用于过期的会话清理作业。</span><br><span class="line">spring.session.jdbc.initialize-schema = embedded ＃数据库模式初始化模式。</span><br><span class="line">spring.session.jdbc.schema = classpath中：组织/ springframework的/会话/ JDBC / schema- @ @ 平台@ @ .SQL ＃的路径SQL文件，以用于初始化数据库架构。</span><br><span class="line">spring.session.jdbc.table-name = SPRING_SESSION ＃用于存储会话的数据库表的名称。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-SESSION-MONGODB（MongoSessionProperties）"><a href="#SPRING-SESSION-MONGODB（MongoSessionProperties）" class="headerlink" title="SPRING SESSION MONGODB（MongoSessionProperties）"></a>SPRING SESSION MONGODB（MongoSessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.mongodb.collection-name = sessions ＃用于存储会话的集合名称。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-SESSION-REDIS（RedisSessionProperties）"><a href="#SPRING-SESSION-REDIS（RedisSessionProperties）" class="headerlink" title="SPRING SESSION REDIS（RedisSessionProperties）"></a>SPRING SESSION REDIS（RedisSessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.session.redis.cleanup-cron = 0 * * * * * #cron 表达式用于过期的会话清理作业。</span><br><span class="line">spring.session.redis.flush-mode = on-save #sessions flush mode。</span><br><span class="line">spring.session.redis.namespace = spring：session ＃用于存储会话的密钥的命名空间。</span><br></pre></td></tr></table></figure>
<h3 id="THYMELEAF（ThymeleafAutoConfiguration）"><a href="#THYMELEAF（ThymeleafAutoConfiguration）" class="headerlink" title="THYMELEAF（ThymeleafAutoConfiguration）"></a>THYMELEAF（ThymeleafAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring.thymeleaf.cache = true ＃是否启用模板缓存。</span><br><span class="line">spring.thymeleaf.check-template = true ＃是否在呈现模板之前检查模板是否存在。</span><br><span class="line">spring.thymeleaf.check-template-location = true ＃是否检查模板位置是否存在。</span><br><span class="line">spring.thymeleaf.enabled = true ＃是否为Web框架启用Thymeleaf视图解析。</span><br><span class="line">spring.thymeleaf.enable-spring-el-compiler = false ＃在SpringEL表达式中启用SpringEL编译器。</span><br><span class="line">spring.thymeleaf.encoding = UTF-8 ＃模板文件编码。</span><br><span class="line">spring.thymeleaf.excluded-view-names = ＃逗号分隔的视图名称列表（允许的模式）应从分辨率中排除。</span><br><span class="line">spring.thymeleaf.mode = HTML ＃要应用于模板的模板模式。另请参见Thymeleaf的TemplateMode枚举。</span><br><span class="line">spring.thymeleaf.prefix = classpath：/ templates / ＃在构建URL时添加前缀以查看名称的前缀。</span><br><span class="line">spring.thymeleaf.reactive.chunked-mode-view-names = ＃逗号分隔的视图名称列表（允许的模式），当设置了最大块大小时，它应该是在CHUNKED模式下执行的唯一列表。</span><br><span class="line">spring.thymeleaf.reactive.full-mode-view-names =＃逗号分隔的视图名称列表（允许的模式），即使设置了最大块大小，也应该在FULL模式下执行。</span><br><span class="line">spring.thymeleaf.reactive.max-chunk-size = 0B ＃用于写入响应的数据缓冲区的最大大小。</span><br><span class="line">spring.thymeleaf.reactive.media-types = ＃视图技术支持的媒体类型。</span><br><span class="line">spring.thymeleaf.render-hidden-markers-before-checkboxes = false ＃是否应在复选框元素本身之前呈现隐藏的表单输入作为复选框的标记。</span><br><span class="line">spring.thymeleaf.servlet.content-type = text / html ＃Content-Type写入HTTP响应的值。</span><br><span class="line">spring.thymeleaf.servlet.produce-partial-output-while-processing = true#Thymeleaf是否应尽快开始编写部分输出或缓冲直到模板处理完成。</span><br><span class="line">spring.thymeleaf.suffix = .html ＃在构建URL时附加到视图名称的后缀。</span><br><span class="line">spring.thymeleaf.template-resolver-order = ＃链中模板解析器的顺序。</span><br><span class="line">spring.thymeleaf.view-names = ＃逗号分隔的视图名称列表（允许的模式），可以解析。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-WEBFLUX（WebFluxProperties）"><a href="#SPRING-WEBFLUX（WebFluxProperties）" class="headerlink" title="SPRING WEBFLUX（WebFluxProperties）"></a>SPRING WEBFLUX（WebFluxProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.webflux.date-format = ＃要使用的日期格式。例如，`dd / MM / yyyy`。</span><br><span class="line">spring.webflux.hiddenmethod.filter.enabled = true ＃是否启用Spring的HiddenHttpMethodFilter。</span><br><span class="line">spring.webflux.static-path-pattern = / ** ＃用于静态资源的路径模式。</span><br></pre></td></tr></table></figure>
<h3 id="SPRING-WEB-SERVICES（WebServicesProperties）"><a href="#SPRING-WEB-SERVICES（WebServicesProperties）" class="headerlink" title="SPRING WEB SERVICES（WebServicesProperties）"></a>SPRING WEB SERVICES（WebServicesProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.webservices.path = / services ＃作为服务基URI的路径。</span><br><span class="line">spring.webservices.servlet.init = ＃Servlet init参数传递给Spring Web Services。</span><br><span class="line">spring.webservices.servlet.load-on-startup = -1 ＃加载Spring Web Services servlet的启动优先级。</span><br><span class="line">spring.webservices.wsdl-locations = ＃逗号分隔的WSDL位置列表以及要作为bean公开的随附XSD。</span><br></pre></td></tr></table></figure>
<h2 id="SECURITY-PROPERTIES"><a href="#SECURITY-PROPERTIES" class="headerlink" title="SECURITY PROPERTIES"></a>SECURITY PROPERTIES</h2><h3 id="SECURITY（SecurityProperties）"><a href="#SECURITY（SecurityProperties）" class="headerlink" title="SECURITY（SecurityProperties）"></a>SECURITY（SecurityProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.security.filter.order = -100 ＃安全过滤器链顺序。</span><br><span class="line">spring.security.filter.dispatcher-types = async，error，request ＃安全过滤器链调度程序类型。</span><br><span class="line">spring.security.user.name = user ＃默认用户名。</span><br><span class="line">spring.security.user.password = ＃默认用户名的密码。</span><br><span class="line">spring.security.user.roles = ＃授予默认用户名的角色。</span><br></pre></td></tr></table></figure>
<h3 id="SECURITY-OAUTH2-CLIENT（OAuth2ClientProperties）"><a href="#SECURITY-OAUTH2-CLIENT（OAuth2ClientProperties）" class="headerlink" title="SECURITY OAUTH2 CLIENT（OAuth2ClientProperties）"></a>SECURITY OAUTH2 CLIENT（OAuth2ClientProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.provider。* = ＃OAuth提供商详细信息。</span><br><span class="line">spring.security.oauth2.client.registration。* = ＃OAuth客户注册。</span><br></pre></td></tr></table></figure>
<h3 id="SECURITY-OAUTH2-RESOURCE-SERVER（OAuth2ResourceServerProperties）"><a href="#SECURITY-OAUTH2-RESOURCE-SERVER（OAuth2ResourceServerProperties）" class="headerlink" title="SECURITY OAUTH2 RESOURCE SERVER（OAuth2ResourceServerProperties）"></a>SECURITY OAUTH2 RESOURCE SERVER（OAuth2ResourceServerProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.resourceserver.jwt.jwk-set-uri = ＃JSON用于验证JWT令牌的Web Key URI。</span><br><span class="line">spring.security.oauth2.resourceserver.jwt.issuer-uri = #OpenID Connect Provider声明为其颁发者标识符的URI。</span><br></pre></td></tr></table></figure>
<h2 id="DATA-PROPERTIES"><a href="#DATA-PROPERTIES" class="headerlink" title="DATA PROPERTIES"></a>DATA PROPERTIES</h2><h3 id="FLYWAY-（FlywayProperties）"><a href="#FLYWAY-（FlywayProperties）" class="headerlink" title="FLYWAY （FlywayProperties）"></a>FLYWAY （FlywayProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">spring.flyway.baseline-description = &lt;&lt; Flyway Baseline &gt;&gt; ＃描述在应用基线时标记现有模式。</span><br><span class="line">spring.flyway.baseline-on-migrate = false ＃是否在迁移非空架构时自动调用基线。</span><br><span class="line">spring.flyway.baseline-version = 1 ＃用于在执行基线时标记现有模式的版本。</span><br><span class="line">spring.flyway.check-location = true ＃是否检查迁移脚本位置是否存在。</span><br><span class="line">spring.flyway.clean-disabled = false ＃是否禁用数据库清理。</span><br><span class="line">spring.flyway.clean-on-validation-error = false＃发生验证错误时是否自动调用clean。</span><br><span class="line">spring.flyway.connect-retries = 0 ＃尝试连接数据库时的最大重试次数。</span><br><span class="line">spring.flyway.enabled = true ＃是否启用flyway。</span><br><span class="line">spring.flyway.encoding = UTF-8 #SQL 迁移的编码。</span><br><span class="line">spring.flyway.group = false ＃是否在应用它们时在同一事务中将所有挂起的迁移组合在一起。</span><br><span class="line">spring.flyway.ignore-future-migrations = true ＃在读取架构历史记录表时是否忽略未来的迁移。</span><br><span class="line">spring.flyway.ignore-ignored-migrations = false＃是否在读取模式历史记录表时忽略忽略的迁移。</span><br><span class="line">spring.flyway.ignore-missing-migrations = false ＃是否在读取模式历史记录表时忽略缺少的迁移。</span><br><span class="line">spring.flyway.ignore-pending-migrations = false ＃在读取架构历史记录表时是否忽略挂起的迁移。</span><br><span class="line">spring.flyway.init-sqls = ＃在获取连接后立即执行以初始化连接的SQL语句。</span><br><span class="line">spring.flyway.installed-by = ＃用户名在架构历史记录表中记录为已应用迁移。</span><br><span class="line">spring.flyway.locations = classpath：db / migration＃迁移脚本的位置。可以包含特殊的“&#123;vendor&#125;”占位符以使用特定于供应商的位置。</span><br><span class="line">spring.flyway.mixed = false ＃是否允许在同一迁移中混合事务和非事务语句。</span><br><span class="line">spring.flyway.out-of-order = false ＃是否允许迁移无序运行。</span><br><span class="line">spring.flyway.password = ＃要迁移的数据库的登录密码。</span><br><span class="line">spring.flyway.placeholder-prefix = $ &#123; ＃迁移脚本中占位符的前缀。</span><br><span class="line">spring.flyway.placeholder-replacement = true ＃在迁移脚本中执行占位符替换。</span><br><span class="line">spring.flyway.placeholder-suffix =&#125;＃迁移脚本中占位符的后缀。</span><br><span class="line">spring.flyway.placeholders = ＃占位符及其替换应用于sql迁移脚本。</span><br><span class="line">spring.flyway.repeatable-sql-migration-prefix = R ＃可重复SQL迁移的文件名前缀。</span><br><span class="line">spring.flyway.schemas = ＃由Flyway 管理的方案名称（区分大小写）。</span><br><span class="line">spring.flyway.skip-default-callbacks = false ＃是否跳过默认回调。如果为true，则仅使用自定义回调。</span><br><span class="line">spring.flyway.skip-default-resolvers = false ＃是否跳过默认的解析器。如果为true，则仅使用自定义解析程序。</span><br><span class="line">spring.flyway.sql-migration-prefix = V.#SQL迁移的文件名前缀。</span><br><span class="line">spring.flyway.sql-migration-separator = __ #SQL迁移的文件名分隔符。</span><br><span class="line">spring.flyway.sql-migration-suffixes = .sql #SQL迁移的文件名后缀。</span><br><span class="line">spring.flyway.table = flyway_schema_history ＃将由 Flyway 使用的架构架构历史记录表的名称。</span><br><span class="line">spring.flyway.target = ＃应考虑迁移的目标版本。</span><br><span class="line">spring.flyway.url = 要迁移的数据库的JDBC url。如果未设置，则使用主要配置的数据源。</span><br><span class="line">spring.flyway.user = ＃要迁移的数据库的登录用户。</span><br><span class="line">spring.flyway.validate-on-migrate = true ＃是否在执行迁移时自动调用validate。</span><br></pre></td></tr></table></figure>
<h3 id="LIQUIBASE（LiquibaseProperties）"><a href="#LIQUIBASE（LiquibaseProperties）" class="headerlink" title="LIQUIBASE（LiquibaseProperties）"></a>LIQUIBASE（LiquibaseProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring.liquibase.change-log = classpath：/db/changelog/db.changelog-master.yaml# 更改日志配置路径。</span><br><span class="line">spring.liquibase.check-change-log-location = true ＃是否检查更改日志位置是否存在。</span><br><span class="line">spring.liquibase.contexts = ＃逗号分隔的运行时上下文列表。</span><br><span class="line">spring.liquibase.database-change-log-lock-table = DATABASECHANGELOGLOCK ＃用于跟踪并发Liquibase用法的表的名称。</span><br><span class="line">spring.liquibase.database-change-log-table = DATABASECHANGELOG ＃用于跟踪更改历史记录的表的名称。</span><br><span class="line">spring.liquibase.default-model= ＃默认数据库架构。</span><br><span class="line">spring.liquibase.drop-first = false ＃是否首先删除数据库模式。</span><br><span class="line">spring.liquibase.enabled = true ＃是否启用Liquibase支持。</span><br><span class="line">spring.liquibase.labels = ＃逗号分隔的运行时标签列表。</span><br><span class="line">spring.liquibase.liquibase-schema = #Schema用于Liquibase对象。</span><br><span class="line">spring.liquibase.liquibase-tablespace = ＃用于Liquibase对象的表空间。</span><br><span class="line">spring.liquibase.parameters。* = ＃更改日志参数。</span><br><span class="line">spring.liquibase.password = ＃要迁移的数据库的登录密码。</span><br><span class="line">spring.liquibase.rollback-file = ＃执行更新时写入回滚SQL的文件。</span><br><span class="line">spring.liquibase.test-rollback-on-update = false ＃是否应在执行更新之前测试回滚。</span><br><span class="line">spring.liquibase.url = ＃JDBC要迁移的数据库的URL。如果未设置，则使用主要配置的数据源。</span><br><span class="line">spring.liquibase.user = ＃要迁移的数据库的登录用户。</span><br></pre></td></tr></table></figure>
<h3 id="COUCHBASE（CouchbaseProperties）"><a href="#COUCHBASE（CouchbaseProperties）" class="headerlink" title="COUCHBASE（CouchbaseProperties）"></a>COUCHBASE（CouchbaseProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring.couchbase.bootstrap-hosts = #Couchbase 节点（主机或IP地址）来自引导程序。</span><br><span class="line">spring.couchbase.bucket.name = default ＃要连接的存储桶的名称。</span><br><span class="line">spring.couchbase.bucket.password =   ＃桶的密码。</span><br><span class="line">spring.couchbase.env.endpoints.key-value = 1 ＃针对键/值服务的每个节点的套接字数。</span><br><span class="line">spring.couchbase.env.endpoints.queryservice.min-endpoints = 1 ＃每个节点的最小套接字数。</span><br><span class="line">spring.couchbase.env.endpoints.queryservice.max-endpoints = 1 ＃每个节点的最大套接字数。</span><br><span class="line">spring.couchbase.env.endpoints.viewservice.min-endpoints = 1 ＃每个节点的最小套接字数。</span><br><span class="line">spring.couchbase.env.endpoints.viewservice.max-endpoints = 1 ＃每个节点的最大套接字数。</span><br><span class="line">spring.couchbase.env.ssl.enabled = ＃是否启用SSL支持。除非另有说明，否则在提供“keyStore”时自动启用。</span><br><span class="line">spring.couchbase.env.ssl.key-store = ＃保存证书的JVM密钥库的路径。</span><br><span class="line">spring.couchbase.env.ssl.key-store-password = ＃用于访问密钥库的密码。</span><br><span class="line">spring.couchbase.env.timeouts.connect = 5000ms ＃桶连接超时。</span><br><span class="line">spring.couchbase.env.timeouts.key-value = 2500ms ＃对特定密钥超时执行的阻止操作。</span><br><span class="line">spring.couchbase.env.timeouts.query = 7500ms ＃N1QL查询操作超时。</span><br><span class="line">spring.couchbase.env.timeouts.socket-connect = 1000ms #Socket 连接超时。</span><br><span class="line">spring.couchbase.env.timeouts.view = 7500ms ＃常规和地理空间视图操作超时。</span><br></pre></td></tr></table></figure>
<h3 id="DAO-（PersistenceExceptionTranslationAutoConfiguration）"><a href="#DAO-（PersistenceExceptionTranslationAutoConfiguration）" class="headerlink" title="DAO （PersistenceExceptionTranslationAutoConfiguration）"></a>DAO （PersistenceExceptionTranslationAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.dao.exceptiontranslation.enabled = true ＃是否启用PersistenceExceptionTranslationPostProcessor。</span><br></pre></td></tr></table></figure>
<h3 id="CASSANDRA-（CassandraProperties）"><a href="#CASSANDRA-（CassandraProperties）" class="headerlink" title="CASSANDRA （CassandraProperties）"></a>CASSANDRA （CassandraProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring.data.cassandra.cluster-name = #Cassandra 集群的名称。</span><br><span class="line">spring.data.cassandra.compression = none ＃Cassandra二进制协议支持的压缩。</span><br><span class="line">spring.data.cassandra.connect-timeout = #Socket 选项：连接超时。</span><br><span class="line">spring.data.cassandra.consistency-level = ＃查询一致性级别。</span><br><span class="line">spring.data.cassandra.contact-points = localhost ＃群集节点地址。</span><br><span class="line">spring.data.cassandra.fetch-size = ＃查询默认提取大小。</span><br><span class="line">spring.data.cassandra.jmx-enabled = false＃是否启用JMX报告。</span><br><span class="line">spring.data.cassandra.keyspace-name = ＃要使用的Keyspace名称。</span><br><span class="line">spring.data.cassandra.port = #Cassandra 服务器的端口。</span><br><span class="line">spring.data.cassandra.password = ＃服务器的登录密码。</span><br><span class="line">spring.data.cassandra.pool.heartbeat-interval = 30s #Heartbeat interval，在此之后，在空闲连接上发送消息以确保它仍然存在。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.data.cassandra.pool.idle-timeout = 120s ＃删除空闲连接之前的空闲超时。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.data.cassandra.pool.max队列大小= 256 ＃如果没有可用连接，则排队的最大请求数。</span><br><span class="line">spring.data.cassandra.pool.pool-timeout = 5000ms ＃尝试从主机池获取连接时的池超时。</span><br><span class="line">spring.data.cassandra.read-timeout = #Socket 选项：读取超时。</span><br><span class="line">spring.data.cassandra.repositories.type = auto ＃要启用的Cassandra存储库的类型。</span><br><span class="line">spring.data.cassandra.serial-consistency-level = ＃查询串行一致性级别。</span><br><span class="line">spring.data.cassandra.schema-action = none ＃启动时要采取的架构操作。</span><br><span class="line">spring.data.cassandra.ssl = false ＃启用SSL支持。</span><br><span class="line">spring.data.cassandra.username = ＃服务器的登录用户。</span><br></pre></td></tr></table></figure>
<h3 id="DATA-COUCHBASE（CouchbaseDataProperties）"><a href="#DATA-COUCHBASE（CouchbaseDataProperties）" class="headerlink" title="DATA COUCHBASE（CouchbaseDataProperties）"></a>DATA COUCHBASE（CouchbaseDataProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.data.couchbase.auto-index = false ＃自动创建视图和索引。</span><br><span class="line">spring.data.couchbase.consistency = read-your-own-writes ＃在生成的查询中默认应用的一致性。</span><br><span class="line">spring.data.couchbase.repositories.type = auto ＃要启用的Couchbase存储库的类型。</span><br></pre></td></tr></table></figure>
<h3 id="ELASTICSEARCH（ElasticsearchProperties）"><a href="#ELASTICSEARCH（ElasticsearchProperties）" class="headerlink" title="ELASTICSEARCH（ElasticsearchProperties）"></a>ELASTICSEARCH（ElasticsearchProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.data.elasticsearch.cluster-name = elasticsearch ＃Elasticsearch集群名称。</span><br><span class="line">spring.data.elasticsearch.cluster-nodes = ＃逗号分隔的集群节点地址列表。</span><br><span class="line">spring.data.elasticsearch.properties。* = ＃用于配置客户端的其他属性。</span><br><span class="line">spring.data.elasticsearch.repositories.enabled = true ＃是否启用Elasticsearch存储库。</span><br></pre></td></tr></table></figure>
<h3 id="DATA-JDBC"><a href="#DATA-JDBC" class="headerlink" title="DATA JDBC"></a>DATA JDBC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.jdbc.repositories.enabled = true ＃是否启用JDBC存储库。</span><br></pre></td></tr></table></figure>
<h3 id="DATA-LDAP"><a href="#DATA-LDAP" class="headerlink" title="DATA LDAP"></a>DATA LDAP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.ldap.repositories.enabled = true ＃是否启用LDAP存储库。</span><br></pre></td></tr></table></figure>
<h3 id="MONGODB（MongoProperties）"><a href="#MONGODB（MongoProperties）" class="headerlink" title="MONGODB（MongoProperties）"></a>MONGODB（MongoProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.authentication-database = ＃认证数据库名称。</span><br><span class="line">spring.data.mongodb.database = ＃数据库名称。</span><br><span class="line">spring.data.mongodb.field-naming-strategy = ＃要使用的FieldNamingStrategy的完全限定名称。</span><br><span class="line">spring.data.mongodb.grid-fs-database = ＃GridFS数据库名称。</span><br><span class="line">spring.data.mongodb.host = #Mongo 服务器主机。无法使用URI设置。</span><br><span class="line">spring.data.mongodb.password = #mongo 服务器的登录密码。无法使用URI设置。</span><br><span class="line">spring.data.mongodb.port = #Mongo 服务器端口。无法使用URI设置。</span><br><span class="line">spring.data.mongodb.repositories.type = auto ＃要启用的Mongo存储库的类型。</span><br><span class="line">spring.data.mongodb.uri = mongodb：// localhost / test ＃Mongo数据库URI。无法使用主机，端口和凭据进行设置。</span><br><span class="line">spring.data.mongodb.username = #mongo 服务器的登录用户。无法使用URI设置。</span><br></pre></td></tr></table></figure>
<h3 id="DATA-REDIS"><a href="#DATA-REDIS" class="headerlink" title="DATA REDIS"></a>DATA REDIS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.redis.repositories.enabled = true ＃是否启用Redis存储库。</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br></pre></td><td class="code"><pre><span class="line">#NEO4J（Neo4jProperties）</span><br><span class="line">spring.data.neo4j.auto-index = none ＃自动索引模式。</span><br><span class="line">spring.data.neo4j.embedded.enabled = true ＃如果嵌入式驱动程序可用，是否启用嵌入模式。</span><br><span class="line">spring.data.neo4j.open-in-view = true ＃注册OpenSessionInViewInterceptor。将Neo4j会话绑定到线程以进行整个请求处理。</span><br><span class="line">spring.data.neo4j.password = ＃服务器的登录密码。</span><br><span class="line">spring.data.neo4j.repositories.enabled = true ＃是否启用Neo4j存储库。</span><br><span class="line">spring.data.neo4j.uri = 驱动程序使用的#URL 。默认情况下自动检测。</span><br><span class="line">spring.data.neo4j.username = ＃服务器的登录用户。</span><br><span class="line"></span><br><span class="line">#DATA REST（RepositoryRestProperties）</span><br><span class="line">spring.data.rest.base-path = #Spring Data REST用于公开存储库资源的基本路径。</span><br><span class="line">spring.data.rest.default-media-type = ＃未指定时用作默认值的内容类型。</span><br><span class="line">spring.data.rest.default-page-size = ＃默认页面大小。</span><br><span class="line">spring.data.rest.detection-strategy = default ＃用于确定暴露哪些存储库的策略。</span><br><span class="line">spring.data.rest.enable-enum-translation = ＃是否通过Spring Data REST默认资源包启用枚举值转换。</span><br><span class="line">spring.data.rest.limit-param-name =#URL查询字符串参数的名称，指示一次返回多少结果。</span><br><span class="line">spring.data.rest.max-page-size = ＃最大页面大小。</span><br><span class="line">spring.data.rest.page-param-name = #URL 查询字符串参数的名称，指示要返回的页面。</span><br><span class="line">spring.data.rest.return-body-on-create = ＃是否在创建实体后返回响应正文。</span><br><span class="line">spring.data.rest.return-body-on-update = ＃更新实体后是否返回响应正文。</span><br><span class="line">spring.data.rest.sort-param-name = #URL 查询字符串参数的名称，指示对结果进行排序的方向。</span><br><span class="line"></span><br><span class="line">#SOLR （SolrProperties）</span><br><span class="line">spring.data.solr.host = http：//127.0.0.1：8983 / solr #Solr host。如果设置了“zk-host”，则忽略。</span><br><span class="line">spring.data.solr.repositories.enabled = true ＃是否启用Solr存储库。</span><br><span class="line">spring.data.solr.zk-host = ＃ZooKeeper主机地址，格式为HOST：PORT。</span><br><span class="line"></span><br><span class="line">#DATA WEB（SpringDataWebProperties）</span><br><span class="line">spring.data.web.pageable.default页大小 = 20 ＃缺省页大小。</span><br><span class="line">spring.data.web.pageable.max-page-size = 2000 ＃要接受的最大页面大小。</span><br><span class="line">spring.data.web.pageable.one-indexed-parameters = false ＃是否公开和假设从1开始的页码索引。</span><br><span class="line">spring.data.web.pageable.page-parameter = page ＃页面索引参数名称。</span><br><span class="line">spring.data.web.pageable.prefix = ＃常用前缀，用于页码和页面大小参数。</span><br><span class="line">spring.data.web.pageable.qualifier-delimiter = _＃限定符与实际页码和大小属性之间使用的分隔符。</span><br><span class="line">spring.data.web.pageable.size-parameter = size ＃页面大小参数名称。</span><br><span class="line">spring.data.web.sort.sort-parameter = sort ＃排序参数名称。</span><br><span class="line"></span><br><span class="line">#DATASOURCE （DataSourceAutoConfiguration＆DataSourceProperties）</span><br><span class="line">spring.datasource.continue-on-error = false ＃初始化数据库时是否发生错误时停止。</span><br><span class="line">spring.datasource.data = #Data （DML）脚本资源引用。</span><br><span class="line">spring.datasource.data-username = ＃用于执行DML脚本的数据库的用户名（如果不同）。</span><br><span class="line">spring.datasource.data-password = ＃执行DML脚本的数据库的密码（如果不同）。</span><br><span class="line">spring.datasource.dbcp2。* = ＃Commons DBCP2特定设置</span><br><span class="line">spring.datasource.driver-class-name =#JDBC驱动程序的完全限定名称。默认情况下，基于URL自动检测。</span><br><span class="line">spring.datasource.generate-unique-name = false ＃是否生成随机数据源名称。</span><br><span class="line">spring.datasource.hikari。* = ＃Hikari特定设置</span><br><span class="line">spring.datasource.initialization-mode = embedded ＃使用可用的DDL和DML脚本初始化数据源。</span><br><span class="line">spring.datasource.jmx-enabled = false ＃是否启用JMX支持（如果由基础池提供）。</span><br><span class="line">spring.datasource.jndi-name = ＃JNDI数据源的位置。设置时将忽略类，URL，用户名和密码。</span><br><span class="line">spring.datasource.name =＃数据源的名称。使用嵌入式数据库时默认为“testdb”。</span><br><span class="line">spring.datasource.password = ＃数据库的登录密码。</span><br><span class="line">spring.datasource.platform = all ＃在DDL或DML脚本中使用的平台（例如架构 -  $ &#123;platform&#125; .sql或data  -  $ &#123;platform&#125; .sql）。</span><br><span class="line">spring.datasource.schema = #Schema （DDL）脚本资源引用。</span><br><span class="line">spring.datasource.schema-username = ＃执行DDL脚本的数据库的用户名（如果不同）。</span><br><span class="line">spring.datasource.schema-password = ＃执行DDL脚本的数据库的密码（如果不同）。</span><br><span class="line">spring.datasource.separator =;#SQL初始化脚本中的语句分隔符。</span><br><span class="line">spring.datasource.sql-script-encoding = #SQL 脚本编码。</span><br><span class="line">spring.datasource.tomcat。* = ＃Tomcat数据源特定设置</span><br><span class="line">spring.datasource.type = ＃要使用的连接池实现的完全限定名称。默认情况下，它是从类路径中自动检测到的。</span><br><span class="line">spring.datasource.url = ＃JDBC数据库的URL。</span><br><span class="line">spring.datasource.username = ＃登录数据库的用户名。</span><br><span class="line">spring.datasource.xa.data-source-class-name = #XA 数据源完全限定名称。</span><br><span class="line">spring.datasource.xa.properties =＃传递给XA数据源的属性。</span><br><span class="line"></span><br><span class="line">#JEST （Elasticsearch HTTP客户端）（JestProperties）</span><br><span class="line">spring.elasticsearch.jest.connection-timeout = 3s ＃连接超时。</span><br><span class="line">spring.elasticsearch.jest.multi-threaded = true ＃是否从多个执行线程启用连接请求。</span><br><span class="line">spring.elasticsearch.jest.password = ＃登录密码。</span><br><span class="line">spring.elasticsearch.jest.proxy.host = #HTTP 客户端应使用的代理主机。</span><br><span class="line">spring.elasticsearch.jest.proxy.port = #HTTP 客户端应使用的代理端口。</span><br><span class="line">spring.elasticsearch.jest.read-timeout = 3s ＃读取超时。</span><br><span class="line">spring.elasticsearch.jest.uris = http：// localhost：9200＃逗号分隔的Elasticsearch实例列表。</span><br><span class="line">spring.elasticsearch.jest.username = ＃登录用户名。</span><br><span class="line"></span><br><span class="line">#Elasticsearch REST客户端（RestClientProperties）</span><br><span class="line">spring.elasticsearch.rest.password = ＃凭据密码。</span><br><span class="line">spring.elasticsearch.rest.uris = http：// localhost：9200 ＃要使用的以逗号分隔的Elasticsearch实例列表。</span><br><span class="line">spring.elasticsearch.rest.username = ＃凭据用户名。</span><br><span class="line"></span><br><span class="line">#H2 Web控制台（H2ConsoleProperties）</span><br><span class="line">spring.h2.console.enabled = false ＃是否启用控制台。</span><br><span class="line">spring.h2.console.path = / h2-console ＃控制台可用的路径。</span><br><span class="line">spring.h2.console.settings.trace = false ＃是否启用跟踪输出。</span><br><span class="line">spring.h2.console.settings.web-allow-others = false ＃是否启用远程访问。</span><br><span class="line"></span><br><span class="line">#InfluxDB（InfluxDbProperties）</span><br><span class="line">spring.influx.password = ＃登录密码。</span><br><span class="line">spring.influx.url = 要连接的InfluxDB实例的URL。</span><br><span class="line">spring.influx.user = ＃登录用户。</span><br><span class="line"></span><br><span class="line">#JOOQ （JooqProperties）</span><br><span class="line">spring.jooq.sql-dialect = #SQL 方言使用。默认情况下自动检测。</span><br><span class="line"></span><br><span class="line">#JDBC （JdbcProperties）</span><br><span class="line">spring.jdbc.template.fetch-size = -1 ＃需要更多行时应从数据库中提取的行数。</span><br><span class="line">spring.jdbc.template.max-rows = -1 ＃最大行数。</span><br><span class="line">spring.jdbc.template.query-timeout = ＃查询超时。默认是使用JDBC驱动程序的默认配置。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line"></span><br><span class="line">＃JPA （JpaBaseConfiguration，HibernateJpaAutoConfiguration）</span><br><span class="line">spring.data.jpa.repositories.bootstrap-mode = default #JAPA 存储库的Bootstrap模式。</span><br><span class="line">spring.data.jpa.repositories.enabled = true ＃是否启用JPA存储库。</span><br><span class="line">spring.jpa.database = ＃要操作的目标数据库，默认情况下自动检测。也可以使用“databasePlatform”属性进行设置。</span><br><span class="line">spring.jpa.database-platform = ＃要操作的目标数据库的名称，默认情况下自动检测。也可以使用“Database”枚举来设置。</span><br><span class="line">spring.jpa.generate-ddl = false ＃是否在启动时初始化架构。</span><br><span class="line">spring.jpa.hibernate.ddl-auto = ＃DDL模式。这实际上是“hibernate.hbm2ddl.auto”属性的快捷方式。使用嵌入式数据库时未默认为“create-drop”，并且未检测到架构管理器。否则，默认为“none”。</span><br><span class="line">spring.jpa.hibernate.naming.implicit-strategy = ＃隐式命名策略的完全限定名称。</span><br><span class="line">spring.jpa.hibernate.naming.physical-strategy = ＃物理命名策略的完全限定名称。</span><br><span class="line">spring.jpa.hibernate.use-new-id-generator-mappings = ＃是否将Hibernate的较新的IdentifierGenerator用于AUTO，TABLE和SEQUENCE。</span><br><span class="line">spring.jpa.mapping-resources =＃Mapping资源（相当于persistence.xml中的“mapping-file”条目）。</span><br><span class="line">spring.jpa.open-in-view = true ＃注册OpenEntityManagerInViewInterceptor。将JPA EntityManager绑定到线程以进行整个请求处理。</span><br><span class="line">spring.jpa.properties。* = ＃要在JPA提供程序上设置的其他本机属性。</span><br><span class="line">spring.jpa.show -sql = false ＃是否启用SQL语句的日志记录。</span><br><span class="line"></span><br><span class="line">#JTA （JtaAutoConfiguration）</span><br><span class="line">spring.jta.enabled = true ＃是否启用JTA支持。</span><br><span class="line">spring.jta.log-dir = #Transaction logs目录。</span><br><span class="line">spring.jta.transaction-manager-id = #Transaction manager唯一标识符。</span><br><span class="line"></span><br><span class="line">#ATOMIKOS（AtomikosProperties）</span><br><span class="line">spring.jta.atomikos.connectionfactory.borrow-connection-timeout = 30 ＃从池中借用连接的超时（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag = true ＃是否在创建会话时忽略事务处理标志。</span><br><span class="line">spring.jta.atomikos.connectionfactory.local-transaction-mode = false ＃是否需要本地事务。</span><br><span class="line">spring.jta.atomikos.connectionfactory.maintenance-interval = 60 ＃池维护线程运行之间的时间（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.connectionfactory.max-idle-time = 60＃从池中清除连接的时间（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.connectionfactory.max-lifetime = 0 ＃连接在被销毁之前可以合并的时间（以秒为单位）。0表示没有限制。</span><br><span class="line">spring.jta.atomikos.connectionfactory.max-pool-size = 1 ＃池的最大大小。</span><br><span class="line">spring.jta.atomikos.connectionfactory.min-pool-size = 1 ＃池的最小大小。</span><br><span class="line">spring.jta.atomikos.connectionfactory.reap-timeout = 0 ＃借用连接的reap超时（以秒为单位）。0表示没有限制。</span><br><span class="line">spring.jta.atomikos.connectionfactory.unique-resource-name = jmsConnectionFactory＃用于在恢复期间标识资源的唯一名称。</span><br><span class="line">spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name = #XAConnectionFactory的供应商特定实现。</span><br><span class="line">spring.jta.atomikos.connectionfactory.xa-properties = ＃供应商特定的XA属性。</span><br><span class="line">spring.jta.atomikos.datasource.borrow-connection-timeout = 30 ＃从池中借用连接的超时时间（秒）。</span><br><span class="line">spring.jta.atomikos.datasource.concurrent-connection-validation = ＃是否使用并发连接验证。</span><br><span class="line">spring.jta.atomikos.datasource.default-isolation-level = ＃池提供的连接的默认隔离级别。</span><br><span class="line">spring.jta.atomikos.datasource.login-timeout = ＃用于建立数据库连接的超时（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.datasource.maintenance-interval = 60 ＃池维护线程运行之间的时间（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.datasource.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.datasource.max-lifetime = 0 ＃连接在被销毁之前可以合并的时间（以秒为单位）。0表示没有限制。</span><br><span class="line">spring.jta.atomikos.datasource.max-pool-size = 1 ＃池的最大大小。</span><br><span class="line">spring.jta.atomikos.datasource.min-pool-size = 1＃池的最小大小。</span><br><span class="line">spring.jta.atomikos.datasource.reap-timeout = 0 ＃借用连接的reap超时（以秒为单位）。0表示没有限制。</span><br><span class="line">spring.jta.atomikos.datasource.test-query = ＃用于在返回连接之前验证连接的SQL查询或语句。</span><br><span class="line">spring.jta.atomikos.datasource.unique-resource-name = dataSource ＃用于在恢复期间标识资源的唯一名称。</span><br><span class="line">spring.jta.atomikos.datasource.xa-data-source-class-name = #XAConnectionFactory的供应商特定实现。</span><br><span class="line">spring.jta.atomikos.datasource.xa-properties = ＃供应商特定的XA属性。</span><br><span class="line">spring.jta.atomikos.properties.allow-sub-transactions = true ＃指定是否允许子事务。</span><br><span class="line">spring.jta.atomikos.properties.checkpoint-interval = 500 ＃检查点之间的间隔，表示为两个检查点之间的日志写入次数。</span><br><span class="line">spring.jta.atomikos.properties.default -jta -timeout = 10000ms #JTA 事务的默认超时。</span><br><span class="line">spring.jta.atomikos.properties.default-max-wait-time-on-shutdown = 9223372036854775807 ＃正常关闭（no-force）等待事务完成的时间。</span><br><span class="line">spring.jta.atomikos.properties.enable-logging = true ＃是否启用磁盘日志记录。</span><br><span class="line">spring.jta.atomikos.properties.force-shutdown-on-vm-exit = false ＃虚拟机关闭是否应触发事务核心的强制关闭。</span><br><span class="line">spring.jta.atomikos.properties.log-base-dir = ＃应存储日志文件的目录。</span><br><span class="line">spring.jta.atomikos.properties.log-base-name = tmlog ＃Transactions日志文件基名。</span><br><span class="line">spring.jta.atomikos.properties.max-actives = 50 ＃最大活动事务数。</span><br><span class="line">spring.jta.atomikos.properties.max-timeout = 300000ms ＃事务允许的最大超时时间。</span><br><span class="line">spring.jta.atomikos.properties.recovery.delay = 10000ms ＃两次恢复扫描之间的延迟。</span><br><span class="line">spring.jta.atomikos.properties.recovery.forget- orphaned -log-entries-delay = 86400000ms ＃恢复之后的延迟可以清除挂起（&apos;孤立&apos;）日志条目。</span><br><span class="line">spring.jta.atomikos.properties.recovery.max-retries = 5 ＃在抛出异常之前提交事务的重试次数。</span><br><span class="line">spring.jta.atomikos.properties.recovery.retry-interval = 10000ms ＃重试尝试之间的延迟。</span><br><span class="line">spring.jta.atomikos.properties.serial-jta-transactions = true ＃是否应尽可能加入子事务。</span><br><span class="line">spring.jta.atomikos.properties.service = ＃应该启动的事务管理器实现。</span><br><span class="line">spring.jta.atomikos.properties.threaded-two-phase-commit = false ＃是否对参与资源使用不同（和并发）线程进行两阶段提交。</span><br><span class="line">spring.jta.atomikos.properties.transaction-manager-unique-name = ＃事务管理器的唯一名称。</span><br><span class="line"></span><br><span class="line">#BITRONIX </span><br><span class="line">spring.jta.bitronix.connectionfactory.acquire-increment = 1 ＃在增长池时创建的连接数。</span><br><span class="line">spring.jta.bitronix.connectionfactory.acquisition-interval = 1 ＃获取无效连接后再次尝试获取连接之前等待的时间（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.connectionfactory.acquisition-timeout = 30 ＃从池中获取连接的超时时间（秒）。</span><br><span class="line">spring.jta.bitronix.connectionfactory.allow-local-transactions = true ＃事务管理器是否应该允许混合XA和非XA事务。</span><br><span class="line">spring.jta.bitronix.connectionfactory.apply-transaction-timeout = false＃是否应在登记时在XAResource上设置事务超时。</span><br><span class="line">spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled = true ＃是否应自动登记和退出资源。</span><br><span class="line">spring.jta.bitronix.connectionfactory.cache-producer-consumers = true ＃是否应该缓存生产者和消费者。</span><br><span class="line">spring.jta.bitronix.connectionfactory.class-name = #XA 资源的底层实现类名。</span><br><span class="line">spring.jta.bitronix.connectionfactory.defer-connection-release = true ＃提供程序是否可以在同一连接上运行多个事务并支持事务交错。</span><br><span class="line">spring.jta.bitronix.connectionfactory.disabled= ＃是否禁用此资源，这意味着暂时禁止从其池中获取连接。</span><br><span class="line">spring.jta.bitronix.connectionfactory.driver-properties = ＃应在底层实现上设置的属性。</span><br><span class="line">spring.jta.bitronix.connectionfactory.failed = ＃将此资源生成器标记为失败。</span><br><span class="line">spring.jta.bitronix.connectionfactory.ignore-recovery-failures = false ＃是否应忽略恢复失败。</span><br><span class="line">spring.jta.bitronix.connectionfactory.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.connectionfactory.max-pool-size = 10＃池的最大大小。0表示没有限制。</span><br><span class="line">spring.jta.bitronix.connectionfactory.min-pool-size = 0 ＃池的最小大小。</span><br><span class="line">spring.jta.bitronix.connectionfactory.password = ＃用于连接JMS提供程序的密码。</span><br><span class="line">spring.jta.bitronix.connectionfactory.share-transaction-connections = false ＃是否可以在事务上下文中共享处于ACCESSIBLE状态的连接。</span><br><span class="line">spring.jta.bitronix.connectionfactory.test-connections = true ＃从池中获取时是否应测试连接。</span><br><span class="line">spring.jta.bitronix.connectionfactory.two-pc-ordering-position = 1＃在两阶段提交期间此资源应采取的位置（始终是第一个是Integer.MIN_VALUE，总是最后一个是Integer.MAX_VALUE）。</span><br><span class="line">spring.jta.bitronix.connectionfactory.unique-name = jmsConnectionFactory ＃用于在恢复期间标识资源的唯一名称。</span><br><span class="line">spring.jta.bitronix.connectionfactory.use -tm -join = true ＃启动XAResources时是否应该使用TMJOIN。spring.jta.bitronix.connectionfactory.user = ＃用于连接到JMS提供程序的用户。</span><br><span class="line">spring.jta.bitronix.datasource.acquire-increment = 1 ＃在增长池时创建的连接数。</span><br><span class="line">spring.jta.bitronix.datasource.acquisition-interval = 1＃在获取无效连接后再次尝试获取连接之前等待的时间（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.datasource.acquisition-timeout = 30 ＃从池中获取连接的超时时间（秒）。</span><br><span class="line">spring.jta.bitronix.datasource.allow-local-transactions = true ＃事务管理器是否应该允许混合XA和非XA事务。</span><br><span class="line">spring.jta.bitronix.datasource.apply-transaction-timeout = false ＃是否应在XAResource登记时设置事务超时。</span><br><span class="line">spring.jta.bitronix.datasource.automatic-enlisting-enabled = true ＃是否应自动登记和退出资源。</span><br><span class="line">spring.jta.bitronix.datasource.class-name = #XA 资源的底层实现类名。</span><br><span class="line">spring.jta.bitronix.datasource.cursor-holdability = ＃连接的默认光标可保持性。</span><br><span class="line">spring.jta.bitronix.datasource.defer-connection-release = true ＃数据库是否可以在同一连接上运行多个事务并支持事务交错。</span><br><span class="line">spring.jta.bitronix.datasource.disabled = ＃是否禁用此资源，这意味着暂时禁止从其池中获取连接。</span><br><span class="line">spring.jta.bitronix.datasource.driver-properties = ＃应在底层实现上设置的属性。</span><br><span class="line">spring.jta.bitronix.datasource.enable -jdbc4-connection-test = ＃从池中获取连接时是否调用Connection.isValid（）。</span><br><span class="line">spring.jta.bitronix.datasource.failed = ＃将此资源生成器标记为失败。</span><br><span class="line">spring.jta.bitronix.datasource.ignore-recovery-failures = false ＃是否应忽略恢复失败。</span><br><span class="line">spring.jta.bitronix.datasource.isolation-level = ＃连接的默认隔离级别。</span><br><span class="line">spring.jta.bitronix.datasource.local-auto-commit = ＃本地事务的默认自动提交模式。</span><br><span class="line">spring.jta.bitronix.datasource.login-timeout =＃建立数据库连接的超时时间（秒）。</span><br><span class="line">spring.jta.bitronix.datasource.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.datasource.max-pool-size = 10 ＃池的最大大小。0表示没有限制。</span><br><span class="line">spring.jta.bitronix.datasource.min-pool-size = 0 ＃池的最小大小。</span><br><span class="line">spring.jta.bitronix.datasource.prepared-statement-cache-size = 0 ＃预准备语句缓存的目标大小。0禁用缓存。</span><br><span class="line">spring.jta.bitronix.datasource.share-transaction-connections = false＃是否可以在事务上下文中共享处于ACCESSIBLE状态的连接。</span><br><span class="line">spring.jta.bitronix.datasource.test-query = ＃用于在返回连接之前验证连接的SQL查询或语句。</span><br><span class="line">spring.jta.bitronix.datasource.two-pc-ordering-position = 1 ＃此资源在两阶段提交期间应采取的位置（始终首先是Integer.MIN_VALUE，并且始终是最后一个是Integer.MAX_VALUE）。</span><br><span class="line">spring.jta.bitronix.datasource.unique-name = dataSource ＃用于在恢复期间标识资源的唯一名称。</span><br><span class="line">spring.jta.bitronix.datasource.use -tm -join = true ＃启动XAResources时是否应该使用TMJOIN。</span><br><span class="line">spring.jta.bitronix.properties.allow-multiple-lrc = false ＃是否允许多个LRC资源登记到同一事务中。</span><br><span class="line">spring.jta.bitronix.properties.asynchronous2-pc = false ＃是否启用异步执行两阶段提交。</span><br><span class="line">spring.jta.bitronix.properties.background-recovery-interval-seconds = 60 ＃在后台运行恢复过程的时间间隔（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.properties.current-node-only-recovery = true ＃是否仅恢复当前节点。</span><br><span class="line">spring.jta.bitronix.properties.debug-zero-resource-transaction = false＃是否记录创建和提交没有单个登记资源的事务调用堆栈。</span><br><span class="line">spring.jta.bitronix.properties.default-transaction-timeout = 60 ＃默认事务超时，以秒为单位。</span><br><span class="line">spring.jta.bitronix.properties.disable-jmx = false ＃是否启用JMX支持。</span><br><span class="line">spring.jta.bitronix.properties.exception-analyzer = ＃设置要使用的异常分析器实现的完全限定名称。</span><br><span class="line">spring.jta.bitronix.properties.filter-log-status = false ＃是否启用日志过滤，以便只写入强制日志。</span><br><span class="line">spring.jta.bitronix.properties.force-batching-enabled = true＃是否批量磁盘强制。</span><br><span class="line">spring.jta.bitronix.properties.forced-write-enabled = true ＃是否强制将日志记录到磁盘。</span><br><span class="line">spring.jta.bitronix.properties.graceful-shutdown-interval = 60 ＃TM在关闭时中止事务之前等待事务完成的最大秒数。</span><br><span class="line">spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name = ＃TransactionSynchronizationRegistry的JNDI名称。</span><br><span class="line">spring.jta.bitronix.properties.jndi-user-transaction-name = ＃UserTransaction的JNDI名称。</span><br><span class="line">spring.jta.bitronix.properties.journal = disk ＃期刊的名称。可以是&apos;disk&apos;，&apos;null&apos;或类名。</span><br><span class="line">spring.jta.bitronix.properties.log-part1-filename = btm1.tlog ＃日志的第一个片段的名称。</span><br><span class="line">spring.jta.bitronix.properties.log-part2-filename = btm2.tlog ＃日志的第二个片段的名称。</span><br><span class="line">spring.jta.bitronix.properties.max-log-size-in-mb = 2 ＃日志片段的最大大小（兆字节）。</span><br><span class="line">spring.jta.bitronix.properties.resource-configuration-filename = ＃ResourceLoader配置文件名。</span><br><span class="line">spring.jta.bitronix.properties.server-id = #ASCII ID必须唯一标识此TM实例。默认为机器的IP地址。</span><br><span class="line">spring.jta.bitronix.properties.skip-corrupted-logs = false#Skip损坏的事务日志条目。</span><br><span class="line">spring.jta.bitronix.properties.warn-about-zero-resource-transaction = true ＃是否为没有单个登记资源的事务记录警告。</span><br><span class="line"></span><br><span class="line">#EMBEDDED MONGODB（EmbeddedMongoProperties）</span><br><span class="line">spring.mongodb.embedded.features = sync_delay ＃逗号分隔的要启用的功能列表。</span><br><span class="line">spring.mongodb.embedded.storage.database-dir = ＃用于数据存储的目录。</span><br><span class="line">spring.mongodb.embedded.storage.oplog-size = #oplog的最大大小。</span><br><span class="line">spring.mongodb.embedded.storage.repl-set-name = ＃副本集的名称。</span><br><span class="line">spring.mongodb.embedded.version = 3.5.5 ＃要使用的Mongo版本。</span><br><span class="line"></span><br><span class="line">#REDIS（RedisProperties）</span><br><span class="line">spring.redis.cluster.max -redirects = ＃在群集中执行命令时要遵循的最大重定向数。</span><br><span class="line">spring.redis.cluster.nodes = ＃逗号分隔的“host：port”对列表引导自。</span><br><span class="line">spring.redis.database = 0 ＃连接工厂使用的数据库索引。</span><br><span class="line">spring.redis.url = ＃连接URL。覆盖主机，端口和密码。用户被忽略。示例：redis：// user：password@example.com ：6379 </span><br><span class="line">spring.redis.host = localhost ＃Redis服务器主机。</span><br><span class="line">spring.redis.jedis.pool.max-active = 8＃池在给定时间可以分配的最大连接数。使用负值无限制。</span><br><span class="line">spring.redis.jedis.pool.max-idle = 8 ＃池中“空闲”连接的最大数量。使用负值表示无限数量的空闲连接。</span><br><span class="line">spring.redis.jedis.pool.max -wait = -1ms ＃在池耗尽时，在抛出异常之前连接分配应该阻塞的最长时间。使用负值无限期阻止。</span><br><span class="line">spring.redis.jedis.pool.min-idle = 0 ＃目标是池中维护的最小空闲连接数。此设置仅在其为正时才有效。</span><br><span class="line">spring.redis.lettuce.pool.max-active = 8＃池在给定时间可以分配的最大连接数。使用负值无限制。</span><br><span class="line">spring.redis.lettuce.pool.max-idle = 8 ＃池中“空闲”连接的最大数量。使用负值表示无限数量的空闲连接。</span><br><span class="line">spring.redis.lettuce.pool.max -wait = -1ms ＃在池耗尽时，在抛出异常之前连接分配应阻塞的最长时间。使用负值无限期阻止。</span><br><span class="line">spring.redis.lettuce.pool.min-idle = 0 ＃目标是池中维护的最小空闲连接数。此设置仅在其为正时才有效。</span><br><span class="line">spring.redis.lettuce.shutdown-timeout = 100ms＃关机超时。</span><br><span class="line">spring.redis.password = ＃redis服务器的登录密码。</span><br><span class="line">spring.redis.port = 6379 #Redis服务器端口。</span><br><span class="line">spring.redis.sentinel.master = #Redis服务器的名称。</span><br><span class="line">spring.redis.sentinel.nodes = ＃逗号分隔的“host：port”对列表。</span><br><span class="line">spring.redis.ssl = false ＃是否启用SSL支持。</span><br><span class="line">spring.redis.timeout = ＃连接超时。</span><br><span class="line"></span><br><span class="line">#TRANSACTION （TransactionProperties）</span><br><span class="line">spring.transaction.default-timeout = ＃默认事务超时。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.transaction.rollback-on-commit-failure = ＃是否回滚提交失败。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">＃---------------------------------------- </span><br><span class="line">＃INTEGRATION PROPERTIES </span><br><span class="line">＃----- -----------------------------------</span><br><span class="line"></span><br><span class="line">#ACTIVEMQ（ActiveMQProperties）</span><br><span class="line">spring.activemq.broker-url = ActiveMQ代理的URL。默认情况下自动生成。</span><br><span class="line">spring.activemq.close-timeout = 15s ＃在考虑结束完成之前等待的时间。</span><br><span class="line">spring.activemq.in-memory = true ＃默认代理URL是否应该在内存中。如果已指定显式代理，则忽略。</span><br><span class="line">spring.activemq.non-blocking-redelivery = false ＃是否在从回滚事务重新传递消息之前停止消息传递。这意味着启用此消息顺序时不会保留消息顺序。</span><br><span class="line">spring.activemq.password = ＃代理的登录密码。</span><br><span class="line">spring.activemq.send-timeout = 0ms ＃等待消息发送响应的时间。将其设置为0以永远等待。</span><br><span class="line">spring.activemq.user = ＃代理的登录用户。</span><br><span class="line">spring.activemq.packages.trust-all = ＃是否信任所有包。</span><br><span class="line">spring.activemq.packages.trusted = ＃逗号分隔的要信任的特定包列表（不信任所有包时）。</span><br><span class="line">spring.activemq.pool.block-if-full = true ＃是否阻止请求连接并且池已满。将其设置为false以改为抛出“JMSException”。</span><br><span class="line">spring.activemq.pool.block-if-full-timeout = -1ms＃如果池仍然满，则在抛出异常之前阻塞。</span><br><span class="line">spring.activemq.pool.enabled = false ＃是否应创建JmsPoolConnectionFactory，而不是常规ConnectionFactory。</span><br><span class="line">spring.activemq.pool.idle-timeout = 30s ＃连接空闲超时。</span><br><span class="line">spring.activemq.pool.max-connections = 1 ＃最大池化连接数。</span><br><span class="line">spring.activemq.pool.max-sessions-per-connection = 500 ＃池中每个连接的最大池化会话数。</span><br><span class="line">spring.activemq.pool.time-between-expiration-check = -1ms ＃在空闲连接驱逐线程的运行之间休眠的时间。当为负时，没有空闲连接驱逐线程运行。</span><br><span class="line">spring.activemq.pool.use-anonymous-producer = true ＃是否只使用一个匿名“MessageProducer”实例。将其设置为false以在每次需要时创建一个“MessageProducer”。</span><br><span class="line"></span><br><span class="line">#ARTEMIS （ArtemisProperties）</span><br><span class="line">spring.artemis.embedded.cluster-password = ＃群集密码。默认情况下在启动时随机生成。</span><br><span class="line">spring.artemis.embedded.data-directory = #Journal 文件目录。如果关闭持久性，则没有必要。</span><br><span class="line">spring.artemis.embedded.enabled = true ＃如果Artemis服务器API可用，是否启用嵌入模式。</span><br><span class="line">spring.artemis.embedded.persistent = false ＃是否启用持久存储。</span><br><span class="line">spring.artemis.embedded.queues = ＃逗号分隔的队列，在启动时创建。</span><br><span class="line">spring.artemis.embedded.server-id =＃服务器ID。默认情况下，使用自动递增的计数器。</span><br><span class="line">spring.artemis.embedded.topics = ＃在启动时要创建的以逗号分隔的主题列表。</span><br><span class="line">spring.artemis.host = localhost ＃Artemis broker主机。</span><br><span class="line">spring.artemis.mode = ＃Artemis部署模式，默认情况下自动检测。</span><br><span class="line">spring.artemis.password = ＃代理的登录密码。</span><br><span class="line">spring.artemis.pool.block-if-full = true ＃是否在请求连接且池已满时阻止。将其设置为false以改为抛出“JMSException”。</span><br><span class="line">spring.artemis.pool.block-if-full-timeout = -1ms ＃如果池仍然满，则在抛出异常之前阻塞。</span><br><span class="line">spring.artemis.pool.enabled = false ＃是否应创建JmsPoolConnectionFactory，而不是常规ConnectionFactory。</span><br><span class="line">spring.artemis.pool.idle-timeout = 30s ＃连接空闲超时。</span><br><span class="line">spring.artemis.pool.max-connections = 1 ＃池化连接的最大数量。</span><br><span class="line">spring.artemis.pool.max-sessions-per-connection = 500 ＃池中每个连接的最大池化会话数。</span><br><span class="line">spring.artemis.pool.time-between-expiration-check = -1ms ＃在空闲连接驱逐线程的运行之间休眠的时间。当为负时，没有空闲连接驱逐线程运行。</span><br><span class="line">spring.artemis.pool.use-anonymous-producers = true＃是否只使用一个匿名“MessageProducer”实例。将其设置为false以在每次需要时创建一个“MessageProducer”。</span><br><span class="line">spring.artemis.port = 61616 #Artemis 经纪人端口。</span><br><span class="line">spring.artemis.user = ＃代理的登录用户。</span><br><span class="line"></span><br><span class="line">#SPRING BATCH（BatchProperties）</span><br><span class="line">spring.batch.initialize-schema = embedded ＃数据库模式初始化模式。</span><br><span class="line">spring.batch.job.enabled = true ＃在启动时执行上下文中的所有Spring Batch作业。</span><br><span class="line">spring.batch.job.names = ＃逗号分隔的要在启动时执行的作业名称列表（例如，`job1，job2`）。默认情况下，将执行上下文中找到的所有作业。</span><br><span class="line">spring.batch.schema = classpath中：组织/ springframework的/批号/核心/ schema- @ @ 平台@ @ .SQL ＃的路径SQL文件，以用于初始化数据库架构。</span><br><span class="line">spring.batch.table-prefix =＃所有批次元数据表的表前缀。</span><br><span class="line"></span><br><span class="line">#SPRING INTEGRATION（IntegrationProperties）</span><br><span class="line">spring.integration.jdbc.initialize-schema = embedded ＃数据库模式初始化模式。</span><br><span class="line">spring.integration.jdbc.schema = classpath中：组织/ springframework的/集成/ JDBC / schema- @ @ 平台@ @ .SQL ＃的路径SQL文件，以用于初始化数据库架构。</span><br><span class="line"></span><br><span class="line">#JMS （JmsProperties）</span><br><span class="line">spring.jms.cache.consumers = false ＃是否缓存消息使用者。</span><br><span class="line">spring.jms.cache.enabled = true ＃是否缓存会话。</span><br><span class="line">spring.jms.cache.producers = true ＃是否缓存消息生成器。</span><br><span class="line">spring.jms.cache.session-cache-size = 1 ＃会话缓存的大小（根据JMS会话类型）。</span><br><span class="line">spring.jms.jndi-name = ＃连接工厂JNDI名称。设置时，优先于其他连接工厂自动配置。</span><br><span class="line">spring.jms.listener.acknowledge-mode = ＃容器的确认模式。默认情况下，侦听器使用自动确认进行事务处理。</span><br><span class="line">spring.jms.listener.auto-startup = true ＃启动时自动启动容器。</span><br><span class="line">spring.jms.listener.concurrency = ＃最小并发使用者数。</span><br><span class="line">spring.jms.listener.max-concurrency = ＃最大并发使用者数。</span><br><span class="line">spring.jms.pub-sub-domain = false ＃默认目标类型是否为topic。</span><br><span class="line">spring.jms.template.default-destination = ＃用于没有目标参数的发送和接收操作的默认目标。</span><br><span class="line">spring.jms.template.delivery-delay = ＃用于发送呼叫的传递延迟。</span><br><span class="line">spring.jms.template.delivery-mode =＃交付模式。设置时启用QoS（服务质量）。</span><br><span class="line">spring.jms.template.priority = ＃发送时消息的优先级。设置时启用QoS（服务质量）。</span><br><span class="line">spring.jms.template.qos-enabled = ＃发送消息时是否启用显式QoS（服务质量）。</span><br><span class="line">spring.jms.template.receive-timeout = ＃用于接收呼叫的超时。</span><br><span class="line">spring.jms.template.time-to-live = ＃发送时消息的生存时间。设置时启用QoS（服务质量）。</span><br><span class="line"></span><br><span class="line">#APACHE KAFKA（KafkaProperties）</span><br><span class="line">spring.kafka.admin.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.admin.fail-fast = false ＃如果代理在启动时不可用，是否快速失败。</span><br><span class="line">spring.kafka.admin.properties。* = ＃用于配置客户端的其他特定于管理员的属性。</span><br><span class="line">spring.kafka.admin.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.admin.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.admin.ssl.key-store-password =＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.admin.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.admin.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.admin.ssl.trust-store-location = ＃信任库文件的位置。</span><br><span class="line">spring.kafka.admin.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.admin.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。除非被覆盖，否则适用于所有组件。</span><br><span class="line">spring.kafka.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.consumer.auto-commit-interval = ＃如果&apos;enable.auto.commit&apos;设置为true，则将消费者偏移自动提交给Kafka的频率。</span><br><span class="line">spring.kafka.consumer.auto-offset-reset = ＃当Kafka中没有初始偏移量或者服务器上不再存在当前偏移量时该怎么办。</span><br><span class="line">spring.kafka.consumer.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。为消费者覆盖全球财产。</span><br><span class="line">spring.kafka.consumer.client-id =#ID在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.consumer.enable-auto-commit = ＃是否在后台定期提交消费者的偏移量。</span><br><span class="line">spring.kafka.consumer.fetch-max-wait = ＃如果没有足够的数据立即满足“fetch-min-size”给出的要求，服务器在回答获取请求之前会阻塞的最长时间。</span><br><span class="line">spring.kafka.consumer.fetch-min-size = ＃服务器应为获取请求返回的最小数据量。</span><br><span class="line">spring.kafka.consumer.group-id = ＃唯一字符串，用于标识此使用者所属的使用者组。</span><br><span class="line">spring.kafka.consumer.heartbeat间隔= ＃心跳与消费者协调员之间的预期时间。</span><br><span class="line">spring.kafka.consumer.key-deserializer = #Deserializer 类的键。</span><br><span class="line">spring.kafka.consumer.max-poll-records = ＃一次调用poll（）时返回的最大记录数。</span><br><span class="line">spring.kafka.consumer.properties。* = ＃用于配置客户端的其他特定于使用者的属性。</span><br><span class="line">spring.kafka.consumer.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.consumer.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.consumer.ssl.key-store-password =＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.consumer.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.consumer.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.consumer.ssl.trust-store-location = ＃信任存储文件的位置。</span><br><span class="line">spring.kafka.consumer.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.consumer.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.consumer.value-deserializer = #Deserializer 类的值。</span><br><span class="line">spring.kafka.jaas.control-flag = required ＃登录配置的控制标志。</span><br><span class="line">spring.kafka.jaas.enabled = false ＃是否启用JAAS配置。</span><br><span class="line">spring.kafka.jaas.login-module = com.sun.security.auth.module.Krb5LoginModule ＃登录模块。</span><br><span class="line">spring.kafka.jaas.options = ＃其他JAAS选项。</span><br><span class="line">spring.kafka.listener.ack-count = ＃当ackMode为“COUNT”或“COUNT_TIME”时，偏移提交之间的记录数。</span><br><span class="line">spring.kafka.listener.ack-mode = ＃Listener AckMode。请参阅spring-kafka文档。</span><br><span class="line">spring.kafka.listener.ack-time = ＃当ackMode为“TIME”或“COUNT_TIME”时，偏移提交之间的时间。</span><br><span class="line">spring.kafka.listener.client-id =＃侦听器的使用者client.id属性的前缀。</span><br><span class="line">spring.kafka.listener.concurrency = ＃在侦听器容器中运行的线程数。</span><br><span class="line">spring.kafka.listener.idle-event-interval = ＃发布空闲消费者事件（未收到数据）之间的时间。</span><br><span class="line">spring.kafka.listener.log-container-config = ＃是否在初始化期间记录容器配置（INFO级别）。</span><br><span class="line">spring.kafka.listener.monitor-interval = ＃检查无响应的消费者之间的时间。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.kafka.listener.no-poll-threshold =#Multiplier应用于“pollTimeout”以确定消费者是否无响应。</span><br><span class="line">spring.kafka.listener.poll-timeout = ＃轮询消费者时使用的超时。</span><br><span class="line">spring.kafka.listener.type = single ＃Listener类型。</span><br><span class="line">spring.kafka.producer.acks = ＃生产者要求领导者在考虑完成请求之前收到的确认数。</span><br><span class="line">spring.kafka.producer.batch-size = ＃默认批量大小。</span><br><span class="line">spring.kafka.producer.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。为生产者覆盖全球财产。</span><br><span class="line">spring.kafka.producer.buffer-memory = ＃生产者可用于缓冲等待发送到服务器的记录的总内存大小。</span><br><span class="line">spring.kafka.producer.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.producer.compression-type = ＃生产者生成的所有数据的压缩类型。</span><br><span class="line">spring.kafka.producer.key-serializer = ＃密码的Serializer类。</span><br><span class="line">spring.kafka.producer.properties。* = ＃用于配置客户端的其他特定于生产者的属性。</span><br><span class="line">spring.kafka.producer.retries = ＃大于零时，启用重试失败的发送。</span><br><span class="line">spring.kafka.producer.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.producer.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.producer.ssl.key-store-password = ＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.producer.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.producer.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.producer.ssl.trust-store-location = ＃信任库文件的位置。</span><br><span class="line">spring.kafka.producer.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.producer.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.producer.transaction-id-prefix = ＃非空时，为生产者启用事务支持。</span><br><span class="line">spring.kafka.producer.value-serializer = #Serializer 类的值。</span><br><span class="line">spring.kafka.properties。* = ＃用于配置客户端的生产者和使用者共有的附加属性。</span><br><span class="line">spring.kafka.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.ssl.key-store-password =＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.ssl.trust-store-location = ＃信任库文件的位置。</span><br><span class="line">spring.kafka.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.streams.application-id = #Kafka streams application.id property; 默认spring.application.name。</span><br><span class="line">spring.kafka.streams.auto-startup = true ＃是否自动启动流工厂bean。</span><br><span class="line">spring.kafka.streams.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。覆盖流的全局属性。</span><br><span class="line">spring.kafka.streams.cache-max-size-buffering = ＃用于跨所有线程缓冲的最大内存大小。</span><br><span class="line">spring.kafka.streams.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.streams.properties。* = ＃用于配置流的其他Kafka属性。</span><br><span class="line">spring.kafka.streams.replication-factor =＃流处理应用程序创建的更改日志主题和重新分区主题的复制因子。</span><br><span class="line">spring.kafka.streams.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.streams.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.streams.ssl.key-store-password = ＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.streams.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.streams.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.streams.ssl.trust-store-location = ＃信任库文件的位置。</span><br><span class="line">spring.kafka.streams.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.streams.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.streams.state-dir = ＃状态存储的目录位置。</span><br><span class="line">spring.kafka.template.default-topic = ＃发送消息的默认主题。</span><br><span class="line"></span><br><span class="line">#RABBIT（RabbitProperties）</span><br><span class="line">spring.rabbitmq.addresses = ＃逗号分隔的客户端应连接的地址列表。</span><br><span class="line">spring.rabbitmq.cache.channel.checkout-timeout = ＃达到缓存大小后等待获取通道的持续时间。</span><br><span class="line">spring.rabbitmq.cache.channel.size = ＃要在缓存中保留的通道数。</span><br><span class="line">spring.rabbitmq.cache.connection.mode = channel ＃连接工厂缓存模式。</span><br><span class="line">spring.rabbitmq.cache.connection.size = ＃缓存的连接数。</span><br><span class="line">spring.rabbitmq.connection-timeout = ＃连接超时。将其设置为零以永远等待。</span><br><span class="line">spring.rabbitmq.dynamic = true ＃是否创建AmqpAdmin bean。</span><br><span class="line">spring.rabbitmq.host = localhost ＃RabbitMQ主机。</span><br><span class="line">spring.rabbitmq.listener.direct.acknowledge-mode = ＃容器的确认模式。</span><br><span class="line">spring.rabbitmq.listener.direct.auto-startup = true ＃是否在启动时自动启动容器。</span><br><span class="line">spring.rabbitmq.listener.direct.consumers-per-queue = ＃每个队列的消费者数量。</span><br><span class="line">spring.rabbitmq.listener.direct.default-requeue-rejected = ＃默认情况下，拒绝的交付是否重新排队。</span><br><span class="line">spring.rabbitmq.listener.direct.idle-event-interval =＃应该发布空闲容器事件的频率。</span><br><span class="line">spring.rabbitmq.listener.direct.missing-queues-fatal = false ＃如果容器声明的队列在代理上不可用，则是否失败。</span><br><span class="line">spring.rabbitmq.listener.direct.prefetch = ＃每个消费者可能未完成的未确认消息的最大数量。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.enabled = false ＃是否启用发布重试。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.initial-interval = 1000ms ＃第一次和第二次尝试传递消息之间的持续时间。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.max-attempts = 3＃传递邮件的最大尝试次数。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.max -interval = 10000ms ＃尝试之间的最长持续时间。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.multiplier = 1 ＃乘数应用于先前的重试间隔。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.stateless = true ＃重试是无状态还是有状态。</span><br><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode = ＃容器的确认模式。</span><br><span class="line">spring.rabbitmq.listener.simple.auto-startup = true ＃是否在启动时自动启动容器。</span><br><span class="line">spring.rabbitmq.listener.simple.concurrency =＃侦听器调用者线程的最小数量。</span><br><span class="line">spring.rabbitmq.listener.simple.default-requeue-rejected = ＃默认情况下，拒绝的交付是否重新排队。</span><br><span class="line">spring.rabbitmq.listener.simple.idle-event-interval = ＃应该发布空闲容器事件的频率。</span><br><span class="line">spring.rabbitmq.listener.simple.max-concurrency = ＃侦听器调用者线程的最大数量。</span><br><span class="line">spring.rabbitmq.listener.simple.missing-queues-fatal = true ＃如果容器声明的队列在代理上不可用，则是否失败和/或如果在运行时删除一个或多个队列，是否停止容器。</span><br><span class="line">spring.rabbitmq.listener.simple.prefetch =＃每个消费者可能未完成的未确认消息的最大数量。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.enabled = false ＃是否启用发布重试。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.initial-interval = 1000ms ＃第一次和第二次尝试传递消息之间的持续时间。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.max-attempts = 3 ＃传递邮件的最大尝试次数。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.max -interval = 10000ms ＃尝试之间的最长持续时间。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.multiplier = 1 ＃乘数应用于上一个重试间隔。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.stateless = true ＃重试是无状态还是有状态。</span><br><span class="line">spring.rabbitmq.listener.simple.transaction-size = ＃确认模式为AUTO时要在acks之间处理的消息数。如果大于预取，则预取将增加到此值。</span><br><span class="line">spring.rabbitmq.listener.type = simple ＃Listener容器类型。</span><br><span class="line">spring.rabbitmq.password = guest ＃登录以对代理进行身份验证。</span><br><span class="line">spring.rabbitmq.port = 5672 ＃RabbitMQ端口。</span><br><span class="line">spring.rabbitmq.publisher-confirms = false ＃是否启用发布者确认。</span><br><span class="line">spring.rabbitmq.publisher-returns = false＃是否启用发布者返回。</span><br><span class="line">spring.rabbitmq.requested-heartbeat = ＃请求心跳超时; 零，没有。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.rabbitmq.ssl.algorithm = #SSL 算法使用。默认情况下，由Rabbit客户端库配置。</span><br><span class="line">spring.rabbitmq.ssl.enabled = false ＃是否启用SSL支持。</span><br><span class="line">spring.rabbitmq.ssl.key-store = ＃保存SSL证书的密钥库的路径。</span><br><span class="line">spring.rabbitmq.ssl.key-store-password = ＃用于访问密钥库的密码。</span><br><span class="line">spring.rabbitmq.ssl.key-store-type = PKCS12 ＃密钥库类型。</span><br><span class="line">spring.rabbitmq.ssl.trust-store = ＃持有SSL证书的信任存储。</span><br><span class="line">spring.rabbitmq.ssl.trust-store-password = ＃用于访问信任库的密码。</span><br><span class="line">spring.rabbitmq.ssl.trust-store-type = JKS #Trust store type。</span><br><span class="line">spring.rabbitmq.ssl.validate-server-certificate = true ＃是否启用服务器端证书验证。</span><br><span class="line">spring.rabbitmq.ssl.verify-hostname = true ＃是否启用主机名验证。</span><br><span class="line">spring.rabbitmq.template.default-receive-queue = ＃从明确指定none时接收消息的默认队列的名称。</span><br><span class="line">spring.rabbitmq.template.exchange =＃用于发送操作的默认交换的名称。</span><br><span class="line">spring.rabbitmq.template.mandatory = ＃是否启用强制消息。</span><br><span class="line">spring.rabbitmq.template.receive-timeout = ＃receive（）`操作的超时。</span><br><span class="line">spring.rabbitmq.template.reply-timeout = #outoutout用于`sendAndReceive（）`操作。</span><br><span class="line">spring.rabbitmq.template.retry.enabled = false ＃是否启用发布重试。</span><br><span class="line">spring.rabbitmq.template.retry.initial-interval = 1000ms ＃第一次和第二次尝试传递消息之间的持续时间。</span><br><span class="line">spring.rabbitmq.template.retry.max-attempts = 3 ＃传递邮件的最大尝试次数。</span><br><span class="line">spring.rabbitmq.template.retry.max -interval = 10000ms ＃尝试之间的最长持续时间。</span><br><span class="line">spring.rabbitmq.template.retry.multiplier = 1 ＃乘数应用于先前的重试间隔。</span><br><span class="line">spring.rabbitmq.template.routing-key = ＃用于发送操作的默认路由密钥的值。</span><br><span class="line">spring.rabbitmq.username = guest ＃登录用户以对代理进行身份验证。</span><br><span class="line">spring.rabbitmq.virtual-host = ＃连接到代理时使用的虚拟主机。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">＃---------------------------------------- </span><br><span class="line">＃ACTUATOR PROPERTIES </span><br><span class="line">＃----- -----------------------------------</span><br><span class="line"></span><br><span class="line">#MANAGEMENT HTTP SERVER（ManagementServerProperties）</span><br><span class="line">management.server.add-application-context-header = false ＃在每个响应中添加“X-Application-Context”HTTP标头。</span><br><span class="line">management.server.address = ＃管理端点应绑定到的网络地址。需要自定义management.server.port。</span><br><span class="line">management.server.port = ＃管理端点HTTP端口（默认情况下使用与应用程序相同的端口）。配置其他端口以使用特定于管理的SSL。</span><br><span class="line">management.server.servlet.context-path = ＃管理端点context-path（例如，`/ management`）。需要自定义management.server.port。</span><br><span class="line">management.server.ssl.ciphers= ＃支持的SSL密码。</span><br><span class="line">management.server.ssl.client-auth = ＃客户端身份验证模式。</span><br><span class="line">management.server.ssl.enabled = true ＃是否启用SSL支持。</span><br><span class="line">management.server.ssl.enabled-protocols = ＃启用SSL协议。</span><br><span class="line">management.server.ssl.key-alias = ＃标识密钥库中密钥的别名。</span><br><span class="line">management.server.ssl.key-password = ＃用于访问密钥库中密钥的密码。</span><br><span class="line">management.server.ssl.key-store = ＃保存SSL证书的密钥库的路径（通常是jks文件）。</span><br><span class="line">management.server.ssl.key-store-password =＃用于访问密钥库的密码。</span><br><span class="line">management.server.ssl.key-store-provider = ＃密钥库的提供者。</span><br><span class="line">management.server.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">management.server.ssl.protocol = TLS ＃要使用的SSL协议。</span><br><span class="line">management.server.ssl.trust-store = ＃持有SSL证书的信任存储。</span><br><span class="line">management.server.ssl.trust-store-password = ＃用于访问信任库的密码。</span><br><span class="line">management.server.ssl.trust-store-provider = ＃信任存储的提供者。</span><br><span class="line">management.server.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line"></span><br><span class="line">#CLOUDFOUNDRY </span><br><span class="line">management.cloudfoundry.enabled = true ＃是否启用扩展的Cloud Foundry执行器端点。</span><br><span class="line">management.cloudfoundry.skip-ssl-validation = false ＃是否跳过Cloud Foundry执行器端点安全调用的SSL验证。</span><br><span class="line"></span><br><span class="line">#ENDPOINTS GENERAL CONFIGURATION </span><br><span class="line">management.endpoints.enabled-by-default = ＃默认情况下是否启用或禁用所有端点。</span><br><span class="line"></span><br><span class="line">#ENDPOINTS JMX CONFIGURATION（JmxEndpointProperties）</span><br><span class="line">management.endpoints.jmx.domain = org.springframework.boot #Endpoints JMX域名。如果设置，则回退到&apos;spring.jmx.default-domain&apos;。</span><br><span class="line">management.endpoints.jmx.exposure.include = * ＃应包含的端点ID或所有的“*”。</span><br><span class="line">management.endpoints.jmx.exposure.exclude = ＃应排除的端点ID或所有的&apos;*&apos;。</span><br><span class="line">management.endpoints.jmx.static-names = ＃附加的静态属性，附加到表示端点的MBean的所有ObjectName。</span><br><span class="line"></span><br><span class="line">#ENDPOINTS WEB CONFIGURATION（WebEndpointProperties）</span><br><span class="line">management.endpoints.web.exposure.include = health，info ＃应包含的端点ID或所有的“*”。</span><br><span class="line">management.endpoints.web.exposure.exclude = ＃应排除的端点ID或所有的&apos;*&apos;。</span><br><span class="line">management.endpoints.web.base-path = / actuator #Web端点的基本路径。相对于server.servlet.context-path或management.server.servlet.context-path，如果配置了management.server.port。</span><br><span class="line">management.endpoints.web.path-mapping = ＃端点ID与应公开它们的路径之间的映射。</span><br><span class="line"></span><br><span class="line">#ENDPOINTS CORS CONFIGURATION（CorsEndpointProperties）</span><br><span class="line">management.endpoints.web.cors.allow-credentials = ＃是否支持凭据。未设置时，不支持凭据。</span><br><span class="line">management.endpoints.web.cors.allowed-headers = ＃逗号分隔的请求中允许的标头列表。&apos;*&apos;允许所有标题。</span><br><span class="line">management.endpoints.web.cors.allowed-methods = ＃逗号分隔的允许方法列表。&apos;*&apos;允许所有方法。未设置时，默认为GET。</span><br><span class="line">management.endpoints.web.cors.allowed-origins = ＃逗号分隔的原始列表允许。&apos;*&apos;允许所有来源。未设置时，将禁用CORS支持。</span><br><span class="line">management.endpoints.web.cors.exposed-headers = ＃逗号分隔的标题列表，包含在响应中。</span><br><span class="line">management.endpoints.web.cors.max-age = 1800s ＃客户端缓存来自飞行前请求的响应的时间。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line"></span><br><span class="line">#AUDIT EVENTS ENDPOINT（AuditEventsEndpoint）</span><br><span class="line">management.endpoint.auditevents.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.auditevents.enabled = true ＃是否启用auditevents端点。</span><br><span class="line"></span><br><span class="line">#BEANS ENDPOINT（BeansEndpoint）</span><br><span class="line">management.endpoint.beans.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.beans.enabled = true ＃是否启用beans端点。</span><br><span class="line"></span><br><span class="line">#CACHES ENDPOINT（CachesEndpoint）</span><br><span class="line">management.endpoint.caches.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.caches.enabled = true ＃是否启用缓存端点。</span><br><span class="line"></span><br><span class="line">#条件报告ENDPOINT（ConditionsReportEndpoint）</span><br><span class="line">management.endpoint.conditions.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.conditions.enabled = true ＃是否启用条件端点。</span><br><span class="line"></span><br><span class="line">#CONFIGURATION PROPERTIES REPORT ENDPOINT（ConfigurationPropertiesReportEndpoint，ConfigurationPropertiesReportEndpointProperties）</span><br><span class="line">management.endpoint.configprops.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.configprops.enabled = true ＃是否启用configprops端点。</span><br><span class="line">management.endpoint.configprops.keys-to-sanitize = password，secret，key，token，。* credentials。*，vcap_services，sun.java.command ＃应该清理的密钥。键可以是属性结尾的简单字符串或正则表达式。</span><br><span class="line"></span><br><span class="line">#ENVEST ENDPOINT（EnvironmentEndpoint，EnvironmentEndpointProperties）</span><br><span class="line">management.endpoint.env.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.env.enabled = true ＃是否启用env端点。</span><br><span class="line">management.endpoint.env.keys-to-sanitize = password，secret，key，token，。* credentials。*，vcap_services，sun.java.command ＃应该清理的密钥。键可以是属性结尾的简单字符串或正则表达式。</span><br><span class="line"></span><br><span class="line">#FLYWAY ENDPOINT（FlywayEndpoint）</span><br><span class="line"> management.endpoint.flyway.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.flyway.enabled = true ＃是否启用flyway端点。</span><br><span class="line"></span><br><span class="line">#HEEC ENDPOINT（HealthEndpoint，HealthEndpointProperties）</span><br><span class="line">management.endpoint.health.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.health.enabled = true ＃是否启用运行状况端点。</span><br><span class="line">management.endpoint.health.roles = ＃用于确定是否授权用户显示详细信息的角色。为空时，所有经过身份验证的用户都被授权。</span><br><span class="line">management.endpoint.health.show-details = never ＃何时显示完整的健康详细信息。</span><br><span class="line"></span><br><span class="line">#HEAP DUMP ENDPOINT（HeapDumpWebEndpoint）</span><br><span class="line">management.endpoint.heapdump.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.heapdump.enabled = true ＃是否启用heapdump端点。</span><br><span class="line"></span><br><span class="line">#HTTP TRACE ENDPOINT（HttpTraceEndpoint）</span><br><span class="line">management.endpoint.httptrace.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.httptrace.enabled = true ＃是否启用httptrace端点。</span><br><span class="line"></span><br><span class="line">#INFO ENDPOINT（InfoEndpoint）</span><br><span class="line">info = ＃要添加到信息端点的任意属性。</span><br><span class="line">management.endpoint.info.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.info.enabled = true ＃是否启用信息端点。</span><br><span class="line"></span><br><span class="line">#INTEGRATION GRAPH ENDPOINT（IntegrationGraphEndpoint）</span><br><span class="line">management.endpoint.integrationgraph.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.integrationgraph.enabled = true ＃是否启用集成图终结点。</span><br><span class="line"></span><br><span class="line">#JOLOKIA ENDPOINT（JolokiaProperties）</span><br><span class="line">management.endpoint.jolokia.config。* = ＃Jolokia设置。有关更多详细信息，请参阅Jolokia的文档。</span><br><span class="line">management.endpoint.jolokia.enabled = true ＃是否启用jolokia端点。</span><br><span class="line"></span><br><span class="line">#LIQUIBASE ENDPOINT（LiquibaseEndpoint）</span><br><span class="line">management.endpoint.liquibase.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.liquibase.enabled = true ＃是否启用liquibase端点。</span><br><span class="line"></span><br><span class="line">＃LOG FILE ENDPOINT（LogFileWebEndpoint，LogFileWebEndpointProperties）</span><br><span class="line">management.endpoint.logfile.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.logfile.enabled = true ＃是否启用日志文件端点。</span><br><span class="line">management.endpoint.logfile.external-file = ＃要访问的外部日志文件。如果日志文件由输出重定向而不是日志记录系统本身写入，则可以使用。</span><br><span class="line"></span><br><span class="line">＃LOGGERS ENDPOINT（LoggersEndpoint）</span><br><span class="line">management.endpoint.loggers.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.loggers.enabled = true ＃是否启用记录器端点。</span><br><span class="line"></span><br><span class="line">#REQUEST MAPPING ENDPOINT（MappingsEndpoint）</span><br><span class="line">management.endpoint.mappings.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.mappings.enabled = true ＃是否启用映射端点。</span><br><span class="line"></span><br><span class="line">#METRICS ENDPOINT（MetricsEndpoint）</span><br><span class="line">management.endpoint.metrics.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.metrics.enabled = true ＃是否启用指标端点。</span><br><span class="line"></span><br><span class="line">#PROMETHEUS ENDPOINT（PrometheusScrapeEndpoint）</span><br><span class="line">management.endpoint.prometheus.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.prometheus.enabled = true ＃是否启用prometheus端点。</span><br><span class="line"></span><br><span class="line">#STEEDEDED TASKS ENDPOINT（ScheduledTasksEndpoint）</span><br><span class="line">management.endpoint.scheduledtasks.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.scheduledtasks.enabled = true ＃是否启用scheduledtasks端点。</span><br><span class="line"></span><br><span class="line">#SESSIONS ENDPOINT（SessionsEndpoint）</span><br><span class="line">management.endpoint.sessions.enabled = true ＃是否启用会话端点。</span><br><span class="line"></span><br><span class="line">#SHUTDOWN ENDPOINT（ShutdownEndpoint）</span><br><span class="line">management.endpoint.shutdown.enabled = false ＃是否启用关闭端点。</span><br><span class="line"></span><br><span class="line">#THREAD DUMP ENDPOINT（ThreadDumpEndpoint）</span><br><span class="line">management.endpoint.threaddump.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.threaddump.enabled = true ＃是否启用threaddump端点。</span><br><span class="line"></span><br><span class="line">＃HEALTH INDICATORS </span><br><span class="line">management.health.db.enabled = true ＃是否启用数据库运行状况检查。</span><br><span class="line">management.health.cassandra.enabled = true ＃是否启用Cassandra运行状况检查。</span><br><span class="line">management.health.couchbase.enabled = true ＃是否启用Couchbase运行状况检查。</span><br><span class="line">management.health.defaults.enabled = true ＃是否启用默认健康指标。</span><br><span class="line">management.health.diskspace.enabled = true ＃是否启用磁盘空间运行状况检查。</span><br><span class="line">management.health.diskspace.path = ＃用于计算可用磁盘空间的路径。</span><br><span class="line">management.health.diskspace.threshold = 10MB＃应该可用的最小磁盘空间。</span><br><span class="line">management.health.elasticsearch.enabled = true ＃是否启用Elasticsearch运行状况检查。</span><br><span class="line">management.health.elasticsearch.indices = ＃逗号分隔的索引名称。</span><br><span class="line">management.health.elasticsearch.response-timeout = 100ms ＃等待集群响应的时间。</span><br><span class="line">management.health.influxdb.enabled = true ＃是否启用InfluxDB运行状况检查。</span><br><span class="line">management.health.jms.enabled = true ＃是否启用JMS运行状况检查。</span><br><span class="line">management.health.ldap.enabled = true ＃是否启用LDAP运行状况检查。</span><br><span class="line">management.health.mail.enabled = true＃是否启用邮件健康检查。</span><br><span class="line">management.health.mongo.enabled = true ＃是否启用MongoDB运行状况检查。</span><br><span class="line">management.health.neo4j.enabled = true ＃是否启用Neo4j运行状况检查。</span><br><span class="line">management.health.rabbit.enabled = true ＃是否启用RabbitMQ运行状况检查。</span><br><span class="line">management.health.redis.enabled = true ＃是否启用Redis运行状况检查。</span><br><span class="line">management.health.solr.enabled = true ＃是否启用Solr运行状况检查。</span><br><span class="line">management.health.status.http-mapping = ＃将健康状态映射到HTTP状态代码。默认情况下，已注册的运行状况映射到合理的默认值（例如，UP映射到200）。</span><br><span class="line">management.health.status.order = DOWN，OUT_OF_SERVICE，UP，UNKNOWN ＃以逗号分隔的健康状态列表，按严重程度排序。</span><br><span class="line"></span><br><span class="line">#HTTP TRACING（HttpTraceProperties）</span><br><span class="line">management.trace.http.enabled = true ＃是否启用HTTP请求 - 响应跟踪。</span><br><span class="line">management.trace.http.include =请求标头，响应标头，cookie，错误＃要包含在跟踪中的项目。</span><br><span class="line"></span><br><span class="line">#INFO CONTRIBUTORS（InfoContributorProperties）</span><br><span class="line">management.info.build.enabled = true ＃是否启用构建信息。</span><br><span class="line">management.info.defaults.enabled = true ＃是否启用默认信息贡献者。</span><br><span class="line">management.info.env.enabled = true ＃是否启用环境信息。</span><br><span class="line">management.info.git.enabled = true ＃是否启用git信息。</span><br><span class="line">management.info.git.mode = simple ＃用于公开git信息的模式。</span><br><span class="line"></span><br><span class="line">#METRICS </span><br><span class="line">management.metrics.distribution.maximum-expected-value。* = ＃预计将以指定名称开始计量ID的最大值。</span><br><span class="line">management.metrics.distribution.minimum-expected-value。* = ＃预计将以指定名称开始的仪表ID的最小值。</span><br><span class="line">management.metrics.distribution.percentiles。* = ＃特定计算的非可聚合百分位数，用于以指定名称开始的仪表ID发送到后端。</span><br><span class="line">management.metrics.distribution.percentiles-histogram。* = ＃是否以指定名称开头的米ID应发布百分位直方图。</span><br><span class="line">management.metrics.distribution.sla。* =＃以指定名称开头的仪表ID的特定SLA边界。最长的比赛获胜。</span><br><span class="line">management.metrics.enable。* = ＃应启用是否以指定名称开始的仪表ID。最长的匹配获胜，关键的“all”也可以用于配置所有的米。</span><br><span class="line">management.metrics.export.appoptics.api-token = #AppOptics API令牌。</span><br><span class="line">management.metrics.export.appoptics.batch-size = 500 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.appoptics.connect-timeout = 5s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.appoptics.enabled= true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.appoptics.host-tag = instance ＃将指标发送到AppOptics时将映射到“@host”的标记。</span><br><span class="line">management.metrics.export.appoptics.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.appoptics.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.appoptics.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.appoptics.uri = https://api.appoptics.com/v1/measurements# 将指标发送到的URI。</span><br><span class="line">management.metrics.export.atlas.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.atlas.config-refresh-frequency = 10s ＃从LWC服务刷新配置设置的频率。</span><br><span class="line">management.metrics.export.atlas.config-time-to-live = 150s #LWC服务订阅的生存时间。</span><br><span class="line">management.metrics.export.atlas.config-uri = http：// localhost：7101 / lwc / api / v1 / expressions / local-dev #Atlas LWC端点的URI，用于检索当前订阅。</span><br><span class="line">management.metrics.export.atlas.connect-timeout = 1s＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.atlas.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.atlas.eval-uri = http：// localhost：7101 / lwc / api / v1 / evaluate ＃用于评估订阅数据的Atlas LWC端点的URI。</span><br><span class="line">management.metrics.export.atlas.lwc-enabled = false ＃是否启用流式传输到Atlas LWC。</span><br><span class="line">management.metrics.export.atlas.meter-time-to-live = 15m ＃没有任何活动的米的生存时间。在此期限之后，仪表将被视为已过期且不会报告。</span><br><span class="line">management.metrics.export.atlas.num-threads = 2＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.atlas.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.atlas.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.atlas.uri = http：// localhost：7101 / api / v1 / publish #Atlas服务器的URI。</span><br><span class="line">management.metrics.export.datadog.api-key = ＃Datadog API密钥。</span><br><span class="line">management.metrics.export.datadog.application-key = ＃Datadog应用程序密钥。不是严格要求，但通过向Datadog发送仪表描述，类型和基本单位来改进Datadog体验。</span><br><span class="line">management.metrics.export.datadog.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.datadog.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.datadog.descriptions = true ＃是否将描述元数据发布到Datadog。将其关闭以最小化发送的元数据量。</span><br><span class="line">management.metrics.export.datadog.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.datadog.host-tag = instance＃将指标发送到Datadog时将映射到“主机”的标记。</span><br><span class="line">management.metrics.export.datadog.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.datadog.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.datadog.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.datadog.uri = https://app.datadoghq.com# 将指标发送到的URI。如果需要将指标发布到到Datadog的内部代理，则可以使用此方法定义代理的位置。</span><br><span class="line">management.metrics.export.dynatrace.api-token =#Dynatrace身份验证令牌。</span><br><span class="line">management.metrics.export.dynatrace.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.dynatrace.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.dynatrace.device-id = 将度量标准导出到Dynatrace的自定义设备的ID。</span><br><span class="line">management.metrics.export.dynatrace.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.dynatrace.num-threads = 2＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.dynatrace.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.dynatrace.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.dynatrace.technology-type = java ＃导出的指标的技术类型。用于在Dynatrace UI中对逻辑技术名称下的度量标准进行分组。</span><br><span class="line">management.metrics.export.dynatrace.uri = 将指标发送到的URI。应该用于SaaS，自我管理的实例或通过内部代理途径。</span><br><span class="line">management.metrics.export.elastic.auto-create-index = true＃是否自动创建索引（如果不存在）。</span><br><span class="line">management.metrics.export.elastic.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.elastic.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.elastic.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.elastic.host = http：// localhost：9200 ＃将指标导出到的主机。</span><br><span class="line">management.metrics.export.elastic.index = metrics ＃将指标导出到的索引。</span><br><span class="line">management.metrics.export.elastic.index-date-format = yyyy-MM ＃用于滚动索引的索引日期格式。附加到索引名称后面加一个&apos; - &apos;。</span><br><span class="line">management.metrics.export.elastic.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.elastic.password = ＃弹性服务器的登录密码。</span><br><span class="line">management.metrics.export.elastic.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.elastic.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.elastic.timestamp-field-name = @ timestamp ＃时间戳字段的名称。 </span><br><span class="line">management.metrics.export.elastic.user-name = ＃弹性服务器的登录用户。</span><br><span class="line">management.metrics.export.ganglia.addressing-mode = multicast ＃UDP寻址模式，单播或多播。</span><br><span class="line">management.metrics.export.ganglia.duration- units =毫秒＃用于报告持续时间的基本时间单位。</span><br><span class="line">management.metrics.export.ganglia.enabled = true ＃是否启用向Ganglia导出指标。</span><br><span class="line">management.metrics.export.ganglia.host = localhost ＃Ganglia服务器的主机，用于接收导出的指标。</span><br><span class="line">management.metrics.export.ganglia.port = 8649 ＃Ganglia服务器端口，用于接收导出的指标。</span><br><span class="line">management.metrics.export.ganglia.protocol-version = 3.1 ＃Ganglia协议版本。必须是3.1或3.0。</span><br><span class="line">management.metrics.export.ganglia.rate- units = seconds ＃用于报告费率的基本时间单位。</span><br><span class="line">management.metrics.export.ganglia.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.ganglia.time-to-live = 1 ＃生活在Ganglia上的指标的时间。将多播生存时间设置为大于主机之间的跳数（路由器）的数量。</span><br><span class="line">management.metrics.export.graphite.duration-units =毫秒＃用于报告持续时间的基本时间单位。</span><br><span class="line">management.metrics.export.graphite.enabled = true＃是否启用将指标导出到Graphite。</span><br><span class="line">management.metrics.export.graphite.host = localhost ＃Graphite服务器的主机，用于接收导出的指标。</span><br><span class="line">management.metrics.export.graphite.port = 2004 ＃Graphite服务器的端口，用于接收导出的指标。</span><br><span class="line">management.metrics.export.graphite.protocol = pickled ＃在将数据发送到Graphite时使用的协议。</span><br><span class="line">management.metrics.export.graphite.rate-units = seconds ＃用于报告费率的基本时间单位。</span><br><span class="line">management.metrics.export.graphite.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.graphite.tags-as-prefix =＃对于默认命名约定，将指定的标记键转换为度量标准前缀的一部分。</span><br><span class="line">management.metrics.export.humio.api-token = ＃Humio API令牌。</span><br><span class="line">management.metrics.export.humio.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.humio.connect-timeout = 5s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.humio.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.humio.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.humio.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.humio.repository = sandbox ＃要将指标发布到的存储库的名称。</span><br><span class="line">management.metrics.export.humio.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.humio.tags。* = ＃Humio标签，用于描述将存储指标的数据源。Humio标签是与Micrometer标签不同的概念。千分尺的标签用于沿尺寸边界划分度量。</span><br><span class="line">management.metrics.export.humio.uri = https://cloud.humio.com#idex将指标发送到。如果您需要将指标发布到Humio的内部代理，您可以使用此方法定义代理的位置。</span><br><span class="line">management.metrics.export.influx.auto-create-db = true ＃在尝试向其发布指标之前，是否创建Influx数据库是否存在。</span><br><span class="line">management.metrics.export.influx.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.influx.compressed = true ＃是否对发布到Influx的度量批次启用GZIP压缩。</span><br><span class="line">management.metrics.export.influx.connect-timeout = 1s＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.influx.consistency = one ＃为每个点写一致性。</span><br><span class="line">management.metrics.export.influx.db = mydb ＃将指标发送到Influx时将映射到“主机”的标记。</span><br><span class="line">management.metrics.export.influx.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.influx.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.influx.password = ＃Influx服务器的登录密码。</span><br><span class="line">management.metrics.export.influx.read-timeout = 10s＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.influx.retention-duration = ＃Influx应在当前数据库中保留数据的时间段。</span><br><span class="line">management.metrics.export.influx.retention-shard-duration = ＃分片组覆盖的时间范围。</span><br><span class="line">management.metrics.export.influx.retention-policy = ＃要使用的保留策略（如果未指定，则Influx写入DEFAULT保留策略）。</span><br><span class="line">management.metrics.export.influx.retention-replication-factor = ＃在群集中存储了多少份数据副本。</span><br><span class="line">management.metrics.export.influx.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.influx.uri = http：// localhost：8086 ＃Influx服务器的URI。</span><br><span class="line">management.metrics.export.influx.user-name = ＃Influx服务器的登录用户。</span><br><span class="line">management.metrics.export.jmx.domain = metrics ＃Metrics JMX域名。</span><br><span class="line">management.metrics.export.jmx.enabled = true ＃是否已启用将度量标准导出到JMX。</span><br><span class="line">management.metrics.export.jmx.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.kairos.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.kairos.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.kairos.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.kairos.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.kairos.password = #KairosDB服务器的登录密码。</span><br><span class="line">management.metrics.export.kairos.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.kairos.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.kairos.uri = localhost：8080 / api / v1 /  datapoints #KairosDB服务器的URI。</span><br><span class="line">management.metrics.export.kairos.user-name = #KairosDB服务器的登录用户。</span><br><span class="line">management.metrics.export.newrelic.account-id = ＃新Relic帐户ID。</span><br><span class="line">management.metrics.export.newrelic.api-key = #New Relic API密钥。</span><br><span class="line">management.metrics.export.newrelic.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.newrelic.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.newrelic.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.newrelic.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.newrelic.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.newrelic.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.newrelic.uri = https：//insights-collector.newrelic.com #idex 将指标发送到。</span><br><span class="line">management.metrics.export.prometheus.descriptions = true＃是否将发布描述作为scrape有效负载的一部分启用到Prometheus。将其关闭以最小化每次刮擦发送的数据量。</span><br><span class="line">management.metrics.export.prometheus.enabled = true ＃是否启用将指标导出到Prometheus。</span><br><span class="line">management.metrics.export.prometheus.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.base-url = localhost：9091 ＃Pushgateway的基本URL。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.enabled = false ＃通过Prometheus Pushgateway启用发布。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.grouping-key =＃为推送的指标分组键。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.job = ＃此应用程序实例的作业标识符。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.push-rate = 1m ＃用于推送指标的频率。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.shutdown-operation = ＃应该在关机时执行的操作。</span><br><span class="line">management.metrics.export.signalfx.access-token = #SignalFX访问令牌。</span><br><span class="line">management.metrics.export.signalfx.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.signalfx.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.signalfx.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.signalfx.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.signalfx.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.signalfx.source = ＃唯一标识正在向SignalFx发布指标的应用实例。默认为本地主机名。</span><br><span class="line">management.metrics.export.signalfx.step = 10s＃步骤大小（即报告频率）使用。</span><br><span class="line">management.metrics.export.signalfx.uri = https：//ingest.signalfx.com# 将指标发送到的URI。</span><br><span class="line">management.metrics.export.simple.enabled = true ＃在没有任何其他导出器的情况下，是否启用将指标导出到内存后端。</span><br><span class="line">management.metrics.export.simple.mode =累积＃计数模式。</span><br><span class="line">management.metrics.export.simple.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.statsd.enabled = true ＃是否启用将度量标准导出到StatsD。</span><br><span class="line">management.metrics.export.statsd.flavor = datadog#StatsD线路协议使用。</span><br><span class="line">management.metrics.export.statsd.host = localhost ＃StatsD服务器的主机，用于接收导出的指标。</span><br><span class="line">management.metrics.export.statsd.max-packet-length = 1400 ＃单个有效负载的总长度应保持在网络的MTU中。</span><br><span class="line">management.metrics.export.statsd.polling-frequency = 10s ＃测量仪表的频率。轮询仪表时，会重新计算其值，如果值已更改（或者publishUnchangedMeters为true），则会将其发送到StatsD服务器。</span><br><span class="line">management.metrics.export.statsd.port = 8125 ＃StatsD服务器的端口，用于接收导出的指标。</span><br><span class="line">management.metrics.export.statsd.publish-不变米= true ＃是否将未更改的计量表发送到StatsD服务器。</span><br><span class="line">management.metrics.export.wavefront.api-token = ＃将指标直接发布到Wavefront API主机时使用的API令牌。</span><br><span class="line">management.metrics.export.wavefront.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.wavefront.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.wavefront.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.wavefront.global-prefix =＃全局前缀用于将源自此应用程序的白盒工具的度量标准与在Wavefront UI中查看时源自其他Wavefront集成的度量标准分开。</span><br><span class="line">management.metrics.export.wavefront.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.wavefront.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.wavefront.source = ＃应用程序实例的唯一标识符，该实例是发布到Wavefront的度量标准的来源。默认为本地主机名。</span><br><span class="line">management.metrics.export.wavefront.step = 10s ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.wavefront.uri = https://longboard.wavefront.com# 将指标发送到的URI。</span><br><span class="line">management.metrics.use-global-registry = true ＃是否应将自动配置的MeterRegistry实现绑定到Metrics上的全局静态注册表。</span><br><span class="line">management.metrics.tags。* = ＃应用于每个仪表的公共标签。</span><br><span class="line">management.metrics.web.client.max-uri-tags = 100 ＃允许的唯一URI标记值的最大数量。达到最大标记值数后，过滤器将拒绝具有其他标记值的度量标准。</span><br><span class="line">management.metrics.web.client.requests-metric-name = http.client.requests ＃已发送请求的度量标准的名称。</span><br><span class="line">management.metrics.web.server.auto-time-requests = true ＃是否应自动为Spring MVC，WebFlux或Jersey处理的请求定时。</span><br><span class="line">management.metrics.web.server.max-uri-tags = 100 ＃允许的唯一URI标记值的最大数量。达到最大标记值数后，过滤器将拒绝具有其他标记值的度量标准。</span><br><span class="line">management.metrics.web.server.requests-metric-name = http.server.requests ＃已接收请求的度量标准的名称。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">＃---------------------------------------- </span><br><span class="line">#DEDTOOLS PROPERTIES </span><br><span class="line">＃----------------------------------------</span><br><span class="line"></span><br><span class="line">#DESTOOLS（DevToolsProperties）</span><br><span class="line">spring.devtools.add-properties = true ＃是否启用开发属性默认值。</span><br><span class="line">spring.devtools.livereload.enabled = true ＃是否启用livereload.com兼容服务器。</span><br><span class="line">spring.devtools.livereload.port = 35729 ＃服务器端口。</span><br><span class="line">spring.devtools.restart.additional-exclude = ＃应该从触发完全重启中排除的其他模式。</span><br><span class="line">spring.devtools.restart.additional-paths = ＃要监视更改的其他路径。</span><br><span class="line">spring.devtools.restart.enabled = true ＃是否启用自动重启。</span><br><span class="line">spring.devtools.restart.exclude= META-INF /行家/ **，META-INF /资源/ **，资源/ **，静态/ **，公共/ **，模板/ **，** / *的Test.class，** / * Tests.class，git.properties，META-INF / build-info.properties ＃应该从触发完全重启中排除的模式。</span><br><span class="line">spring.devtools.restart.log-condition-evaluation-delta = true ＃是否在重新启动时记录条件评估增量。</span><br><span class="line">spring.devtools.restart.poll-interval = 1s ＃轮询类路径更改之间等待的时间。</span><br><span class="line">spring.devtools.restart.quiet-period = 400ms ＃触发重启之前没有任何类路径更改所需的安静时间量。</span><br><span class="line">spring.devtools.restart.trigger-file =＃特定文件的名称，当更改时，触发重新启动检查。如果未指定，则任何类路径文件更改都会触发重新启动。</span><br><span class="line"></span><br><span class="line">#remote DEVTOOLS（RemoteDevToolsProperties）</span><br><span class="line">spring.devtools.remote.context-path = /。~~ spring-boot！〜＃用于处理远程连接的上下文路径。</span><br><span class="line">spring.devtools.remote.proxy.host = ＃用于连接远程应用程序的代理主机。</span><br><span class="line">spring.devtools.remote.proxy.port = ＃用于连接远程应用程序的代理端口。</span><br><span class="line">spring.devtools.remote.restart.enabled = true ＃是否启用远程重启。</span><br><span class="line">spring.devtools.remote.secret = ＃建立连接所需的共享密钥（启用远程支持所需）。</span><br><span class="line">spring.devtools.remote.secret头名= X-AUTH-TOKEN ＃用于传输共享密钥的HTTP头。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">＃---------------------------------------- </span><br><span class="line">#TESTING PROPERTIES </span><br><span class="line">＃----- -----------------------------------</span><br><span class="line"></span><br><span class="line">spring.test.database.replace = any ＃要替换的现有DataSource的类型。</span><br><span class="line">spring.test.mockmvc.print =default #MVC 打印选项。</span><br></pre></td></tr></table></figure>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-附录A/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-SpringMVC/">使用SpringBoot-SpringMVC</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/rest/">rest</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/spring/">spring</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/mvc/">mvc</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>Spring Boot有许多包含Spring MVC的启动器。请注意，一些启动器包含对Spring MVC的依赖，而不是直接包含它。本节回答有关Spring MVC和Spring Boot的常见问题。</p>
<h2 id="编写JSON-REST服务"><a href="#编写JSON-REST服务" class="headerlink" title="编写JSON REST服务"></a>编写JSON REST服务</h2><p><code>@RestController</code>只要Jackson2在类路径中，Spring Boot应用程序中的任何Spring 都应默认呈现JSON响应，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/thing"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> MyThing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MyThing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要<code>MyThing</code>可以通过Jackson2序列化（对于普通的POJO或Groovy对象都是如此），则<code>localhost:8080/thing</code>默认为它提供JSON表示。请注意，在浏览器中，您有时可能会看到XML响应，因为浏览器倾向于发送更喜欢XML的接受标头。</p>
<h2 id="编写XML-REST服务"><a href="#编写XML-REST服务" class="headerlink" title="编写XML REST服务"></a>编写XML REST服务</h2><p>如果<code>jackson-dataformat-xml</code>在类路径上有Jackson XML扩展（），则可以使用它来呈现XML响应。我们用于JSON的前一个示例可以使用。要使用Jackson XML渲染器，请将以下依赖项添加到项目中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果Jackson的XML扩展不可用，则使用JAXB（默认情况下在JDK中提供），并附加要求<code>MyThing</code>注释为 <code>@XmlRootElement</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThing</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">// .. getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使服务器呈现XML而不是JSON，您可能必须发送 <code>Accept: text/xml</code>标头（或使用浏览器）。</p>
<h2 id="自定义Jackson-ObjectMapper"><a href="#自定义Jackson-ObjectMapper" class="headerlink" title="自定义Jackson ObjectMapper"></a>自定义Jackson ObjectMapper</h2><p>Spring MVC（客户端和服务器端）用于<code>HttpMessageConverters</code>协商HTTP交换中的内容转换。如果Jackson在类路径上，您已经获得了由其提供的默认转换器<code>Jackson2ObjectMapperBuilder</code>，其实例将自动为您配置。</p>
<p>该<code>ObjectMapper</code>（或<code>XmlMapper</code>为JacksonXML转换器）实例（默认创建）具有以下定义的属性：</p>
<ul>
<li><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code> 被禁用</li>
<li><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code> 被禁用</li>
<li><code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code> 被禁用</li>
</ul>
<p>Spring Boot还具有一些功能，可以更轻松地自定义此行为。</p>
<p>您可以使用环境配置<code>ObjectMapper</code>和<code>XmlMapper</code>实例。Jackson提供了一套广泛的简单开/关功能，可用于配置其处理的各个方面。这些功能在六个enum（在Jackson中）中描述，它们映射到环境中的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">枚举</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>com.fasterxml.jackson.databind.DeserializationFeature</code></td>
<td style="text-align:center"><code>spring.jackson.deserialization.&lt;feature_name&gt;</code></td>
<td style="text-align:center"><code>true</code>， <code>false</code></td>
</tr>
<tr>
<td style="text-align:center"><code>com.fasterxml.jackson.core.JsonGenerator.Feature</code></td>
<td style="text-align:center"><code>spring.jackson.generator.&lt;feature_name&gt;</code></td>
<td style="text-align:center"><code>true</code>， <code>false</code></td>
</tr>
<tr>
<td style="text-align:center"><code>com.fasterxml.jackson.databind.MapperFeature</code></td>
<td style="text-align:center"><code>spring.jackson.mapper.&lt;feature_name&gt;</code></td>
<td style="text-align:center"><code>true</code>， <code>false</code></td>
</tr>
<tr>
<td style="text-align:center"><code>com.fasterxml.jackson.core.JsonParser.Feature</code></td>
<td style="text-align:center"><code>spring.jackson.parser.&lt;feature_name&gt;</code></td>
<td style="text-align:center"><code>true</code>， <code>false</code></td>
</tr>
<tr>
<td style="text-align:center"><code>com.fasterxml.jackson.databind.SerializationFeature</code></td>
<td style="text-align:center"><code>spring.jackson.serialization.&lt;feature_name&gt;</code></td>
<td style="text-align:center"><code>true</code>， <code>false</code></td>
</tr>
<tr>
<td style="text-align:center"><code>com.fasterxml.jackson.annotation.JsonInclude.Include</code></td>
<td style="text-align:center"><code>spring.jackson.default-property-inclusion</code></td>
<td style="text-align:center"><code>always</code>，<code>non_null</code>，<code>non_absent</code>，<code>non_default</code>，<code>non_empty</code></td>
</tr>
</tbody>
</table>
<p>例如，要启用漂亮打印，请设置<code>spring.jackson.serialization.indent_output=true</code>。需要注意的是，由于使用了<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-relaxed-binding" target="_blank" rel="noopener">松弛绑定</a>，所以<code>indent_output</code>不必匹配相应枚举常量的情况，即<code>INDENT_OUTPUT</code>。</p>
<p>此基于环境的配置应用于自动配置的 <code>Jackson2ObjectMapperBuilder</code>bean，并应用于使用构建器创建的任何映射器，包括自动配置的<code>ObjectMapper</code>bean。</p>
<p>上下文<code>Jackson2ObjectMapperBuilder</code>可以由一个或多个<code>Jackson2ObjectMapperBuilderCustomizer</code>bean 自定义 。可以订购这样的定制器bean（Boot自己的定制器的顺序为0），允许在Boot定制之前和之后应用其他定制。</p>
<p>任何类型的bean都会<code>com.fasterxml.jackson.databind.Module</code>自动注册自动配置<code>Jackson2ObjectMapperBuilder</code>，并应用于<code>ObjectMapper</code> 它创建的任何实例。这为您在应用程序中添加新功能时提供了一种提供自定义模块的全局机制。</p>
<p>如果要<code>ObjectMapper</code>完全替换默认值，请定义<code>@Bean</code>该类型的一个并将其标记为，<code>@Primary</code>或者，如果您更喜欢基于构建器的方法，请定义一个<code>Jackson2ObjectMapperBuilder</code> <code>@Bean</code>。请注意，在任何一种情况下，这样做都会禁用所有的自动配置<code>ObjectMapper</code>。</p>
<p>如果提供任何<code>@Beans</code>类型<code>MappingJackson2HttpMessageConverter</code>，则它们将替换MVC配置中的默认值。此外，<code>HttpMessageConverters</code>还提供了类型的便利bean （如果使用默认的MVC配置，则始终可用）。它有一些有用的方法来访问默认和用户增强的消息转换器。</p>
<p>有关详细信息，请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-customize-the-responsebody-rendering" target="_blank" rel="noopener">第79.4节</a> ” <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-customize-the-responsebody-rendering" target="_blank" rel="noopener">，“自定义@ResponseBody渲染</a> ”部分和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java" target="_blank" rel="noopener"><code>WebMvcAutoConfiguration</code></a> 源代码。</p>
<h2 id="自定义-ResponseBody渲染"><a href="#自定义-ResponseBody渲染" class="headerlink" title="自定义@ResponseBody渲染"></a>自定义@ResponseBody渲染</h2><p>Spring用于<code>HttpMessageConverters</code>渲染<code>@ResponseBody</code>（或响应 <code>@RestController</code>）。您可以通过在Spring Boot上下文中添加适当类型的bean来提供其他转换器。如果您添加的bean是默认包含的类型（例如<code>MappingJackson2HttpMessageConverter</code>JSON转换），则它将替换默认值。<code>HttpMessageConverters</code>提供了类型的便利bean， 如果您使用默认的MVC配置，它始终可用。它有一些有用的方法来访问默认和用户增强的消息转换器（例如，如果要手动将它们注入自定义，它可能很有用<code>RestTemplate</code>）。</p>
<p>与正常的MVC使用情况一样，<code>WebMvcConfigurer</code>您提供的任何bean也可以通过覆盖该<code>configureMessageConverters</code>方法来提供转换器。但是，与普通的MVC不同，您只能提供所需的其他转换器（因为Spring Boot使用相同的机制来提供其默认值）。最后，如果您通过提供自己的<code>@EnableWebMvc</code>配置选择退出Spring Boot默认MVC 配置，则可以完全控制并使用<code>getMessageConverters</code>from 手动完成所有操作 <code>WebMvcConfigurationSupport</code>。</p>
<p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java" target="_blank" rel="noopener"><code>WebMvcAutoConfiguration</code></a> 更多详细信息，请参阅 源代码。</p>
<h2 id="处理多部分文件上传"><a href="#处理多部分文件上传" class="headerlink" title="处理多部分文件上传"></a>处理多部分文件上传</h2><p>Spring Boot包含Servlet 3 <code>javax.servlet.http.Part</code>API以支持上传文件。默认情况下，Spring Boot配置Spring MVC，每个文件的最大大小为1MB，单个请求中的文件数据最大为10MB。您可以覆盖这些值，中间数据的存储位置（例如，到<code>/tmp</code> 目录），以及使用<code>MultipartProperties</code>类中公开的属性将数据刷新到磁盘的阈值。例如，如果要指定文件不受限制，请将<code>spring.servlet.multipart.max-file-size</code>属性设置为<code>-1</code>。</p>
<p>当您希望在Spring MVC控制器处理程序方法中接收多部分编码文件数据作为<code>@RequestParam</code>类型的注释参数时，多部分支持很有用<code>MultipartFile</code>。</p>
<p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/MultipartAutoConfiguration.java" target="_blank" rel="noopener"><code>MultipartAutoConfiguration</code></a> 详细信息，请参阅 源代码。</p>
<blockquote>
<p>建议使用容器的内置支持进行分段上传，而不是引入其他依赖项，例如Apache Commons File Upload。</p>
</blockquote>
<h2 id="关闭Spring-MVC-DispatcherServlet"><a href="#关闭Spring-MVC-DispatcherServlet" class="headerlink" title="关闭Spring MVC DispatcherServlet"></a>关闭Spring MVC DispatcherServlet</h2><p>默认情况下，所有内容都是从应用程序的根目录（<code>/</code>）提供的。如果您希望映射到其他路径，可以按如下方式配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.servlet.path=/acme</span><br></pre></td></tr></table></figure>
<p>如果你有额外的servlet，你可以声明一个<code>@Bean</code>类型<code>Servlet</code>或 <code>ServletRegistrationBean</code>每个servlet ，Spring Boot会将它们透明地注册到容器中。因为servlet是以这种方式注册的，所以可以将它们映射到<code>DispatcherServlet</code>不调用它的子上下文。</p>
<p>配置<code>DispatcherServlet</code>你自己是不寻常的，但如果你真的需要这样做，还必须提供一种 <code>@Bean</code>类型<code>DispatcherServletPath</code>来提供自定义的路径<code>DispatcherServlet</code>。</p>
<h2 id="关闭默认MVC配置"><a href="#关闭默认MVC配置" class="headerlink" title="关闭默认MVC配置"></a>关闭默认MVC配置</h2><p>完全控制MVC配置的最简单方法是为您自己 <code>@Configuration</code>提供<code>@EnableWebMvc</code>注释。这样做会将所有MVC配置留在您的手中。</p>
<h2 id="自定义ViewResolvers"><a href="#自定义ViewResolvers" class="headerlink" title="自定义ViewResolvers"></a>自定义ViewResolvers</h2><p>A<code>ViewResolver</code>是Spring MVC的一个核心组件，将视图名称转换 <code>@Controller</code>为实际<code>View</code>实现。请注意，<code>ViewResolvers</code>主要用于UI应用程序，而不是REST样式的服务（<code>View</code>不用于呈现 <code>@ResponseBody</code>）。有许多实现<code>ViewResolver</code>可供选择，而Spring本身并不反对你应该使用哪些实现。另一方面，Spring Boot会为您安装一个或两个，具体取决于它在类路径和应用程序上下文中找到的内容。它<code>DispatcherServlet</code>使用它在应用程序上下文中找到的所有解析器，依次尝试每个解析器直到获得结果，因此，如果添加自己的解析器，则必须知道顺序以及添加解析器的位置。</p>
<p><code>WebMvcAutoConfiguration</code>在<code>ViewResolvers</code>您的上下文中添加以下内容：</p>
<ul>
<li>一个<code>InternalResourceViewResolver</code>名为’defaultViewResolver’。这个可以通过使用<code>DefaultServlet</code>（包括静态资源和JSP页面，如果您使用它们）来查找可以呈现的物理资源。它将前缀和后缀应用于视图名称，然后在servlet上下文中查找具有该路径的物理资源（默认值为空，但可通过<code>spring.mvc.view.prefix</code>和访问外部配置 <code>spring.mvc.view.suffix</code>）。您可以通过提供相同类型的bean来覆盖它。</li>
<li>一个<code>BeanNameViewResolver</code>名为’beanNameViewResolver’。这是视图解析器链的一个有用成员，并获取与<code>View</code>正在解析的名称相同的任何bean 。没有必要覆盖或替换它。</li>
<li>一个<code>ContentNegotiatingViewResolver</code>名为“ViewResolver的”只如果有添加<strong>的</strong> 实际类型的豆类<code>View</code>存在。这是一个“主”解析器，委托给所有其他人，并尝试找到客户端发送的“Accept”HTTP标头的匹配项。有一个有用的 <a href="https://spring.io/blog/2013/06/03/content-negotiation-using-views" target="_blank" rel="noopener">博客 <code>ContentNegotiatingViewResolver</code></a>，您可能想要学习以了解更多信息，您也可以查看源代码以获取详细信息。您可以<code>ContentNegotiatingViewResolver</code>通过定义名为“viewResolver”的bean 来关闭自动配置 。</li>
<li>如果你使用Thymeleaf，你也有一个<code>ThymeleafViewResolver</code>名为’thymeleafViewResolver’。它通过使用前缀和后缀包围视图名称来查找资源。前缀是<code>spring.thymeleaf.prefix</code>，后缀是 <code>spring.thymeleaf.suffix</code>。前缀和后缀的值分别默认为“classpath：/ templates /”和“.html”。您可以<code>ThymeleafViewResolver</code>通过提供相同名称的bean 来覆盖 。</li>
<li>如果您使用FreeMarker，您还有一个<code>FreeMarkerViewResolver</code>名为’freeMarkerViewResolver’。它<code>spring.freemarker.templateLoaderPath</code>通过用前缀和后缀包围视图名称来查找加载器路径中的资源（外部化并具有默认值’classpath：/ templates /‘）。前缀外部<code>spring.freemarker.prefix</code>化为，后缀外部化为 <code>spring.freemarker.suffix</code>。前缀和后缀的默认值分别为空和“.ftl”。您可以<code>FreeMarkerViewResolver</code>通过提供相同名称的bean 来覆盖。<ul>
<li>如果您使用Groovy模板（实际上，如果<code>groovy-templates</code>在您的类路径中），您还有一个<code>GroovyMarkupViewResolver</code>名为<code>groovyMarkupViewResolver</code>。它通过用前缀和后缀（外部化为<code>spring.groovy.template.prefix</code>和<code>spring.groovy.template.suffix</code>）包围视图名称来查找加载器路径中的资源。前缀和后缀分别具有“classpath：/ templates /”和“.tpl”的默认值。您可以<code>GroovyMarkupViewResolver</code>通过提供相同名称的bean 来覆盖。</li>
</ul>
</li>
</ul>
<p>有关更多详细信息，请参阅以下部分：</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java" target="_blank" rel="noopener"><code>WebMvcAutoConfiguration</code></a></li>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java" target="_blank" rel="noopener"><code>ThymeleafAutoConfiguration</code></a></li>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java" target="_blank" rel="noopener"><code>FreeMarkerAutoConfiguration</code></a></li>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java" target="_blank" rel="noopener"><code>GroovyTemplateAutoConfiguration</code></a></li>
</ul>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-SpringMVC/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-嵌入式Web服务器/">使用SpringBoot-嵌入式Web服务器</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/http2/">http2</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/http/">http</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/web/">web</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/compression/">compression</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/ssl/">ssl</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/servlet/">servlet</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/filter/">filter</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/listener/">listener</a></div></div><div class="post-content"><div class="main-content content"><h1 id="嵌入式Web服务器"><a href="#嵌入式Web服务器" class="headerlink" title="嵌入式Web服务器"></a>嵌入式Web服务器</h1><p>每个Spring Boot Web应用程序都包含一个嵌入式Web服务器。此功能会导致许多操作方法问题，包括如何更改嵌入式服务器以及如何配置嵌入式服务器。本节回答了这些问题。</p>
<h2 id="使用其他Web服务器"><a href="#使用其他Web服务器" class="headerlink" title="使用其他Web服务器"></a>使用其他Web服务器</h2><p>许多Spring Boot启动器都包含默认的嵌入式容器。</p>
<ul>
<li>对于servlet堆栈应用程序，<code>spring-boot-starter-web</code>包括Tomcat <code>spring-boot-starter-tomcat</code>，但您可以使用<code>spring-boot-starter-jetty</code>或<code>spring-boot-starter-undertow</code>替代。</li>
<li>对于反应栈的应用，<code>spring-boot-starter-webflux</code>包括反应堆的Netty通过包括<code>spring-boot-starter-reactor-netty</code>，但你可以使用<code>spring-boot-starter-tomcat</code>， <code>spring-boot-starter-jetty</code>或<code>spring-boot-starter-undertow</code>代替。</li>
</ul>
<p>切换到其他HTTP服务器时，除了包含所需的依赖项外，还需要排除默认依赖项。Spring Boot为HTTP服务器提供单独的启动程序，以帮助使此过程尽可能简单。</p>
<p>以下Maven示例显示如何排除Tomcat并为Spring MVC包含Jetty：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 排除Tomcat依赖项 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用Jetty --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Servlet API的版本已被覆盖，因为与Tomcat 9和Undertow 2.0不同，Jetty 9.4不支持Servlet 4.0。</p>
</blockquote>
<p>以下Gradle示例显示如何排除Netty并包含Spring WebFlux的Undertow：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">	<span class="comment">//排除Reactor Netty</span></span><br><span class="line">	<span class="keyword">compile</span>.<span class="keyword">exclude</span> module: <span class="string">'spring-boot-starter-reactor-netty'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	<span class="keyword">compile</span> <span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span></span><br><span class="line">	<span class="comment">//使用Undertow</span></span><br><span class="line">	<span class="keyword">compile</span> <span class="string">'org.springframework.boot:spring-boot-starter-undertow'</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>spring-boot-starter-reactor-netty</code>需要使用<code>WebClient</code>该类，因此即使您需要包含不同的HTTP服务器，也可能需要依赖Netty。</p>
</blockquote>
<h2 id="禁用Web服务器"><a href="#禁用Web服务器" class="headerlink" title="禁用Web服务器"></a>禁用Web服务器</h2><p>如果您的类路径包含启动Web服务器所需的位，Spring Boot将自动启动它。要禁用此行为，请<code>WebApplicationType</code>在您的配置中进行配置<code>application.properties</code>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.main.web-application-type=none</span><br></pre></td></tr></table></figure>
<h2 id="更改HTTP端口"><a href="#更改HTTP端口" class="headerlink" title="更改HTTP端口"></a>更改HTTP端口</h2><p>在独立应用程序中，主HTTP端口默认为<code>8080</code>但可以设置 <code>server.port</code>（例如，<code>application.properties</code>作为System属性或作为System属性）。由于轻松绑定<code>Environment</code>值，您还可以使用<code>SERVER_PORT</code>（例如，作为OS环境变量）。</p>
<p>要完全关闭HTTP端点但仍然创建一个<code>WebApplicationContext</code>，请使用<code>server.port=-1</code>。（这样做有时对测试很有用。）</p>
<p>有关更多详细信息，请参阅“ Spring Boot功能”部分中的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-customizing-embedded-containers" target="_blank" rel="noopener">第29.4.4节”“自定义嵌入式Servlet容器”</a>或 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java" target="_blank" rel="noopener"><code>ServerProperties</code></a>源代码。</p>
<h2 id="使用随机未分配的HTTP端口"><a href="#使用随机未分配的HTTP端口" class="headerlink" title="使用随机未分配的HTTP端口"></a>使用随机未分配的HTTP端口</h2><p>要扫描一个空闲端口（使用OS本机来防止冲突），请使用<code>server.port=0</code>。</p>
<h2 id="在运行时发现HTTP端口"><a href="#在运行时发现HTTP端口" class="headerlink" title="在运行时发现HTTP端口"></a>在运行时发现HTTP端口</h2><p>您可以从日志输出或<code>ServletWebServerApplicationContext</code>通过其输出访问服务器正在运行的端口 <code>WebServer</code>。获得它并确保它已被初始化的最佳方法是添加一个<code>@Bean</code>类型， <code>ApplicationListener&lt;ServletWebServerInitializedEvent&gt;</code>并在发布时将容器拉出事件。</p>
<p>使用的测试<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>还可以使用<code>@LocalServerPort</code>注释将实际端口注入字段，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment=WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebIntegrationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	ServletWebServerApplicationContext server;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@LocalServerPort</span></span><br><span class="line">	<span class="keyword">int</span> port;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@LocalServerPort</code>是一个元注释<code>@Value(&quot;${local.server.port}&quot;)</code>。不要尝试在常规应用程序中注入端口。正如我们刚刚看到的那样，只有在容器初始化之后才设置该值。与测试相反，应用程序代码回调会尽早处理（在值实际可用之前）。</p>
</blockquote>
<h2 id="启用HTTP响应压缩"><a href="#启用HTTP响应压缩" class="headerlink" title="启用HTTP响应压缩"></a>启用HTTP响应压缩</h2><p>Jetty，Tomcat和Undertow支持HTTP响应压缩。它可以启用<code>application.properties</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.compression.enabled=true</span><br></pre></td></tr></table></figure>
<p>默认情况下，响应必须至少为2048字节，才能执行压缩。您可以通过设置<code>server.compression.min-response-size</code>属性来配置此行为 。</p>
<p>默认情况下，只有在内容类型为以下内容之一时才会压缩响应：</p>
<ul>
<li><code>text/html</code></li>
<li><code>text/xml</code></li>
<li><code>text/plain</code></li>
<li><code>text/css</code></li>
<li><code>text/javascript</code></li>
<li><code>application/javascript</code></li>
<li><code>application/json</code></li>
<li><code>application/xml</code></li>
</ul>
<p>您可以通过设置<code>server.compression.mime-types</code>属性来配置此行为。</p>
<h2 id="配置SSL"><a href="#配置SSL" class="headerlink" title="配置SSL"></a>配置SSL</h2><p>可以通过设置各种<code>server.ssl.*</code>属性以声明方式配置SSL ，通常在<code>application.properties</code>或中<code>application.yml</code>。以下示例显示了在以下位置设置SSL属性<code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.port=8443</span><br><span class="line">server.ssl.key-store=classpath:keystore.jks</span><br><span class="line">server.ssl.key-store-password=secret</span><br><span class="line">server.ssl.key-password=another-secret</span><br></pre></td></tr></table></figure>
<p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/server/Ssl.java" target="_blank" rel="noopener"><code>Ssl</code></a>所有支持的属性的详细信息，请参阅。</p>
<p>使用上述示例之类的配置意味着应用程序不再支持端口8080上的普通HTTP连接器.Spring Boot不支持HTTP连接器和HTTPS连接器的配置<code>application.properties</code>。如果要同时使用两者，则需要以编程方式配置其中一个。我们建议使用 <code>application.properties</code>配置HTTPS，因为HTTP连接器更容易以编程方式配置。有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/spring-boot-sample-tomcat-multi-connectors" target="_blank" rel="noopener"><code>spring-boot-sample-tomcat-multi-connectors</code></a> 示例，请参阅 示例项目。</p>
<h2 id="配置HTTP-2"><a href="#配置HTTP-2" class="headerlink" title="配置HTTP / 2"></a>配置HTTP / 2</h2><p>您可以使用<code>server.http2.enabled</code>配置属性在Spring Boot应用程序中启用HTTP / 2支持 。此支持取决于所选的Web服务器和应用程序环境，因为JDK8不支持该协议。</p>
<blockquote>
<p>Spring Boot不支持<code>h2c</code>HTTP / 2协议的明文版本。因此，您必须先<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-ssl" target="_blank" rel="noopener">配置SSL</a>。</p>
</blockquote>
<h3 id="Undertow的HTTP-2"><a href="#Undertow的HTTP-2" class="headerlink" title="Undertow的HTTP / 2"></a>Undertow的HTTP / 2</h3><p>从Undertow 1.4.0+开始，支持HTTP / 2，对JDK8没有任何额外要求。</p>
<h3 id="Jetty的HTTP-2"><a href="#Jetty的HTTP-2" class="headerlink" title="Jetty的HTTP / 2"></a>Jetty的HTTP / 2</h3><p>从Jetty 9.4.8开始，<a href="https://www.conscrypt.org/" target="_blank" rel="noopener">Conscrypt库</a>也支持HTTP / 2 。要启用该支持，您的应用程序需要有两个额外的依赖项：<code>org.eclipse.jetty:jetty-alpn-conscrypt-server</code>和<code>org.eclipse.jetty.http2:http2-server</code>。</p>
<h3 id="Tomcat的HTTP-2"><a href="#Tomcat的HTTP-2" class="headerlink" title="Tomcat的HTTP / 2"></a>Tomcat的HTTP / 2</h3><p>Spring Boot默认使用Tomcat 9.0.x，它在使用JDK 9或更高版本时支持HTTP / 2开箱即用。或者，如果<code>libtcnative</code> 库及其依赖项安装在主机操作系统上，则可以在JDK 8上使用HTTP / 2 。</p>
<p>必须使库文件夹（如果尚未可用）到JVM库路径。您可以使用JVM参数来完成此操作 <code>-Djava.library.path=/usr/local/opt/tomcat-native/lib</code>。有关<a href="https://tomcat.apache.org/tomcat-9.0-doc/apr.html" target="_blank" rel="noopener">Tomcat官方文档的</a>更多 <a href="https://tomcat.apache.org/tomcat-9.0-doc/apr.html" target="_blank" rel="noopener">信息</a>。</p>
<p>在没有该本机支持的情况下在JDK 8上启动Tomcat 9.0.x会记录以下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 8787 --- [           main] o.a.coyote.http11.Http11NioProtocol      : The upgrade handler [org.apache.coyote.http2.Http2Protocol] for [h2] only supports upgrade via ALPN but has beenconfigured for the ["https-jsse-nio-8443"] connector that does not support ALPN.</span><br></pre></td></tr></table></figure>
<p>此错误不是致命错误，应用程序仍以HTTP / 1.1 SSL支持启动。</p>
<h3 id="Reactor-Netty的HTTP-2"><a href="#Reactor-Netty的HTTP-2" class="headerlink" title="Reactor Netty的HTTP / 2"></a>Reactor Netty的HTTP / 2</h3><p>在<code>spring-boot-webflux-starter</code>默认情况下，反应堆的Netty作为服务器使用。可以使用JDK 9或更高版本的JDK支持为Reactor Netty配置HTTP / 2。对于JDK 8环境或最佳运行时性能，此服务器还支持具有本机库的HTTP / 2。要启用它，您的应用程序需要具有其他依赖项。</p>
<p>Spring Boot管理<code>io.netty:netty-tcnative-boringssl-static</code>“超级jar” 的版本 ，包含所有平台的本机库。开发人员可以选择使用分类器仅导入所需的依赖项（请参阅<a href="http://netty.io/wiki/forked-tomcat-native.html" target="_blank" rel="noopener">Netty官方文档</a>）。</p>
<h2 id="配置Web服务器"><a href="#配置Web服务器" class="headerlink" title="配置Web服务器"></a>配置Web服务器</h2><p>通常，您应首先考虑使用众多可用配置键中的一个，并通过在您的<code>application.properties</code>（ <code>application.yml</code>或环境等）中添加新条目来自定义您的Web服务器，请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-discover-build-in-options-for-external-properties" target="_blank" rel="noopener">第77.8节”，“发现外部属性的内置选项”</a> “） 。该<code>server.*</code> 命名空间是非常有用的在这里，它包括命名空间一样<code>server.tomcat.*</code>，<code>server.jetty.*</code>和其他人，了解特定服务器的功能。请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">附录A，<em>常见应用程序属性</em></a>列表。</p>
<p>前面的部分介绍了许多常见用例，例如压缩，SSL或HTTP / 2。但是，如果您的用例不存在配置密钥，则应该查看 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/web/server/WebServerFactoryCustomizer.html" target="_blank" rel="noopener"><code>WebServerFactoryCustomizer</code></a>。您可以声明这样的组件并获得与您选择的服务器工厂相关的访问权限：您应该为所选服务器（Tomcat，Jetty，Reactor Netty，Undertow）和所选Web堆栈（Servlet或Reactive）选择变体。</p>
<p>以下示例适用于具有<code>spring-boot-starter-web</code>（Servlet堆栈）的Tomcat ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTomcatWebServerCustomizer</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">TomcatServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(TomcatServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// customize the factory here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外Spring Boot提供：</p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器</th>
<th style="text-align:center">Servlet Stack</th>
<th style="text-align:center">Reactive Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Tomcat的</td>
<td style="text-align:center"><code>TomcatServletWebServerFactory</code></td>
<td style="text-align:center"><code>TomcatReactiveWebServerFactory</code></td>
</tr>
<tr>
<td style="text-align:center">码头</td>
<td style="text-align:center"><code>JettyServletWebServerFactory</code></td>
<td style="text-align:center"><code>JettyReactiveWebServerFactory</code></td>
</tr>
<tr>
<td style="text-align:center">暗潮</td>
<td style="text-align:center"><code>UndertowServletWebServerFactory</code></td>
<td style="text-align:center"><code>UndertowReactiveWebServerFactory</code></td>
</tr>
<tr>
<td style="text-align:center">反应堆</td>
<td style="text-align:center">N / A</td>
<td style="text-align:center"><code>NettyReactiveWebServerFactory</code></td>
</tr>
</tbody>
</table>
<p>一旦您有权访问a <code>WebServerFactory</code>，您通常可以向其添加定制器以配置特定部件，例如连接器，服务器资源或服务器本身 - 所有这些都使用特定于服务器的API。</p>
<p>作为最后的手段，您还可以声明自己的<code>WebServerFactory</code>组件，它将覆盖Spring Boot提供的组件。在这种情况下，您不能再依赖<code>server</code>命名空间中的配置属性。</p>
<h2 id="向应用程序添加Servlet，Filter或Listener"><a href="#向应用程序添加Servlet，Filter或Listener" class="headerlink" title="向应用程序添加Servlet，Filter或Listener"></a>向应用程序添加Servlet，Filter或Listener</h2><p>在servlet堆栈应用程序中，即使用<code>spring-boot-starter-web</code>，有两种方法可以向应用程序添加<code>Servlet</code>，<code>Filter</code>和<code>ServletContextListener</code>，以及Servlet API支持的其他侦听器：</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-add-a-servlet-filter-or-listener-as-spring-bean" target="_blank" rel="noopener">部分78.10.1，“使用Spring Bean添加Servlet，过滤器或监听器”</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-add-a-servlet-filter-or-listener-using-scanning" target="_blank" rel="noopener">部分78.10.2，“使用类路径扫描添加Servlet，过滤器和监听器”</a></li>
</ul>
<h3 id="使用Spring-Bean添加"><a href="#使用Spring-Bean添加" class="headerlink" title="使用Spring Bean添加"></a>使用Spring Bean添加</h3><p>要添加<code>Servlet</code>，<code>Filter</code>或servlet <code>*Listener</code>使用的Spring bean，你必须提供一个<code>@Bean</code>它的定义。当您想要注入配置或依赖项时，这样做非常有用。但是，您必须非常小心，它们不会导致太多其他bean的初始化，因为它们必须在应用程序生命周期的早期安装在容器中。（例如，让它们依赖于您的<code>DataSource</code>或JPA配置并不是一个好主意。）您可以通过在首次使用而不是初始化时懒惰地初始化bean来解决此类限制。</p>
<p>在的情况下<code>Filters</code>和<code>Servlets</code>，还可以通过添加添加映射和初始化参数<code>FilterRegistrationBean</code>或<code>ServletRegistrationBean</code>代替或除了下面的部件。</p>
<blockquote>
<p>如果<code>dispatcherType</code>在过滤器注册中指定了no ，<code>REQUEST</code>则使用。这与Servlet规范的默认调度程序类型一致。</p>
</blockquote>
<p>像任何其他Spring bean一样，您可以定义Servlet过滤器bean的顺序; 请务必检查“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-embedded-container-servlets-filters-listeners-beans" target="_blank" rel="noopener">名为”将Servlet，过滤器和监听器注册为Spring Beans</a> “部分。</p>
<h4 id="禁用Servlet或过滤器的注册"><a href="#禁用Servlet或过滤器的注册" class="headerlink" title="禁用Servlet或过滤器的注册"></a>禁用Servlet或过滤器的注册</h4><p>正如<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-add-a-servlet-filter-or-listener-as-spring-bean" target="_blank" rel="noopener">前面所述</a>，任何 <code>Servlet</code>或<code>Filter</code>豆与servlet容器自动注册。要禁用特定<code>Filter</code>或<code>Servlet</code>bean的注册，请为其创建注册Bean并将其标记为已禁用，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">registration</span><span class="params">(MyFilter filter)</span> </span>&#123;</span><br><span class="line">	FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean(filter);</span><br><span class="line">	registration.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用类路径扫描添加"><a href="#使用类路径扫描添加" class="headerlink" title="使用类路径扫描添加"></a>使用类路径扫描添加</h3><p><code>@WebServlet</code>，<code>@WebFilter</code>和带<code>@WebListener</code>注释的类可以通过使用一个<code>@Configuration</code>类注释<code>@ServletComponentScan</code>并指定包含要注册的组件的包来自动注册嵌入式servlet容器。默认情况下，<code>@ServletComponentScan</code>从带注释的类的包中进行扫描。</p>
<h2 id="配置访问日志记录"><a href="#配置访问日志记录" class="headerlink" title="配置访问日志记录"></a>配置访问日志记录</h2><p>以通过各自的命名空间为Tomcat，Undertow和Jetty配置访问日志。</p>
<p>例如，以下设置使用<a href="https://tomcat.apache.org/tomcat-8.5-doc/config/valve.html#Access_Logging" target="_blank" rel="noopener">自定义模式</a>在Tomcat上记录访问权限 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.basedir=my-tomcat</span><br><span class="line">server.tomcat.accesslog.enabled=true</span><br><span class="line">server.tomcat.accesslog.pattern=%t %a &quot;%r&quot; %s (%D ms)</span><br></pre></td></tr></table></figure>
<p>日志存储在<code>logs</code>相对于应用程序工作目录的目录中。您可以通过设置<code>server.undertow.accesslog.directory</code>属性来自定义此位置 。</p>
<p>最后，Jetty的访问日志记录也可以配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.jetty.accesslog.enabled=true</span><br><span class="line">server.jetty.accesslog.filename=/var/log/jetty-access.log</span><br></pre></td></tr></table></figure>
<p>默认情况下，日志会重定向到<code>System.err</code>。有关更多详细信息，请参阅 <a href="https://www.eclipse.org/jetty/documentation/9.4.x/configuring-jetty-request-logs.html" target="_blank" rel="noopener">Jetty文档</a>。</p>
<h2 id="在前端代理服务器后面运行"><a href="#在前端代理服务器后面运行" class="headerlink" title="在前端代理服务器后面运行"></a>在前端代理服务器后面运行</h2><p>您的应用程序可能需要发送<code>302</code>重定向或使用绝对链接呈现内容。在代理后面运行时，调用者需要指向代理的链接，而不是托管应用程序的计算机的物理地址。通常，这种情况是通过与代理的合同来处理的，代理会添加标题以告诉后端如何构建自己的链接。</p>
<p>如果代理添加了常规<code>X-Forwarded-For</code>和<code>X-Forwarded-Proto</code>头文件（大多数代理服务器都这样做），则应该正确呈现绝对链接，前提<code>server.use-forward-headers</code>是<code>true</code>在您的中设置<code>application.properties</code>。</p>
<blockquote>
<p>如果您的应用程序在Cloud Foundry或Heroku中运行，则该 <code>server.use-forward-headers</code>属性默认为<code>true</code>。在所有其他情况下，默认为<code>false</code>。</p>
</blockquote>
<h3 id="自定义Tomcat的代理配置"><a href="#自定义Tomcat的代理配置" class="headerlink" title="自定义Tomcat的代理配置"></a>自定义Tomcat的代理配置</h3><p>如果使用Tomcat，还可以配置用于携带“转发”信息的标头名称，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.remote-ip-header=x-your-remote-ip-header</span><br><span class="line">server.tomcat.protocol-header=x-your-protocol-header</span><br></pre></td></tr></table></figure>
<p>Tomcat还配置了一个默认的正则表达式，该表达式匹配要信任的内部代理。默认情况下，IP地址中<code>10/8</code>，<code>192.168/16</code>， <code>169.254/16</code>和<code>127/8</code>是值得信赖的。您可以通过添加条目来自定义阀门的配置<code>application.properties</code>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.internal-proxies=192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仅当使用属性文件进行配置时，才需要双反斜杠。如果使用YAML，则单个反斜杠就足够了，并且值等于前面示例中显示的值<code>192\.168\.\d{1,3}\.\d{1,3}</code>。</p>
</blockquote>
<blockquote>
<p>您可以通过将其设置<code>internal-proxies</code>为空来信任所有代理（但在生产中不这样做）。</p>
</blockquote>
<p>您可以<code>RemoteIpValve</code>通过关闭自动关闭（为此，设置<code>server.use-forward-headers=false</code>）并在<code>TomcatServletWebServerFactory</code>bean中添加新的阀门实例来完全控制Tomcat的配置。</p>
<h2 id="使用Tomcat启用多个连接器"><a href="#使用Tomcat启用多个连接器" class="headerlink" title="使用Tomcat启用多个连接器"></a>使用Tomcat启用多个连接器</h2><p>可以添加<code>org.apache.catalina.connector.Connector</code>到 <code>TomcatServletWebServerFactory</code>，这可以允许多个连接器，包括HTTP和HTTPS连接器，显示在下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletWebServerFactory <span class="title">servletContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	TomcatServletWebServerFactory tomcat = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">	tomcat.addAdditionalTomcatConnectors(createSslConnector());</span><br><span class="line">	<span class="keyword">return</span> tomcat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connector <span class="title">createSslConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Connector connector = <span class="keyword">new</span> Connector(<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">	Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		File keystore = <span class="keyword">new</span> ClassPathResource(<span class="string">"keystore"</span>).getFile();</span><br><span class="line">		File truststore = <span class="keyword">new</span> ClassPathResource(<span class="string">"keystore"</span>).getFile();</span><br><span class="line">		connector.setScheme(<span class="string">"https"</span>);</span><br><span class="line">		connector.setSecure(<span class="keyword">true</span>);</span><br><span class="line">		connector.setPort(<span class="number">8443</span>);</span><br><span class="line">		protocol.setSSLEnabled(<span class="keyword">true</span>);</span><br><span class="line">		protocol.setKeystoreFile(keystore.getAbsolutePath());</span><br><span class="line">		protocol.setKeystorePass(<span class="string">"changeit"</span>);</span><br><span class="line">		protocol.setTruststoreFile(truststore.getAbsolutePath());</span><br><span class="line">		protocol.setTruststorePass(<span class="string">"changeit"</span>);</span><br><span class="line">		protocol.setKeyAlias(<span class="string">"apitester"</span>);</span><br><span class="line">		<span class="keyword">return</span> connector;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"can't access keystore: ["</span> + <span class="string">"keystore"</span></span><br><span class="line">				+ <span class="string">"] or truststore: ["</span> + <span class="string">"keystore"</span> + <span class="string">"]"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Tomcat的LegacyCookieProcessor"><a href="#使用Tomcat的LegacyCookieProcessor" class="headerlink" title="使用Tomcat的LegacyCookieProcessor"></a>使用Tomcat的LegacyCookieProcessor</h2><p>默认情况下，Spring Boot使用的嵌入式Tomcat不支持Cookie格式的“Version 0”，因此您可能会看到以下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: An invalid character [32] was present in the Cookie value</span><br></pre></td></tr></table></figure>
<p>如果可能的话，您应该考虑将代码更新为仅存储符合以后Cookie规范的值。但是，如果您无法更改cookie的写入方式，则可以将Tomcat配置为使用<code>LegacyCookieProcessor</code>。要切换到<code>LegacyCookieProcessor</code>，请使用<code>WebServerFactoryCustomizer</code>添加a 的 bean <code>TomcatContextCustomizer</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt;cookieProcessorCustomizer() &#123;</span><br><span class="line">	<span class="keyword">return</span> (factory) -&gt; factory.addContextCustomizers(</span><br><span class="line">			(context) -&gt; context.setCookieProcessor(<span class="keyword">new</span> LegacyCookieProcessor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Undertow启用多个侦听器"><a href="#使用Undertow启用多个侦听器" class="headerlink" title="使用Undertow启用多个侦听器"></a>使用Undertow启用多个侦听器</h2><p>一个添加<code>UndertowBuilderCustomizer</code>到<code>UndertowServletWebServerFactory</code>与收听添加到<code>Builder</code>，如图所示在下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UndertowServletWebServerFactory <span class="title">servletWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	UndertowServletWebServerFactory factory = <span class="keyword">new</span> UndertowServletWebServerFactory();</span><br><span class="line">	factory.addBuilderCustomizers(<span class="keyword">new</span> UndertowBuilderCustomizer() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">			builder.addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-ServerEndpoint创建WebSocket端点"><a href="#使用-ServerEndpoint创建WebSocket端点" class="headerlink" title="使用@ServerEndpoint创建WebSocket端点"></a>使用@ServerEndpoint创建WebSocket端点</h2><p>如果要在使用<code>@ServerEndpoint</code>嵌入式容器的Spring Boot应用程序中使用，则必须声明一个<code>ServerEndpointExporter</code> <code>@Bean</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面示例中显示的<code>@ServerEndpoint</code>bean使用基础WebSocket容器注册任何带注释的bean。当部署到独立的servlet容器时，此角色由servlet容器初始化程序执行，并且<code>ServerEndpointExporter</code>不需要该 bean。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-嵌入式Web服务器/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-属性和配置/">使用SpringBoot-属性和配置</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/properties/">properties</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/configuration/">configuration</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/maven/">maven</a></div></div><div class="post-content"><div class="main-content content"><h1 id="属性和配置-部分"><a href="#属性和配置-部分" class="headerlink" title="属性和配置(部分)"></a>属性和配置(部分)</h1><p>本节包括有关设置和读取属性和配置设置及其与Spring Boot应用程序交互的主题。</p>
<h2 id="在构建时自动展开属性"><a href="#在构建时自动展开属性" class="headerlink" title="在构建时自动展开属性"></a>在构建时自动展开属性</h2><p>您可以使用现有的构建配置自动扩展它们，而不是硬编码在项目的构建配置中也指定的某些属性。这在Maven和Gradle都是可行的。</p>
<h3 id="使用Maven自动扩展属性"><a href="#使用Maven自动扩展属性" class="headerlink" title="使用Maven自动扩展属性"></a>使用Maven自动扩展属性</h3><p>您可以使用资源过滤从Maven项目自动扩展属性。如果您使用<code>spring-boot-starter-parent</code>，则可以使用<code>@..@</code>占位符引用Maven“项目属性” ，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.encoding=@project.build.sourceEncoding@</span><br><span class="line">app.java.version=@java.version@</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有生产配置以这种方式过滤（换句话说，不应用过滤<code>src/test/resources</code>）。</p>
</blockquote>
<blockquote>
<p>如果启用该<code>addResources</code>标志，则<code>spring-boot:run</code>目标可以<code>src/main/resources</code>直接添加 到类路径（用于热重新加载）。这样做可以绕过资源过滤和此功能。相反，您可以使用<code>exec:java</code> 目标或自定义插件的配置。有关详细信息，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/maven-plugin/usage.html" target="_blank" rel="noopener">插件使用情况页面</a>。</p>
</blockquote>
<p>如果不使用起动机家长，你需要包括中引入下列元素<code>&lt;build/&gt;</code>的元素<code>pom.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>您还需要在内部包含以下元素<code>&lt;plugins/&gt;</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">delimiters</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">delimiter</span>&gt;</span>@<span class="tag">&lt;/<span class="name">delimiter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">delimiters</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">useDefaultDelimiters</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useDefaultDelimiters</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>useDefaultDelimiters</code>如果<code>${placeholder}</code>在配置中使用标准的Spring占位符（例如），则该属性很重要。如果该属性未设置为<code>false</code>，则可以通过构建扩展这些属性。</p>
</blockquote>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-属性和配置/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-配置HTTP-2/">使用SpringBoot-配置HTTP/2</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/http2/">http2</a></div></div><div class="post-content"><div class="main-content content"><h1 id="配置HTTP-2"><a href="#配置HTTP-2" class="headerlink" title="配置HTTP / 2"></a>配置HTTP / 2</h1><p>您可以使用<code>server.http2.enabled</code>配置属性在Spring Boot应用程序中启用HTTP / 2支持 。此支持取决于所选的Web服务器和应用程序环境，因为JDK8不支持该协议。</p>
<blockquote>
<p>Spring Boot不支持<code>h2c</code>HTTP / 2协议的明文版本。因此，您必须先<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-ssl" target="_blank" rel="noopener">配置SSL</a>。</p>
</blockquote>
<h2 id="Undertow的HTTP-2"><a href="#Undertow的HTTP-2" class="headerlink" title="Undertow的HTTP / 2"></a>Undertow的HTTP / 2</h2><p>从Undertow 1.4.0+开始，支持HTTP / 2，对JDK8没有任何额外要求。</p>
<h2 id="Jetty的HTTP-2"><a href="#Jetty的HTTP-2" class="headerlink" title="Jetty的HTTP / 2"></a>Jetty的HTTP / 2</h2><p>从Jetty 9.4.8开始，<a href="https://www.conscrypt.org/" target="_blank" rel="noopener">Conscrypt库</a>也支持HTTP / 2 。要启用该支持，您的应用程序需要有两个额外的依赖项：</p>
<ul>
<li><p><code>org.eclipse.jetty:jetty-alpn-conscrypt-server</code></p>
</li>
<li><p><code>org.eclipse.jetty.http2:http2-server</code></p>
</li>
</ul>
<h2 id="Tomcat的HTTP-2"><a href="#Tomcat的HTTP-2" class="headerlink" title="Tomcat的HTTP / 2"></a>Tomcat的HTTP / 2</h2><p>Spring Boot默认使用Tomcat 9.0.x，它在使用JDK 9或更高版本时支持HTTP / 2开箱即用。或者，如果<code>libtcnative</code> 库及其依赖项安装在主机操作系统上，则可以在JDK 8上使用HTTP / 2 。</p>
<p>必须使库文件夹（如果尚未可用）到JVM库路径。您可以使用JVM参数来完成此操作 <code>-Djava.library.path=/usr/local/opt/tomcat-native/lib</code>。有关<a href="https://tomcat.apache.org/tomcat-9.0-doc/apr.html" target="_blank" rel="noopener">Tomcat官方文档的</a>更多 <a href="https://tomcat.apache.org/tomcat-9.0-doc/apr.html" target="_blank" rel="noopener">信息</a>。</p>
<p>在没有该本机支持的情况下在JDK 8上启动Tomcat 9.0.x会记录以下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 8787 --- [           main] o.a.coyote.http11.Http11NioProtocol      : The upgrade handler [org.apache.coyote.http2.Http2Protocol] for [h2] only supports upgrade via ALPN but has beenconfigured for the ["https-jsse-nio-8443"] connector that does not support ALPN.</span><br></pre></td></tr></table></figure>
<p>此错误不是致命错误，应用程序仍以HTTP / 1.1 SSL支持启动。</p>
<h2 id="Reactor-Netty的HTTP-2"><a href="#Reactor-Netty的HTTP-2" class="headerlink" title="Reactor Netty的HTTP / 2"></a>Reactor Netty的HTTP / 2</h2><p>在<code>spring-boot-webflux-starter</code>默认情况下，反应堆的Netty作为服务器使用。可以使用JDK 9或更高版本的JDK支持为Reactor Netty配置HTTP / 2。对于JDK 8环境或最佳运行时性能，此服务器还支持具有本机库的HTTP / 2。要启用它，您的应用程序需要具有其他依赖项。</p>
<p>Spring Boot管理<code>io.netty:netty-tcnative-boringssl-static</code>“超级jar” 的版本 ，包含所有平台的本机库。开发人员可以选择使用分类器仅导入所需的依赖项（请参阅<a href="http://netty.io/wiki/forked-tomcat-native.html" target="_blank" rel="noopener">Netty官方文档</a>）。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-配置HTTP-2/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-通过HTTP进行监控和管理/">使用SpringBoot-通过HTTP进行监控和管理</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/http/">http</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/management/">management</a></div></div><div class="post-content"><div class="main-content content"><h1 id="通过HTTP进行监控和管理"><a href="#通过HTTP进行监控和管理" class="headerlink" title="通过HTTP进行监控和管理"></a>通过HTTP进行监控和管理</h1><p>如果您正在开发Web应用程序，则Spring Boot Actuator会自动配置所有已启用的端点以通过HTTP公开。默认约定是使用<code>id</code>前缀<code>/actuator</code>为URL路径的端点。例如，<code>health</code>暴露为<code>/actuator/health</code>。提示：Spring MVC，Spring WebFlux和Jersey本身支持Actuator。</p>
<h2 id="自定义管理端点路径"><a href="#自定义管理端点路径" class="headerlink" title="自定义管理端点路径"></a>自定义管理端点路径</h2><p>有时，定制管理端点的前缀很有用。例如，您的应用程序可能已<code>/actuator</code>用于其他目的。您可以使用该<code>management.endpoints.web.base-path</code>属性更改管理端点的前缀，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.base-path=/manage</span><br></pre></td></tr></table></figure>
<p>上面的<code>application.properties</code>示例将端点更改 <code>/actuator/{id}</code>为<code>/manage/{id}</code>（例如<code>/manage/info</code>）。</p>
<blockquote>
<p>除非管理端口已经被配置为 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-customizing-management-server-port" target="_blank" rel="noopener">通过使用不同的HTTP端口暴露端点</a>，<code>management.endpoints.web.base-path</code>相对于<code>server.servlet.context-path</code>。如果<code>management.server.port</code>配置， <code>management.endpoints.web.base-path</code>则相对于<code>management.server.servlet.context-path</code>。</p>
</blockquote>
<p>如果要将端点映射到其他路径，可以使用该 <code>management.endpoints.web.path-mapping</code>属性。</p>
<p>以下示例重新映射<code>/actuator/health</code>到<code>/healthcheck</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.base-path=/</span><br><span class="line">management.endpoints.web.path-mapping.health=healthcheck</span><br></pre></td></tr></table></figure>
<h2 id="自定义Management-Server端口"><a href="#自定义Management-Server端口" class="headerlink" title="自定义Management Server端口"></a>自定义Management Server端口</h2><p>使用默认HTTP端口公开管理端点是基于云的部署的明智选择。但是，如果您的应用程序在您自己的数据中心内运行，您可能更喜欢使用不同的HTTP端口公开端点。</p>
<p>您可以设置该<code>management.server.port</code>属性以更改HTTP端口，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.server.port=8081</span><br></pre></td></tr></table></figure>
<h2 id="配置管理特定的SSL"><a href="#配置管理特定的SSL" class="headerlink" title="配置管理特定的SSL"></a>配置管理特定的SSL</h2><p>配置为使用自定义端口时，还可以使用各种<code>management.server.ssl.*</code>属性为管理服务器配置自己的SSL 。例如，这样做可以在主应用程序使用HTTPS时通过HTTP使管理服务器可用，如以下属性设置所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8443</span><br><span class="line">server.ssl.enabled=true</span><br><span class="line">server.ssl.key-store=classpath:store.jks</span><br><span class="line">server.ssl.key-password=secret</span><br><span class="line">management.server.port=8080</span><br><span class="line">management.server.ssl.enabled=false</span><br></pre></td></tr></table></figure>
<p>或者，主服务器和管理服务器都可以使用SSL但具有不同的密钥库，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.port=8443</span><br><span class="line">server.ssl.enabled=true</span><br><span class="line">server.ssl.key-store=classpath:main.jks</span><br><span class="line">server.ssl.key-password=secret</span><br><span class="line">management.server.port=8080</span><br><span class="line">management.server.ssl.enabled=true</span><br><span class="line">management.server.ssl.key-store=classpath:management.jks</span><br><span class="line">management.server.ssl.key-password=secret</span><br></pre></td></tr></table></figure>
<h2 id="自定义管理服务器地址"><a href="#自定义管理服务器地址" class="headerlink" title="自定义管理服务器地址"></a>自定义管理服务器地址</h2><p>您可以通过设置<code>management.server.address</code>属性来自定义管理端点可用的地址。如果您只想在内部或面向操作的网络上侦听或仅侦听来自的连接，那么这样做会非常有用 <code>localhost</code>。</p>
<blockquote>
<p>仅当端口与主服务器端口不同时，才能侦听不同的地址。</p>
</blockquote>
<p>以下示例<code>application.properties</code>不允许远程管理连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.server.port=8081</span><br><span class="line">management.server.address=127.0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="禁用HTTP端点"><a href="#禁用HTTP端点" class="headerlink" title="禁用HTTP端点"></a>禁用HTTP端点</h2><p>如果您不想通过HTTP公开端点，可以将管理端口设置为 <code>-1</code>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.server.port=-1</span><br></pre></td></tr></table></figure>
<p>这也可以使用<code>management.endpoints.web.exposure.exclude</code>属性来实现，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.exclude=*</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-通过HTTP进行监控和管理/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-endpoints/">使用SpringBoot-endpoints</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/endpoint/">endpoint</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h1><p>通过执行器端点，您可以监控应用程序并与之交互。Spring Boot包含许多内置端点，允许您添加自己的端点。例如， <code>health</code>端点提供基本的应用程序健康信息。</p>
<p>可以<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-enabling-endpoints" target="_blank" rel="noopener">启用或禁用</a>每个端点。它控制是否创建端点并且其bean存在于应用程序上下文中。要进行远程访问，还必须<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints" target="_blank" rel="noopener">通过JMX或HTTP公开</a>端点 。大多数应用程序选择HTTP，其中端点的ID以及前缀<code>/actuator</code> 映射到URL。例如，默认情况下，<code>health</code>端点映射到 <code>/actuator/health</code>。</p>
<p>可以使用以下与技术无关的端点：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认情况下启用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>auditevents</code></td>
<td style="text-align:center">公开当前应用程序的审核事件信息。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>beans</code></td>
<td style="text-align:center">显示应用程序中所有Spring bean的完整列表。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>caches</code></td>
<td style="text-align:center">暴露可用的缓存。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>conditions</code></td>
<td style="text-align:center">显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>configprops</code></td>
<td style="text-align:center">显示所有的整理列表<code>@ConfigurationProperties</code>。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>env</code></td>
<td style="text-align:center">露出Spring的属性<code>ConfigurableEnvironment</code>。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>flyway</code></td>
<td style="text-align:center">显示已应用的任何Flyway数据库迁移。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>health</code></td>
<td style="text-align:center">显示应用健康信息。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>httptrace</code></td>
<td style="text-align:center">显示HTTP跟踪信息（默认情况下，最后100个HTTP请求 - 响应交换）。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>info</code></td>
<td style="text-align:center">显示任意应用信息。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>integrationgraph</code></td>
<td style="text-align:center">显示Spring Integration图。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>loggers</code></td>
<td style="text-align:center">显示和修改应用程序中记录器的配置。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>liquibase</code></td>
<td style="text-align:center">显示已应用的任何Liquibase数据库迁移。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>metrics</code></td>
<td style="text-align:center">显示当前应用程序的“指标”信息。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>mappings</code></td>
<td style="text-align:center">显示所有<code>@RequestMapping</code>路径的整理列表。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>scheduledtasks</code></td>
<td style="text-align:center">显示应用程序中的计划任务。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>sessions</code></td>
<td style="text-align:center">允许从Spring Session支持的会话存储中检索和删除用户会话。使用Spring Session对响应式Web应用程序的支持时不可用。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>shutdown</code></td>
<td style="text-align:center">允许应用程序正常关闭。</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>threaddump</code></td>
<td style="text-align:center">执行线程转储。</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<p>如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认情况下启用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>heapdump</code></td>
<td style="text-align:center">返回<code>hprof</code>堆转储文件。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>jolokia</code></td>
<td style="text-align:center">通过HTTP公开JMX bean（当Jolokia在类路径上时，不适用于WebFlux）。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>logfile</code></td>
<td style="text-align:center">返回日志文件的内容（如果已设置<code>logging.file</code>或<code>logging.path</code>属性）。支持使用HTTP <code>Range</code>标头检索部分日志文件的内容。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>prometheus</code></td>
<td style="text-align:center">以可以由Prometheus服务器抓取的格式公开指标。</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<p>要了解有关Actuator端点及其请求和响应格式的更多信息，请参阅单独的API文档（<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//html" target="_blank" rel="noopener">HTML</a>或 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf" target="_blank" rel="noopener">PDF</a>）。</p>
<h2 id="启用端点"><a href="#启用端点" class="headerlink" title="启用端点"></a>启用端点</h2><p>默认情况下，<code>shutdown</code>启用除除以外的所有端点。要配置端点的启用，请使用其<code>management.endpoint.&lt;id&gt;.enabled</code>属性。以下示例启用<code>shutdown</code>端点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoint.shutdown.enabled=true</span><br></pre></td></tr></table></figure>
<p>如果您希望端点启用是选择加入而不是选择退出，请将该<code>management.endpoints.enabled-by-default</code>属性设置 为<code>false</code>并使用各个端点 <code>enabled</code>属性重新加入。以下示例启用<code>info</code>端点并禁用所有其他端点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.enabled-by-default=false</span><br><span class="line">management.endpoint.info.enabled=true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>已完全从应用程序上下文中删除已禁用的端点。如果只想更改端点所暴露的技术，请改用 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints" target="_blank" rel="noopener"><code>include</code>和<code>exclude</code>属性</a> 。</p>
</blockquote>
<h2 id="公开端点"><a href="#公开端点" class="headerlink" title="公开端点"></a>公开端点</h2><p>由于端点可能包含敏感信息，因此应仔细考虑何时公开它们。下表显示了内置端点的默认曝光：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">JMX</th>
<th style="text-align:center">WEB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>auditevents</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>beans</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>caches</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>conditions</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>configprops</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>env</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>flyway</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>health</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>heapdump</code></td>
<td style="text-align:center">N / A</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>httptrace</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>info</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>integrationgraph</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>jolokia</code></td>
<td style="text-align:center">N / A</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>logfile</code></td>
<td style="text-align:center">N / A</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>loggers</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>liquibase</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>metrics</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>mappings</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>prometheus</code></td>
<td style="text-align:center">N / A</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>scheduledtasks</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>sessions</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>shutdown</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>threaddump</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
</tbody>
</table>
<p>要更改端点暴露，使用下面的特定技术<code>include</code>和 <code>exclude</code>特性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">默认</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>management.endpoints.jmx.exposure.exclude</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>management.endpoints.jmx.exposure.include</code></td>
<td style="text-align:center"><code>*</code></td>
</tr>
<tr>
<td style="text-align:center"><code>management.endpoints.web.exposure.exclude</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>management.endpoints.web.exposure.include</code></td>
<td style="text-align:center"><code>info, health</code></td>
</tr>
</tbody>
</table>
<p>该<code>include</code>属性列出了公开的端点的ID。该<code>exclude</code> 属性列出了不应公开的端点的ID。该<code>exclude</code> 属性优先于该<code>include</code>属性。无论<code>include</code>和<code>exclude</code> 性能可与端点ID列表进行配置。</p>
<p>例如，要停止通过JMX公开所有端点并仅显示端点<code>health</code>和 <code>info</code>端点，请使用以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.jmx.exposure.include=health,info</span><br></pre></td></tr></table></figure>
<p><code>*</code>可用于选择所有端点。例如，要通过HTTP公开除了<code>env</code>和<code>beans</code>端点之外的所有内容，请使用以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoints.web.exposure.exclude=env,beans</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>*</code> 在YAML中有特殊含义，因此如果要包含（或排除）所有端点，请务必添加引号，如以下示例所示：</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您的申请是公开的，我们强烈建议您也 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-security" target="_blank" rel="noopener">保护您的终端</a>。</p>
</blockquote>
<blockquote>
<p>如果要在公开端点时实现自己的策略，可以注册<code>EndpointFilter</code>bean。</p>
</blockquote>
<h2 id="保护HTTP端点"><a href="#保护HTTP端点" class="headerlink" title="保护HTTP端点"></a>保护HTTP端点</h2><p>您应该像使用任何其他敏感URL一样注意保护HTTP端点。如果存在Spring Security，则默认使用Spring Security的内容协商策略来保护端点。例如，如果您希望为HTTP端点配置自定义安全性，只允许具有特定角色的用户访问它们，Spring Boot提供了一些<code>RequestMatcher</code>可以与Spring Security结合使用的方便对象。</p>
<p>典型的Spring Security配置可能类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActuatorSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class="line">				.anyRequest().hasRole(<span class="string">"ENDPOINT_ADMIN"</span>)</span><br><span class="line">				.and()</span><br><span class="line">			.httpBasic();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例用于<code>EndpointRequest.toAnyEndpoint()</code>将请求与任何端点进行匹配，然后确保所有端点都具有该<code>ENDPOINT_ADMIN</code>角色。其他几种匹配方法也可用<code>EndpointRequest</code>。请参阅API文档（<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//html" target="_blank" rel="noopener">HTML</a>或 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf" target="_blank" rel="noopener">PDF</a>详细信息，）。</p>
<p>如果在防火墙后面部署应用程序，您可能希望无需身份验证即可访问所有执行器端点。您可以通过更改<code>management.endpoints.web.exposure.include</code>属性来执行此操作 ，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anagement.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure>
<p>此外，如果存在Spring Security，则需要添加自定义安全配置，以允许对端点进行未经身份验证的访问，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActuatorSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class="line">			.anyRequest().permitAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置端点"><a href="#配置端点" class="headerlink" title="配置端点"></a>配置端点</h2><p>端点自动缓存对不带任何参数的读取操作的响应。要配置端点缓存响应的时间量，请使用其<code>cache.time-to-live</code>属性。以下示例将<code>beans</code>端点缓存的生存时间设置为10秒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoint.beans.cache.time-to-live=10s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前缀<code>management.endpoint.&lt;name&gt;</code>用于唯一标识正在配置的端点。</p>
</blockquote>
<blockquote>
<p>在进行经过身份验证的HTTP请求时，Principal会将其视为端点的输入，因此不会缓存响应。</p>
</blockquote>
<h2 id="用于执行器Web端点的超媒体"><a href="#用于执行器Web端点的超媒体" class="headerlink" title="用于执行器Web端点的超媒体"></a>用于执行器Web端点的超媒体</h2><p>添加了“发现页面”，其中包含指向所有端点的链接。<code>/actuator</code>默认情况下，“发现页面”可用。</p>
<p>配置自定义管理上下文路径后，“发现页面”会自动从<code>/actuator</code>管理上下文的根目录移动。例如，如果管理上下文路径是<code>/management</code>，则可以从中获取发现页面<code>/management</code>。当管理上下文路径设置为时<code>/</code>，将禁用发现页面以防止与其他映射冲突的可能性。</p>
<h2 id="CORS支持"><a href="#CORS支持" class="headerlink" title="CORS支持"></a>CORS支持</h2><p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank" rel="noopener">跨源资源共享</a> （CORS）是一种<a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener">W3C规范</a>，允许您以灵活的方式指定授权的跨域请求类型。如果您使用Spring MVC或Spring WebFlux，则可以配置Actuator的Web端点以支持此类方案。</p>
<p>默认情况下禁用CORS支持，并且仅<code>management.endpoints.web.cors.allowed-origins</code>在设置了属性后才启用CORS支持 。以下配置允许<code>GET</code>和<code>POST</code>来自<code>example.com</code>域的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.cors.allowed-origins=http://example.com</span><br><span class="line">management.endpoints.web.cors.allowed-methods=GET,POST</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关 选项的完整列表，请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java" target="_blank" rel="noopener">CorsEndpointProperties</a>。</p>
</blockquote>
<h2 id="实现自定义端点"><a href="#实现自定义端点" class="headerlink" title="实现自定义端点"></a>实现自定义端点</h2><p>如果您添加带<code>@Bean</code>注释的<code>@Endpoint</code>注释<code>@ReadOperation</code>，通过JMX 注释的任何方法 <code>@WriteOperation</code>，或者<code>@DeleteOperation</code>通过JMX自动公开，以及在Web应用程序中也通过HTTP 添加注释。可以使用Jersey，Spring MVC或Spring WebFlux通过HTTP公开端点。</p>
<p>您还可以使用<code>@JmxEndpoint</code>或 编写特定于技术的端点<code>@WebEndpoint</code>。这些端点仅限于各自的技术。例如，<code>@WebEndpoint</code>仅通过HTTP而不是通过JMX公开。</p>
<p>您可以使用<code>@EndpointWebExtension</code>和 编写特定于技术的扩展<code>@EndpointJmxExtension</code>。通过这些注释，您可以提供特定于技术的操作来扩充现有端点。</p>
<p>最后，如果您需要访问特定于Web框架的功能，则可以实现Servlet或Spring <code>@Controller</code>和<code>@RestController</code>端点，但代价是它们不能通过JMX或使用不同的Web框架。</p>
<h3 id="接收输入"><a href="#接收输入" class="headerlink" title="接收输入"></a>接收输入</h3><p>端点上的操作通过其参数接收输入。通过Web公开时，这些参数的值取自URL的查询参数和JSON请求体。通过JMX公开时，参数将映射到MBean操作的参数。默认情况下需要参数。它们可以通过注释使它们成为可选的<a href="mailto:`@org.springframework.lang.Nullable" target="_blank" rel="noopener">`@org.springframework.lang.Nullable</a>`。</p>
<p>JSON请求正文中的每个根属性都可以映射到端点的参数。考虑以下JSON请求正文：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span>: <span class="string">"test"</span>,</span><br><span class="line">	<span class="attr">"counter"</span>: <span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以用于调用，需要一个写操作<code>String name</code>和<code>int counter</code> 参数。</p>
<blockquote>
<p>由于端点与技术无关，因此只能在方法签名中指定简单类型。特别是不支持使用定义<code>name</code>和<code>counter</code>属性的自定义类型声明单个参数 。</p>
</blockquote>
<blockquote>
<p>为了允许输入映射到操作方法的参数，应该编译实现端点的Java代码<code>-parameters</code>，并且应该编译实现端点的Kotlin代码<code>-java-parameters</code>。如果您使用的是Spring Boot的Gradle插件，或者您正在使用Maven和 <code>spring-boot-starter-parent</code>。</p>
</blockquote>
<h4 id="输入类型转换"><a href="#输入类型转换" class="headerlink" title="输入类型转换"></a>输入类型转换</h4><p>如有必要，传递给端点操作方法的参数将自动转换为所需类型。在调用操作方法之前，通过JMX或HTTP请求接收的输入将使用实例转换为所需类型<code>ApplicationConversionService</code>。</p>
<h3 id="自定义Web端点"><a href="#自定义Web端点" class="headerlink" title="自定义Web端点"></a>自定义Web端点</h3><p>操作<code>@Endpoint</code>，<code>@WebEndpoint</code>或者<code>@EndpointWebExtension</code>使用新泽西州，Spring MVC，或Spring WebFlux通过HTTP自动曝光。</p>
<h4 id="Web端点请求谓词"><a href="#Web端点请求谓词" class="headerlink" title="Web端点请求谓词"></a>Web端点请求谓词</h4><p>为Web暴露的端点上的每个操作自动生成请求谓词。</p>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>谓词的路径由端点的ID和Web暴露的端点的基本路径确定。默认基本路径是<code>/actuator</code>。例如，具有ID的端点<code>sessions</code>将<code>/actuator/sessions</code>用作谓词中的路径。</p>
<p>可以通过用操作方法的一个或多个参数注释来进一步定制路径<code>@Selector</code>。这样的参数作为路径变量添加到路径谓词中。调用端点操作时，变量的值将传递给操作方法。</p>
<h4 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h4><p>谓词的HTTP方法由操作类型决定，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">HTTP Method</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@ReadOperation</code></td>
<td style="text-align:center"><code>GET</code></td>
</tr>
<tr>
<td style="text-align:center"><code>@WriteOperation</code></td>
<td style="text-align:center"><code>POST</code></td>
</tr>
<tr>
<td style="text-align:center"><code>@DeleteOperation</code></td>
<td style="text-align:center"><code>DELETE</code></td>
</tr>
</tbody>
</table>
<h4 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h4><p>对于使用请求主体的<code>@WriteOperation</code>（HTTP <code>POST</code>），谓词的consumemes子句是<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。对于所有其他操作，consumemes子句为空。</p>
<h4 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h4><p>的产生谓词子句可以由被确定<code>produces</code>的属性 <code>@DeleteOperation</code>，<code>@ReadOperation</code>和<code>@WriteOperation</code>注解。该属性是可选的。如果未使用，则自动确定produce子句。</p>
<p>如果操作方法返回<code>void</code>或者<code>Void</code>produce子句为空。如果操作方法返回a <code>org.springframework.core.io.Resource</code>，则generate子句为<code>application/octet-stream</code>。对于所有其他操作，produce子句是 <code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。</p>
<h4 id="Web端点响应状态"><a href="#Web端点响应状态" class="headerlink" title="Web端点响应状态"></a>Web端点响应状态</h4><p>端点操作的默认响应状态取决于操作类型（读取，写入或删除）以及操作返回的内容（如果有）。</p>
<p>A <code>@ReadOperation</code>返回一个值，响应状态为200（OK）。如果它未返回值，则响应状态将为404（未找到）。</p>
<p>如果a <code>@WriteOperation</code>或<code>@DeleteOperation</code>返回值，则响应状态将为200（OK）。如果它没有返回值，则响应状态将为204（无内容）。</p>
<p>如果在没有必需参数的情况下调用操作，或者使用无法转换为所需类型的参数，则不会调用操作方法，并且响应状态将为400（错误请求）。</p>
<h4 id="Web端点范围请求"><a href="#Web端点范围请求" class="headerlink" title="Web端点范围请求"></a>Web端点范围请求</h4><p>HTTP范围请求可用于请求部分HTTP资源。使用Spring MVC或Spring Web Flux时，返回<code>org.springframework.core.io.Resource</code> 自动支持范围请求的操作。</p>
<blockquote>
<p>使用Jersey时不支持范围请求。</p>
</blockquote>
<h4 id="Web端点安全"><a href="#Web端点安全" class="headerlink" title="Web端点安全"></a>Web端点安全</h4><p>Web端点或特定于Web的端点扩展上的操作可以接收当前<code>java.security.Principal</code>或 <code>org.springframework.boot.actuate.endpoint.SecurityContext</code>作为方法参数。前者通常与<code>@Nullable</code>经过身份验证和未经身份验证的用户一起使用以提供不同的行为。后者通常用于使用其<code>isUserInRole(String)</code>方法执行授权检查。</p>
<h3 id="Servlet端点"><a href="#Servlet端点" class="headerlink" title="Servlet端点"></a>Servlet端点</h3><p><code>Servlet</code>可以公开为通过实施与注释的一个类的端点 <code>@ServletEndpoint</code>也实现<code>Supplier&lt;EndpointServlet&gt;</code>。Servlet端点提供与Servlet容器更深层次的集成，但代价是可移植性。它们旨在用于将现有的公开<code>Servlet</code>作为端点。对于新端点，应尽可能优先使用<code>@Endpoint</code>和<code>@WebEndpoint</code>注释。</p>
<h3 id="控制器端点"><a href="#控制器端点" class="headerlink" title="控制器端点"></a>控制器端点</h3><p><code>@ControllerEndpoint</code>并且<code>@RestControllerEndpoint</code>可用于实现仅由Spring MVC或Spring WebFlux公开的端点。使用Spring MVC和Spring WebFlux的标准注释（例如<code>@RequestMapping</code> 和）映射方法<code>@GetMapping</code>，并将端点的ID用作路径的前缀。控制器端点提供与Spring的Web框架更深层次的集成，但代价是可移植性。的<code>@Endpoint</code>和<code>@WebEndpoint</code>注解应当优选只要有可能。</p>
<h2 id="健康信息"><a href="#健康信息" class="headerlink" title="健康信息"></a>健康信息</h2><p>您可以使用运行状况信息来检查正在运行的应用程序的状态。监视软件经常使用它在生产系统出现故障时提醒某人。<code>health</code>端点公开的信息取决于<code>management.endpoint.health.show-details</code>可以使用以下值之一配置的 属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>never</code></td>
<td style="text-align:center">细节永远不会显示。</td>
</tr>
<tr>
<td style="text-align:center"><code>when-authorized</code></td>
<td style="text-align:center">详细信息仅向授权用户显示。可以使用配置授权角色 <code>management.endpoint.health.roles</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>always</code></td>
<td style="text-align:center">向所有用户显示详细信息。</td>
</tr>
</tbody>
</table>
<p>默认值为<code>never</code>。当用户处于一个或多个端点的角色时，将被视为已获得授权。如果端点没有配置角色（默认值），则认为所有经过身份验证的用户都已获得授权。可以使用<code>management.endpoint.health.roles</code>属性配置角色。</p>
<blockquote>
<p>如果您已保护应用程序并希望使用<code>always</code>，则安全配置必须允许对经过身份验证和未经身份验证的用户访问运行状况终结点。</p>
</blockquote>
<p>健康信息是从a的内容中收集的 （默认情况下，所有 实例都在你的Spring中定义.Spring Boot包括一些自动配置 ，你也可以编写自己的。默认情况下，最终的系统状态是通过对状态进行排序得出的从每个 基于状态的有序列表上。在排序列表中的第一个状态用作总体运行状况。如果没有回报是已知的一个状态 ，一个是使用状态。</p>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicatorRegistry.java" target="_blank" rel="noopener"><code>HealthIndicatorRegistry</code></a><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java" target="_blank" rel="noopener"><code>HealthIndicator</code></a><code>ApplicationContext</code> <code>HealthIndicators</code> <code>HealthAggregator</code> <code>HealthIndicator</code> <code>HealthIndicator</code> <code>HealthAggregator</code> <code>UNKNOWN</code></p>
<blockquote>
<p>该<code>HealthIndicatorRegistry</code>可用于注册和在运行时注销卫生指标。</p>
</blockquote>
<h3 id="自动配置的HealthIndicators"><a href="#自动配置的HealthIndicators" class="headerlink" title="自动配置的HealthIndicators"></a>自动配置的HealthIndicators</h3><p><code>HealthIndicators</code>适当时，Spring Boot会自动配置以下内容：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraHealthIndicator.java" target="_blank" rel="noopener"><code>CassandraHealthIndicator</code></a></td>
<td style="text-align:center">检查Cassandra数据库是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseHealthIndicator.java" target="_blank" rel="noopener"><code>CouchbaseHealthIndicator</code></a></td>
<td style="text-align:center">检查Couchbase群集是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/system/DiskSpaceHealthIndicator.java" target="_blank" rel="noopener"><code>DiskSpaceHealthIndicator</code></a></td>
<td style="text-align:center">检查磁盘空间不足。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jdbc/DataSourceHealthIndicator.java" target="_blank" rel="noopener"><code>DataSourceHealthIndicator</code></a></td>
<td style="text-align:center">检查是否可以获得连接<code>DataSource</code>。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchHealthIndicator.java" target="_blank" rel="noopener"><code>ElasticsearchHealthIndicator</code></a></td>
<td style="text-align:center">检查Elasticsearch集群是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/influx/InfluxDbHealthIndicator.java" target="_blank" rel="noopener"><code>InfluxDbHealthIndicator</code></a></td>
<td style="text-align:center">检查InfluxDB服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jms/JmsHealthIndicator.java" target="_blank" rel="noopener"><code>JmsHealthIndicator</code></a></td>
<td style="text-align:center">检查JMS代理是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mail/MailHealthIndicator.java" target="_blank" rel="noopener"><code>MailHealthIndicator</code></a></td>
<td style="text-align:center">检查邮件服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoHealthIndicator.java" target="_blank" rel="noopener"><code>MongoHealthIndicator</code></a></td>
<td style="text-align:center">检查Mongo数据库是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jHealthIndicator.java" target="_blank" rel="noopener"><code>Neo4jHealthIndicator</code></a></td>
<td style="text-align:center">检查Neo4j服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.java" target="_blank" rel="noopener"><code>RabbitHealthIndicator</code></a></td>
<td style="text-align:center">检查Rabbit服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisHealthIndicator.java" target="_blank" rel="noopener"><code>RedisHealthIndicator</code></a></td>
<td style="text-align:center">检查Redis服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/solr/SolrHealthIndicator.java" target="_blank" rel="noopener"><code>SolrHealthIndicator</code></a></td>
<td style="text-align:center">检查Solr服务器是否已启动。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>您可以通过设置<code>management.health.defaults.enabled</code> 属性来禁用它们。</p>
</blockquote>
<h3 id="编写自定义HealthIndicators"><a href="#编写自定义HealthIndicators" class="headerlink" title="编写自定义HealthIndicators"></a>编写自定义HealthIndicators</h3><p>要提供自定义运行状况信息，可以注册实现该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java" target="_blank" rel="noopener"><code>HealthIndicator</code></a>接口的Spring bean 。您需要提供<code>health()</code>方法的实现并返回<code>Health</code> 响应。的<code>Health</code>响应应该包括一个状态，并且可以任选地包括另外的细节被显示。以下代码显示了一个示例<code>HealthIndicator</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.Health;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> errorCode = check(); <span class="comment">// perform some specific health check</span></span><br><span class="line">		<span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> Health.down().withDetail(<span class="string">"Error Code"</span>, errorCode).build();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Health.up().build();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给定的标识符<code>HealthIndicator</code>是没有<code>HealthIndicator</code>后缀的bean的名称（ 如果存在）。在前面的示例中，健康信息在名为的条目中可用<code>my</code>。</p>
</blockquote>
<p>除了Spring Boot的预定义 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/Status.java" target="_blank" rel="noopener"><code>Status</code></a>类型之外，还可以 <code>Health</code>返回<code>Status</code>表示新系统状态的自定义。在这种情况下，<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthAggregator.java" target="_blank" rel="noopener"><code>HealthAggregator</code></a>还需要提供接口的自定义实现 ，或者必须使用<code>management.health.status.order</code>配置属性配置默认实现。</p>
<p>例如，假设在您的某个实现中使用了 <code>Status</code>带代码的新代码。要配置严重性顺序，请将以下属性添加到应用程序属性：<code>FATAL`</code>HealthIndicator`</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.health.status.order=FATAL, DOWN, OUT_OF_SERVICE, UNKNOWN, UP</span><br></pre></td></tr></table></figure>
<p>在响应中的HTTP状态代码反映总体健康状况（例如， <code>UP</code>映射到200，而<code>OUT_OF_SERVICE</code>并<code>DOWN</code>映射到503）。如果通过HTTP访问运行状况端点，则可能还需要注册自定义状态映射。例如，以下属性映射<code>FATAL</code>到503（服务不可用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.health.status.http-mapping.FATAL=503</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要更多控制，可以定义自己的<code>HealthStatusHttpMapper</code>bean。</p>
</blockquote>
<p>下表显示了内置状态的默认状态映射：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">映射</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">下</td>
<td style="text-align:center">SERVICE_UNAVAILABLE（503）</td>
</tr>
<tr>
<td style="text-align:center">停止服务</td>
<td style="text-align:center">SERVICE_UNAVAILABLE（503）</td>
</tr>
<tr>
<td style="text-align:center">UP</td>
<td style="text-align:center">默认情况下没有映射，因此http状态为200</td>
</tr>
<tr>
<td style="text-align:center">未知</td>
<td style="text-align:center">默认情况下没有映射，因此http状态为200</td>
</tr>
</tbody>
</table>
<h3 id="反应性健康指标"><a href="#反应性健康指标" class="headerlink" title="反应性健康指标"></a>反应性健康指标</h3><p>对于反应式应用程序（例如使用Spring WebFlux的应用程序），<code>ReactiveHealthIndicator</code> 提供了一个非阻塞的合同来获取应用程序运行状况。与传统类似<code>HealthIndicator</code>，健康信息是从a的内容中收集的 （默认情况下，在您的。中定义的所有 和 实例都不会在弹性调度程序上执行不检查反应API的常规 。<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicatorRegistry.java" target="_blank" rel="noopener"><code>ReactiveHealthIndicatorRegistry</code></a><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java" target="_blank" rel="noopener"><code>HealthIndicator</code></a><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java" target="_blank" rel="noopener"> <code>ReactiveHealthIndicator</code></a><code>ApplicationContext</code> <code>HealthIndicator</code></p>
<blockquote>
<p>在响应式应用程序中，<code>ReactiveHealthIndicatorRegistry</code>可用于在运行时注册和取消注册运行状况指示器。</p>
</blockquote>
<p>要从反应式API提供自定义运行状况信息，您可以注册实现该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>ReactiveHealthIndicator</code></a> 接口的Spring bean 。以下代码显示了一个示例<code>ReactiveHealthIndicator</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactiveHealthIndicator</span> <span class="keyword">implements</span> <span class="title">ReactiveHealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;Health&gt; <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> doHealthCheck() <span class="comment">//执行一些返回Mono &lt;Health&gt; </span></span><br><span class="line">			.onErrorResume(ex -&gt; Mono.just(<span class="keyword">new</span> Health.Builder().down(ex).build())));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要自动处理错误，请考虑从中扩展 <code>AbstractReactiveHealthIndicator</code>。</p>
</blockquote>
<h3 id="自动配置的ReactiveHealthIndicators"><a href="#自动配置的ReactiveHealthIndicators" class="headerlink" title="自动配置的ReactiveHealthIndicators"></a>自动配置的ReactiveHealthIndicators</h3><p><code>ReactiveHealthIndicators</code>适当时，Spring Boot会自动配置以下内容：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>CassandraReactiveHealthIndicator</code></a></td>
<td style="text-align:center">检查Cassandra数据库是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>CouchbaseReactiveHealthIndicator</code></a></td>
<td style="text-align:center">检查Couchbase群集是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>MongoReactiveHealthIndicator</code></a></td>
<td style="text-align:center">检查Mongo数据库是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>RedisReactiveHealthIndicator</code></a></td>
<td style="text-align:center">检查Redis服务器是否已启动。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>必要时，反应指标取代常规指标。此外，任何 <code>HealthIndicator</code>未明确处理的内容都会自动换行。</p>
</blockquote>
<h2 id="应用信息"><a href="#应用信息" class="headerlink" title="应用信息"></a>应用信息</h2><p>应用程序信息公开从<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java" target="_blank" rel="noopener"><code>InfoContributor</code></a>您的中定义的所有bean 收集的各种信息 <code>ApplicationContext</code>。Spring Boot包含许多自动配置的<code>InfoContributor</code>bean，您可以编写自己的bean。</p>
<h3 id="自动配置的InfoContributors"><a href="#自动配置的InfoContributors" class="headerlink" title="自动配置的InfoContributors"></a>自动配置的InfoContributors</h3><p><code>InfoContributor</code>适当时，Spring Boot会自动配置以下bean：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java" target="_blank" rel="noopener"><code>EnvironmentInfoContributor</code></a></td>
<td style="text-align:center">暴露出钥匙<code>Environment</code>下面的任何<code>info</code>钥匙。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java" target="_blank" rel="noopener"><code>GitInfoContributor</code></a></td>
<td style="text-align:center">如果<code>git.properties</code>文件可用，则公开git信息。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java" target="_blank" rel="noopener"><code>BuildInfoContributor</code></a></td>
<td style="text-align:center">如果<code>META-INF/build-info.properties</code>文件可用，则公开构建信息。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>可以通过设置<code>management.info.defaults.enabled</code> 属性来禁用它们。</p>
</blockquote>
<h3 id="自定义应用程序信息"><a href="#自定义应用程序信息" class="headerlink" title="自定义应用程序信息"></a>自定义应用程序信息</h3><p>您可以<code>info</code>通过设置<code>info.*</code>Spring属性来自定义端点公开的数据。密钥<code>Environment</code>下的所有属性都会<code>info</code>自动显示。例如，您可以将以下设置添加到您的<code>application.properties</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.app.encoding=UTF-8</span><br><span class="line">info.app.java.source=1.8</span><br><span class="line">info.app.java.target=1.8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您可以<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-automatic-expansion" target="_blank" rel="noopener">在构建时扩展信息属性，</a>而不是对这些值进行硬编码 。</p>
<p>假设您使用Maven，您可以按如下方式重写前面的示例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.app.encoding=@project.build.sourceEncoding@</span><br><span class="line">info.app.java.source=@java.version@</span><br><span class="line">info.app.java.target=@java.version@</span><br></pre></td></tr></table></figure>
<h3 id="Git提交信息"><a href="#Git提交信息" class="headerlink" title="Git提交信息"></a>Git提交信息</h3><p><code>info</code>端点的另一个有用功能是它能够<code>git</code>在构建项目时发布有关源代码存储库状态的信息。如果 <code>GitProperties</code>豆可用，<code>git.branch</code>，<code>git.commit.id</code>，和<code>git.commit.time</code>属性暴露出来。</p>
<blockquote>
<p>一个<code>GitProperties</code>bean是自动配置，如果一个<code>git.properties</code>文件可在classpath的根目录。有关更多详细<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-git-info" target="_blank" rel="noopener">信息，</a>请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-git-info" target="_blank" rel="noopener">生成git信息</a> ”。</p>
</blockquote>
<p>如果要显示完整的git信息（即完整内容 <code>git.properties</code>），请使用该<code>management.info.git.mode</code>属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.info.git.mode=full</span><br></pre></td></tr></table></figure>
<h3 id="构建信息"><a href="#构建信息" class="headerlink" title="构建信息"></a>构建信息</h3><p>如果<code>BuildProperties</code>bean可用，<code>info</code>端点也可以发布有关构建的信息。如果<code>META-INF/build-info.properties</code>类路径中有文件可用，则会发生这种情况。</p>
<blockquote>
<p>Maven和Gradle插件都可以生成该文件。有关更多详细<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-build-info" target="_blank" rel="noopener">信息，</a>请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-build-info" target="_blank" rel="noopener">生成构建信息</a> ”。</p>
</blockquote>
<h3 id="编写自定义InfoContributors"><a href="#编写自定义InfoContributors" class="headerlink" title="编写自定义InfoContributors"></a>编写自定义InfoContributors</h3><p>要提供自定义应用程序信息，可以注册实现该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java" target="_blank" rel="noopener"><code>InfoContributor</code></a>接口的Spring bean 。</p>
<p>以下示例<code>example</code>使用单个值提供条目：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInfoContributor</span> <span class="keyword">implements</span> <span class="title">InfoContributor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contribute</span><span class="params">(Info.Builder builder)</span> </span>&#123;</span><br><span class="line">		builder.withDetail(<span class="string">"example"</span>,</span><br><span class="line">				Collections.singletonMap(<span class="string">"key"</span>, <span class="string">"value"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果到达<code>info</code>端点，您应该看到包含以下附加条目的响应：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"example"</span>: &#123;</span><br><span class="line">		<span class="attr">"key"</span> : <span class="string">"value"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-endpoints/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-actuator/">使用SpringBoot-actuator</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/actuator/">actuator</a></div></div><div class="post-content"><div class="main-content content"><h1 id="启用生产就绪功能"><a href="#启用生产就绪功能" class="headerlink" title="启用生产就绪功能"></a>启用生产就绪功能</h1><p>该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator" target="_blank" rel="noopener"><code>spring-boot-actuator</code></a>模块提供了Spring Boot的所有生产就绪功能。启用这些功能的最简单方法是为<code>spring-boot-starter-actuator</code>“Starter” 添加依赖项。</p>
<p><strong>执行器的定义</strong></p>
<p>致动器是制造术语，指的是用于移动或控制某物的机械装置。执行器可以通过一个小的变化产生大量的运动。</p>
<p>要将执行器添加到基于Maven的项目，请添加以下“Starter”依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于Gradle，请使用以下声明：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	<span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-actuator"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-actuator/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-创建自己的自动配置/">使用SpringBoot-创建自己的自动配置</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/configuration/">configuration</a></div></div><div class="post-content"><div class="main-content content"><h1 id="创建自己的自动配置"><a href="#创建自己的自动配置" class="headerlink" title="创建自己的自动配置"></a>创建自己的自动配置</h1><p>如果您在开发共享库的公司工作，或者您在开源或商业库中工作，则可能需要开发自己的自动配置。自动配置类可以捆绑在外部jar中，仍然可以通过Spring Boot获取。</p>
<p>自动配置可以与“启动器”相关联，该“启动器”提供自动配置代码以及您将使用它的典型库。我们首先介绍了构建自己的自动配置需要了解的内容，然后我们将继续介绍<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-custom-starter" target="_blank" rel="noopener">创建自定义启动器所需</a>的 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-custom-starter" target="_blank" rel="noopener">典型步骤</a>。</p>
<blockquote>
<p>可以使用<a href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration" target="_blank" rel="noopener">演示项目</a>来展示如何逐步创建启动器。</p>
</blockquote>
<h2 id="了解自动配置的Bean"><a href="#了解自动配置的Bean" class="headerlink" title="了解自动配置的Bean"></a>了解自动配置的Bean</h2><p>在引擎盖下，自动配置使用标准<code>@Configuration</code>类实现。其他<code>@Conditional</code>注释用于约束何时应用自动配置。通常，自动配置类使用<code>@ConditionalOnClass</code>和 <code>@ConditionalOnMissingBean</code>注释。这可确保仅在找到相关类时以及未声明自己的类时才应用自动配置 <code>@Configuration</code>。</p>
<p>您可以浏览源代码<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure" target="_blank" rel="noopener"><code>spring-boot-autoconfigure</code></a> 以查看<code>@Configuration</code>Spring提供的类（请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories" target="_blank" rel="noopener"><code>META-INF/spring.factories</code></a> 文件）。</p>
<h2 id="找到自动配置候选者"><a href="#找到自动配置候选者" class="headerlink" title="找到自动配置候选者"></a>找到自动配置候选者</h2><p>Spring Boot会检查<code>META-INF/spring.factories</code>已发布jar中是否存在文件。该文件应列出<code>EnableAutoConfiguration</code>密钥下的配置类 ，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自动配置，必须加载这种方式<em>只</em>。确保它们在特定的包空间中定义，并且它们永远不是组件扫描的目标。此外，自动配置类不应启用组件扫描以查找其他组件。应该使用特定的<code>@ Import</code>s代替。</p>
</blockquote>
<p>如果需要按特定顺序应用配置，则可以使用 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java" target="_blank" rel="noopener"><code>@AutoConfigureAfter</code></a>或 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java" target="_blank" rel="noopener"><code>@AutoConfigureBefore</code></a>注释。例如，如果您提供特定于Web的配置，则可能需要在之后应用您的类 <code>WebMvcAutoConfiguration</code>。</p>
<p>如果您想订购某些不应该彼此直接了解的自动配置，您也可以使用<code>@AutoConfigureOrder</code>。该注释与常规注释具有相同的语义，<code>@Order</code>但为自动配置类提供了专用顺序。</p>
<h2 id="条件注释"><a href="#条件注释" class="headerlink" title="条件注释"></a>条件注释</h2><p>您几乎总是希望<code>@Conditional</code>在自动配置类中包含一个或多个注释。该<code>@ConditionalOnMissingBean</code>注释是用来让开发者重写自动配置，如果他们不满意自己的缺省值一个常见的例子。</p>
<p>Spring Boot包含许多<code>@Conditional</code>注释，您可以通过注释<code>@Configuration</code>类或单个<code>@Bean</code>方法在自己的代码中重用这些注释。这些注释包括：</p>
<ul>
<li>Class条件</li>
<li>Bean条件</li>
<li>Property条件</li>
<li>Resource条件</li>
<li>Web Application条件</li>
<li>spEL表达式条件</li>
</ul>
<h3 id="Class-Conditions"><a href="#Class-Conditions" class="headerlink" title="Class Conditions"></a>Class Conditions</h3><p><code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingClass</code>注解让 <code>@Configuration</code>类基于特定类的存在或不存在被包括在内。由于使用<a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a>解析注释元数据这一事实，您可以使用该<code>value</code>属性来引用真实类，即使该类实际上可能不会出现在正在运行的应用程序类路径中。<code>name</code> 如果您希望使用<code>String</code>值指定类名，也可以使用该属性。</p>
<p>此机制不适用于<code>@Bean</code>通常返回类型是条件的目标的方法：在方法的条件适用之前，JVM将加载类和可能处理的方法引用，如果类不是当下。</p>
<p>要处理此方案，<code>@Configuration</code>可以使用单独的类来隔离条件，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//一些条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自动配置的bean</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(EmbeddedAcmeService.class)</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedConfiguration</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> EmbeddedAcmeService <span class="title">embeddedAcmeService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您使用<code>@ConditionalOnClass</code>或<code>@ConditionalOnMissingClass</code>作为元注释的一部分来组成您自己的组合注释，则必须使用<code>name</code>在这种情况下引用该类而不处理。</p>
</blockquote>
<h3 id="Bean-Conditions"><a href="#Bean-Conditions" class="headerlink" title="Bean Conditions"></a>Bean Conditions</h3><p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>注解让豆基于特定豆的存在或不存在被包括在内。您可以使用该<code>value</code> 属性按类型<code>name</code>指定bean 或按名称指定bean。该<code>search</code> 属性允许您限制<code>ApplicationContext</code>搜索Bean时应考虑的层次结构。</p>
<p>放置在<code>@Bean</code>方法上时，目标类型默认为方法的返回类型，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，<code>myService</code>如果没有<code>MyService</code>包含类型的bean，则将创建bean <code>ApplicationContext</code>。</p>
<blockquote>
<p>您需要非常小心添加bean定义的顺序，因为这些条件是根据到目前为止已处理的内容进行评估的。出于这个原因，我们建议仅对自动配置类使用<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>注释（因为在添加任何用户定义的bean定义之后，这些类保证加载）。</p>
</blockquote>
<blockquote>
<p><code>@ConditionalOnBean</code>并且<code>@ConditionalOnMissingBean</code>不会阻止<code>@Configuration</code> 创建类。在类级别使用这些条件和<code>@Bean</code>使用注释标记每个包含的方法之间的唯一区别是，<code>@Configuration</code>如果条件不匹配，前者会阻止将类注册为bean。</p>
</blockquote>
<h3 id="Property-Conditions"><a href="#Property-Conditions" class="headerlink" title="Property Conditions"></a>Property Conditions</h3><p>该<code>@ConditionalOnProperty</code>注解让配置基于Spring的环境属性被包括在内。使用<code>prefix</code>和<code>name</code>属性指定应检查的属性。默认情况下，<code>false</code>匹配存在且不相等的任何属性。您还可以使用<code>havingValue</code>和 <code>matchIfMissing</code>属性创建更高级的检查。</p>
<h3 id="Resource-Conditions"><a href="#Resource-Conditions" class="headerlink" title="Resource Conditions"></a>Resource Conditions</h3><p>该<code>@ConditionalOnResource</code>注解让配置被包括仅当特定资源是否存在。可以使用常用的Spring约定来指定资源，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:/home/user/test.dat</span><br></pre></td></tr></table></figure>
<h3 id="Web-Application-Conditions"><a href="#Web-Application-Conditions" class="headerlink" title="Web Application Conditions"></a>Web Application Conditions</h3><p>在<code>@ConditionalOnWebApplication</code>和<code>@ConditionalOnNotWebApplication</code>注释，让配置取决于应用程序是否是一个“Web应用程序”被包括在内。Web应用程序是使用Spring <code>WebApplicationContext</code>，定义<code>session</code>范围或具有的任何应用程序<code>StandardServletEnvironment</code>。</p>
<h3 id="spEL-Conditions"><a href="#spEL-Conditions" class="headerlink" title="spEL Conditions"></a>spEL Conditions</h3><p>该<code>@ConditionalOnExpression</code>注解让配置基于一个的结果被包括<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/core.html#expressions" target="_blank" rel="noopener">使用SpEL表达</a>。</p>
<h2 id="测试自动配置"><a href="#测试自动配置" class="headerlink" title="测试自动配置"></a>测试自动配置</h2><p>自动配置可能受许多因素的影响：用户配置（<code>@Bean</code> 定义和<code>Environment</code>自定义），条件评估（存在特定库）等。具体而言，每个测试都应创建一个定义良好的<code>ApplicationContext</code>代表，以表示这些自定义的组合。 <code>ApplicationContextRunner</code>提供了实现这一目标的好方法。</p>
<p><code>ApplicationContextRunner</code>通常被定义为测试类的一个字段来收集基本的通用配置。以下示例确保 <code>UserServiceAutoConfiguration</code>始终调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">		.withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果必须定义多个自动配置，则无需按照与运行应用程序时完全相同的顺序调用它们的声明。</p>
</blockquote>
<p>每个测试都可以使用运行器来表示特定的用例。例如，下面的示例调用用户配置（<code>UserConfiguration</code>）并检查自动配置是否正确退回。调用<code>run</code>提供了可以使用的回调上下文<code>Assert4J</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultServiceBacksOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.contextRunner.withUserConfiguration(UserConfiguration.class)</span><br><span class="line">			.run((context) -&gt; &#123;</span><br><span class="line">				assertThat(context).hasSingleBean(UserService.class);</span><br><span class="line">				assertThat(context.getBean(UserService.class)).isSameAs(</span><br><span class="line">						context.getBean(UserConfiguration.class).myUserService());</span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> UserService <span class="title">myUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> UserService(<span class="string">"mine"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以轻松自定义<code>Environment</code>，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceNameCanBeConfigured</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.contextRunner.withPropertyValues(<span class="string">"user.name=test123"</span>).run((context) -&gt; &#123;</span><br><span class="line">		assertThat(context).hasSingleBean(UserService.class);</span><br><span class="line">		assertThat(context.getBean(UserService.class).getName()).isEqualTo(<span class="string">"test123"</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runner也可以用来显示<code>ConditionEvaluationReport</code>。报告可以打印<code>INFO</code>或<code>DEBUG</code>级别打印。以下示例显示如何使用<code>ConditionEvaluationReportLoggingListener</code> 在自动配置测试中打印报表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> autoConfigTest &#123;</span><br><span class="line">	ConditionEvaluationReportLoggingListener initializer = </span><br><span class="line">        <span class="keyword">new</span> ConditionEvaluationReportLoggingListener(LogLevel.INFO);</span><br><span class="line">	ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">			.withInitializer(initializer).run((context) -&gt; &#123;</span><br><span class="line">					<span class="comment">// Do something...</span></span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟Web上下文"><a href="#模拟Web上下文" class="headerlink" title="模拟Web上下文"></a>模拟Web上下文</h3><p>如果您需要测试仅在Servlet或Reactive Web应用程序上下文中运行的自动配置，请分别使用<code>WebApplicationContextRunner</code>或<code>ReactiveWebApplicationContextRunner</code>。</p>
<h3 id="覆盖Classpath"><a href="#覆盖Classpath" class="headerlink" title="覆盖Classpath"></a>覆盖Classpath</h3><p>还可以测试在运行时不存在特定类和/或包时发生的情况。Spring Boot附带一个<code>FilteredClassLoader</code>可以由跑步者轻松使用的。在以下示例中，我们声明如果<code>UserService</code>不存在，则会正确禁用自动配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceIsIgnoredIfLibraryIsNotPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.contextRunner.withClassLoader(<span class="keyword">new</span> FilteredClassLoader(UserService.class))</span><br><span class="line">			.run((context) -&gt; assertThat(context).doesNotHaveBean(<span class="string">"userService"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建自己的启动器"><a href="#创建自己的启动器" class="headerlink" title="创建自己的启动器"></a>创建自己的启动器</h2><p>的完整Spring Boot启动程序可能包含以下组件：</p>
<ul>
<li><code>autoconfigure</code>包含自动配置代码的模块。</li>
<li>该<code>starter</code>模块提供对<code>autoconfigure</code>模块以及库的依赖关系以及通常有用的任何其他依赖关系。简而言之，添加启动器应该提供开始使用该库所需的一切。</li>
</ul>
<blockquote>
<p>如果您不需要将这两个问题分开，则可以将自动配置代码和依赖关系管理组合在一个模块中。</p>
</blockquote>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>您应该确保为您的启动器提供适当的命名空间。<code>spring-boot</code>即使您使用其他Maven，也不要使用它来启动模块名称<code>groupId</code>。我们可能会为您将来自动配置的内容提供官方支持。</p>
<p>根据经验，您应该在启动器后命名组合模块。例如，假设您正在为“acme”创建启动器，并且您将自动配置模块<code>acme-spring-boot-autoconfigure</code>和启动器命名为<code>acme-spring-boot-starter</code>。如果您只有一个组合两者的模块，请将其命名<code>acme-spring-boot-starter</code>。</p>
<p>此外，如果您的启动器提供配置密钥，请为它们使用唯一的命名空间。特别是，不包括你在春天开机使用的命名空间键（如 <code>server</code>，<code>management</code>，<code>spring</code>，等）。如果您使用相同的命名空间，我们将来可能会以破坏您的模块的方式修改这些命名空间。</p>
<p>确保 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#configuration-metadata-annotation-processor" target="_blank" rel="noopener">触发元数据生成，</a>以便为您的密钥提供IDE帮助。您可能希望查看生成的元数据（<code>META-INF/spring-configuration-metadata.json</code>）以确保正确记录您的密钥。</p>
<h3 id="autoconfigure模块"><a href="#autoconfigure模块" class="headerlink" title="autoconfigure模块"></a>autoconfigure模块</h3><p>该<code>autoconfigure</code>模块包含开始使用库所需的所有内容。它还可以包含配置键定义（例如 <code>@ConfigurationProperties</code>）和任何可用于进一步自定义组件初始化方式的回调接口。</p>
<blockquote>
<p>您应该将库的依赖项标记为可选，以便您可以<code>autoconfigure</code>更轻松地将模块包含在项目中。如果以这种方式执行，则不提供库，默认情况下，Spring Boot会退出。</p>
</blockquote>
<p>Spring Boot使用注释处理器来收集元数据文件（<code>META-INF/spring-autoconfigure-metadata.properties</code>）中自动配置的条件。如果该文件存在，则用于热切过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于Gradle 4.5及更早版本，应在<code>compileOnly</code> 配置中声明依赖项，如以下示例所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	compileOnly <span class="string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Gradle 4.6及更高版本时，应在<code>annotationProcessor</code> 配置中声明依赖项，如以下示例所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	annotationProcessor <span class="string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动器模块"><a href="#启动器模块" class="headerlink" title="启动器模块"></a>启动器模块</h3><p>启动器是一个空罐子。它的唯一目的是提供必要的依赖项来使用库。您可以将其视为对入门所需内容的一种看法。</p>
<p>不要对添加启动器的项目做出假设。如果您自动配置的库通常需要其他启动器，请同时提及它们。如果可选依赖项的数量很高，则提供一组适当的<em>默认</em>依赖项可能很难，因为您应该避免包含对典型库的使用不必要的依赖项。换句话说，您不应该包含可选的依赖项。</p>
<blockquote>
<p>无论哪种方式，您的启动器必须<code>spring-boot-starter</code>直接或间接引用核心Spring Boot启动器（）（如果您的启动器依赖于另一个启动器，则无需添加它）。如果只使用自定义启动器创建项目，则Spring Boot的核心功能将通过核心启动器的存在来实现。</p>
</blockquote>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-创建自己的自动配置/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2019 By YoungDream</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/clicklove.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>