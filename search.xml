<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mybatis中的n-n关系</title>
      <link href="/2019/03/25/Mappr%E4%B8%AD%E7%9A%84n-n%E5%85%B3%E7%B3%BB/"/>
      <url>/2019/03/25/Mappr%E4%B8%AD%E7%9A%84n-n%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis中的级联关系"><a href="#Mybatis中的级联关系" class="headerlink" title="Mybatis中的级联关系"></a>Mybatis中的级联关系</h1><ul><li>association 一对一</li><li>collection 一对多</li><li>discrimination 多对多</li></ul><h2 id="asscociation"><a href="#asscociation" class="headerlink" title="asscociation"></a>asscociation</h2><p>我们模拟一个场景</p><p>一个学生有姓名，年龄，住址等等</p><p>Student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> Student&#123;</span><br><span class="line">    <span class="keyword">private</span> Long studentNo;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的住址又包括省、市、区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> Address&#123;</span><br><span class="line">    <span class="keyword">private</span> Long addressNo;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String area;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>多表级联查询不使用<code>association</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Student"</span> <span class="attr">id</span>=<span class="string">"studentResult"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"studentNo"</span> <span class="attr">column</span>=<span class="string">"student_no"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 直接赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address.addressNo"</span> <span class="attr">column</span>=<span class="string">"a_no"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address.province"</span> <span class="attr">column</span>=<span class="string">"province"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address.city"</span> <span class="attr">column</span>=<span class="string">"city"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"address.area"</span> <span class="attr">column</span>=<span class="string">"area"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>查询语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findStudentWithAddress"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">"studentResult"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">parameterType</span>=<span class="string">"Integer"</span>&gt;</span></span><br><span class="line">select * from t_student t1,t_address t2 where t1.a_no=t2.address_no and t1.student_no=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式采用的是对象方式的级联操作不太好，因为每一次查询都要把所有的属性列在那里，并且修改的时候要全部修改，所以很不方便，尽量模块化</p></li><li><p>多表级联查询使用<code>association</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Student"</span> <span class="attr">id</span>=<span class="string">"StudentResult"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"studentNo"</span> <span class="attr">column</span>=<span class="string">"student_no"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">javaType</span>=<span class="string">"Address"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"addressNo"</span> <span class="attr">column</span>=<span class="string">"address_no"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"province"</span> <span class="attr">column</span>=<span class="string">"province"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"city"</span> <span class="attr">column</span>=<span class="string">"city"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"area"</span> <span class="attr">column</span>=<span class="string">"area"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>单表查询(N+1的问题)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Student"</span> <span class="attr">id</span>=<span class="string">"StudentResult"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"studentNo"</span> <span class="attr">column</span>=<span class="string">"student_no"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"address"</span> <span class="attr">javaType</span>=<span class="string">"Student"</span> <span class="attr">column</span>=<span class="string">"a_no"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">selete</span>=<span class="string">"getAddress"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不一定在同一XML文件中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAddress"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    select * from t_address where address_no=#&#123;_parameter&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的<code>selete</code>=<code>getAddress</code>也可以是<code>packageName.xxxMapper.selectID</code></p><p>不用sql联合查询，通过<code>association</code>的延迟加载来实现:</p><p>​    什么是延迟加载？如果先查询订单信息即可满足业务要求就不会去查询用户，只有当用到用户信息时再查询用户信息。 对用户信息按需去查询就是延迟加载。<br>比如上面，只有当调用<code>Student</code>Bean中的<code>getAddress</code>方法获取关联的<code>address</code>数据时，才会触发数据库查询<code>t_address</code>表。</p><p><code>mybatis</code>默认没有开启延迟加载，需要在<code>SqlMapConfig.xml</code>中<code>setting</code>配置。<br><code>lazyLoadingEnabled</code>：全局性设置懒加载。如果设为<code>false</code>，则所有相关联的都会被初始化加载。</p><p>​                       允许值有：<code>true</code> | <code>false</code>。默认值：<code>false</code><br><code>aggressiveLazyLoading</code>：当设置为<code>true</code>的时候，懒加载的对象可能被任何懒属性全部加载。</p><p>​                       否则，每个属性都按需加载。允许值有：<code>true</code> | <code>false</code>。默认值：<code>true</code></p><p>事实上，大多数业务场景显示的表格，都会用到多个表字段。<br>如果采用延迟加载，会存在N+1问题。<br>什么是N+1问题呢？<br>每一个获取Order内部的User对象，都会进行一次select查询<br>那么当运行过程中执行Order的getList方法时，SQL首先进行1次查询，查询结果如果有N条订单记录，那么实际在每条订单中显示过程中还要运行一次select用户的查询，共n次。<br>SQL总共执行了n+1次。相比第二种方法的只进行一次联合查询，这种方式无疑是低效的。<br>如果业务场景的表格显示字段，并没有跨表，那么可以采用延迟加载方式</p></li></ol><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><p>情景：一个班级有多个学生</p><p>班级表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`class`</span> (</span><br><span class="line">  <span class="string">`CLASS_ID`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`CLASS_NAME`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`CLASS_YEAR`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`TEACHER_ID`</span> <span class="built_in">int</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`CLASS_ID`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>学生表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`class_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`student_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`class_id`</span> (<span class="string">`class_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`class_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`class_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`class`</span> (<span class="string">`CLASS_ID`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>班级类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassEntity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> classid;</span><br><span class="line"><span class="keyword">private</span> String className;</span><br><span class="line"><span class="keyword">private</span> String classYear;</span><br><span class="line"><span class="keyword">private</span> Teacher teacher;</span><br><span class="line"><span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> studentId;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String sex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>班级Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"包名.ClassMapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"classEntity"</span> <span class="attr">id</span>=<span class="string">"classResultMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"classid"</span> <span class="attr">column</span>=<span class="string">"CLASS_ID"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"className"</span> <span class="attr">column</span>=<span class="string">"CLASS_NAME"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"classYear"</span> <span class="attr">column</span>=<span class="string">"CLASS_YEAR"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">column</span>=<span class="string">"TEACHER_ID"</span> </span></span><br><span class="line"><span class="tag">                     <span class="attr">select</span>=<span class="string">"包名.TeacherMapper.getTeacher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"students"</span> <span class="attr">column</span>=<span class="string">"class_id"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">javaType</span>=<span class="string">"ArrayList"</span> <span class="attr">ofType</span>=<span class="string">"student"</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">select</span>=<span class="string">"包名.StudentMapper.getStudentByClassId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getClass"</span> <span class="attr">parameterType</span>=<span class="string">"integer"</span> <span class="attr">resultMap</span>=<span class="string">"classResultMap"</span>&gt;</span></span><br><span class="line">SELECT * FROM CLASS CT</span><br><span class="line">WHERE CT.CLASS_ID = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>学生Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"包名.StudentMapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"student"</span> <span class="attr">id</span>=<span class="string">"ResultMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"studentId"</span> <span class="attr">column</span>=<span class="string">"STUDENT_ID"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"NAME"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"sex"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"age"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudentByClassId"</span> <span class="attr">parameterType</span>=<span class="string">"integer"</span> <span class="attr">resultMap</span>=<span class="string">"ResultMap"</span>&gt;</span></span><br><span class="line">SELECT * FROM Student CT</span><br><span class="line">WHERE CT.CLASS_ID = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用方法和效率的比较："><a href="#使用方法和效率的比较：" class="headerlink" title="使用方法和效率的比较："></a>使用方法和效率的比较：</h3><ol><li><p>全使用单表查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Student"</span> <span class="attr">id</span>=<span class="string">"StudentMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"job"</span> <span class="attr">property</span>=<span class="string">"job"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"scores"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">ofType</span>=<span class="string">"Score"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">"id"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">"queryScoresBySID"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Score"</span> <span class="attr">id</span>=<span class="string">"ScoreMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"num"</span> <span class="attr">property</span>=<span class="string">"num"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"subject"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">javaType</span>=<span class="string">"Subject"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">column</span>=<span class="string">"subject"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">select</span>=<span class="string">"querySubjectBySubId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryStudents"</span> <span class="attr">resultMap</span>=<span class="string">"StudentMap"</span> &gt;</span></span><br><span class="line">    SELECT id,name,job FROM t_student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScoresBySID"</span> <span class="attr">resultMap</span>=<span class="string">"ScoreMap"</span>&gt;</span></span><br><span class="line">    SELECT id,num,subject FROM t_score WHERE sid = #&#123;sid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"querySubjectBySubId"</span> <span class="attr">resultType</span>=<span class="string">"Subject"</span> &gt;</span></span><br><span class="line">    SELECT id,name FROM t_subject where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用左连接进行多表查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Student"</span> <span class="attr">id</span>=<span class="string">"StudentMap2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"job"</span> <span class="attr">property</span>=<span class="string">"job"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"scores"</span> <span class="attr">javaType</span>=<span class="string">"java.util.ArrayList"</span> <span class="attr">ofType</span>=<span class="string">"Score"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"num"</span> <span class="attr">property</span>=<span class="string">"num"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">javaType</span>=<span class="string">"Subject"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryStudents2"</span> <span class="attr">resultMap</span>=<span class="string">"StudentMap2"</span> &gt;</span></span><br><span class="line">    SELECT stu.id,stu.name name,stu.job,sco.id id,sco.num num,sub.id id,sub.name name</span><br><span class="line">    FROM t_student stu LEFT JOIN t_score sco ON stu.id = sco.sid LEFT JOIN t_subject sub ON sco.subject = sub.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>总结:</p><p>方案一：需要执行至少三次sql语句，开启三次事务才能完成本次请求。<br>方案二：只需要执行一次sql语句，开启一次事务就能完成本次请求</p><p>方案二比方案一的效率要高，但是在使用的时候，方案一的代码可重用性要高</p><p>如果追求代码重用性可以选择方案一<br>如果追求运行的性能可以选择方案二</p><h2 id="descrimination"><a href="#descrimination" class="headerlink" title="descrimination"></a>descrimination</h2><p>待续…</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> association </tag>
            
            <tag> collection </tag>
            
            <tag> discrimination </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java11尝鲜</title>
      <link href="/2019/03/23/Java11%E5%B0%9D%E9%B2%9C/"/>
      <url>/2019/03/23/Java11%E5%B0%9D%E9%B2%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Java11新工具"><a href="#Java11新工具" class="headerlink" title="Java11新工具"></a>Java11新工具</h2><h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>​    用过Python的童鞋都知道读取-求值-打印循环(Read-Evaluation-Print Loop)很方便。他的目的在于以即时结果和反馈的形式。java9引入了JShell这个交互性工具，让Java也可以像脚本语言一样来运行，可以从控制台启动JShell，在JShell中直接输入表达式并查看其执行结果。当需要测试一个方法的运行效果或者是快速的对表达式进行求值时，JShell都十分方便。除了表达式之外，还可以创建 Java 类和方法。jshell 也有基本的代码完成功能。我们在教人们如何编写 Java 的过程中，不再需要解释 “public static void main（String [] args）” 这句废话。</p><h3 id="Dynamic-Class-File-Constants类文件新添的一种结构"><a href="#Dynamic-Class-File-Constants类文件新添的一种结构" class="headerlink" title="Dynamic Class-File Constants类文件新添的一种结构"></a>Dynamic Class-File Constants类文件新添的一种结构</h3><p>Java的类型文件格式将被拓展，支持一种新的常量池格式：CONSTANT_Dynamic，加载CONSTANT_Dynamic会将创建委托给bootstrap方法。</p><p>目的<br>其目的是降低开发新形式的可实现类文件约束带来的成本和干扰。</p><h3 id="局部变量类型推断（var-”关键字”）"><a href="#局部变量类型推断（var-”关键字”）" class="headerlink" title="局部变量类型推断（var ”关键字”）"></a>局部变量类型推断（var ”关键字”）</h3><p>什么是局部变量类型推断？</p><p>var javastack = “javastack”;<br>System.out.println(javastack);<br>大家看出来了，局部变量类型推断就是左边的类型直接使用 var 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 String 。</p><p>var javastack = “javastack”;<br>就等于：<br>String javastack = “javastack”;</p><p>在声明隐式类型的lambda表达式的形参时允许使用var<br>使用var的好处是在使用lambda表达式时给参数加上注解<br>(@Deprecated var x, @Nullable var y) -&gt; x.process(y);</p><blockquote><p><strong>注意</strong>：</p><ol><li>var a; 这样不可以, 因为无法推断</li><li>类的属性的数据类型不可以使用var</li></ol><p><strong>有参数的lambda表达式使用</strong><br>函数式接口 :<br>    Consumer<t> : 消费型函数式接口.<br>        public void accept(T t);</t></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = t -&gt; System.out.println(t.toUpperCase());</span><br><span class="line">Consumer&lt;String&gt; consumer = (<span class="keyword">var</span> t) -&gt; System.out.println(t.toUpperCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的形式: 必须要有类型, 可以加上var</span></span><br><span class="line">Consumer&lt;String&gt; consumer = (<span class="meta">@Deprecated</span> t) -&gt; System.out.println(t.toUpperCase());</span><br><span class="line"><span class="comment">//正确的形式:</span></span><br><span class="line">Consumer&lt;String&gt; consumer = (<span class="meta">@Deprecated</span> <span class="keyword">var</span> t) -&gt; System.out.println(t.toUpperCase());</span><br></pre></td></tr></table></figure><h2 id="Java11新API-实用"><a href="#Java11新API-实用" class="headerlink" title="Java11新API(实用)"></a>Java11新API(实用)</h2><h3 id="新的本机不可修改集合API"><a href="#新的本机不可修改集合API" class="headerlink" title="新的本机不可修改集合API"></a>新的本机不可修改集合API</h3><p>自 Java 9 开始，Jdk 里面为集合（List/ Set/ Map）都添加了 of 和 copyOf 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。</p><p>示例1：</p><p>var list = List.of(“Java”, “Python”, “C”);<br>var copy = List.copyOf(list);<br>System.out.println(list == copy); // true<br>示例2：</p><p>var list = new ArrayList<string>();<br>var copy = List.copyOf(list);<br>System.out.println(list == copy); // false<br>示例1和2代码差不多，为什么一个为true,一个为false?</string></p><p>来看下它们的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(E... elements)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (elements.length) &#123; <span class="comment">// implicit null check of elements</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ImmutableCollections.emptyList();</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(elements[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(elements[<span class="number">0</span>], elements[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(elements);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">listCopy</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coll <span class="keyword">instanceof</span> AbstractImmutableList &amp;&amp; coll.getClass() != SubList.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;)coll;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;)List.of(coll.toArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 copyOf 方法会先判断来源集合是不是 AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创建一个新的集合。</p><p>示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类，所以 copyOf 方法又创建了一个新的实例，所以为false.</p><p>注意：使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 java.lang.UnsupportedOperationException 异常。</p><p>上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</p><p>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</p><h3 id="Stream-加强"><a href="#Stream-加强" class="headerlink" title="Stream 加强"></a>Stream 加强</h3><p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p><ol><li><p>增加单个参数构造方法，可为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.ofNullable(<span class="keyword">null</span>).count(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p>增加 takeWhile 和 dropWhile 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从开始计算，当 n &lt; 3 时就截止。终止后，不管之后的元素满不满足条件，都不再进行判断</span></span><br><span class="line">ream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>).takeWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个和上面的相反，一旦 n &lt; 3 不成立就开始计算。</span></span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>).dropWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure></li><li><p>iterate重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老版本的使用方法</span></span><br><span class="line">Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="number">1</span>, t -&gt; (<span class="number">2</span> * t) + <span class="number">1</span>);</span><br><span class="line">iterate.forEach(System.out::println);<span class="comment">//无限流，原因：溢出了</span></span><br><span class="line">iterate.limit(<span class="number">200</span>).forEach(System.out::println);<span class="comment">//限制条数</span></span><br><span class="line"><span class="comment">//这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</span></span><br><span class="line">Stream&lt;Integer&gt; newIterate = Stream.iterate(<span class="number">1</span>, t -&gt; t &gt; <span class="number">200</span>, t -&gt; (<span class="number">2</span> * t) + <span class="number">1</span>);</span><br><span class="line">newIterate.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ol><h3 id="增加了一系列的字符串处理方法"><a href="#增加了一系列的字符串处理方法" class="headerlink" title="增加了一系列的字符串处理方法"></a>增加了一系列的字符串处理方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为空白</span></span><br><span class="line"><span class="string">" "</span>.isBlank(); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 去除首尾空白</span></span><br><span class="line"><span class="string">" Javastack "</span>.strip(); <span class="comment">// "Javastack"</span></span><br><span class="line"><span class="comment">// 去除尾部空格</span></span><br><span class="line"><span class="string">" Javastack "</span>.stripTrailing(); <span class="comment">// " Javastack"</span></span><br><span class="line"><span class="comment">// 去除首部空格</span></span><br><span class="line"><span class="string">" Javastack "</span>.stripLeading(); <span class="comment">// "Javastack "</span></span><br><span class="line"><span class="comment">// 复制字符串</span></span><br><span class="line"><span class="string">"Java"</span>.repeat(<span class="number">3</span>);<span class="comment">// "JavaJavaJava"</span></span><br><span class="line"><span class="comment">// 行数统计</span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().count(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="Optional-加强"><a href="#Optional-加强" class="headerlink" title="Optional 加强"></a>Optional 加强</h3><p>Opthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(<span class="string">"javastack"</span>).orElseThrow(); <span class="comment">// javastack</span></span><br><span class="line">Optional.of(<span class="string">"javastack"</span>).stream().count(); <span class="comment">// 1</span></span><br><span class="line">Optional.ofNullable(<span class="keyword">null</span>).or(() -&gt; Optional.of(<span class="string">"javastack"</span>)).get(); <span class="comment">// javastack</span></span><br></pre></td></tr></table></figure><h3 id="改进的文件API"><a href="#改进的文件API" class="headerlink" title="改进的文件API"></a>改进的文件API</h3><p>InputStream 加强</p><p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="keyword">var</span> inputStream = classLoader.getResourceAsStream(<span class="string">"javastack.txt"</span>);</span><br><span class="line"><span class="keyword">var</span> javastack = File.createTempFile(<span class="string">"javastack2"</span>, <span class="string">"txt"</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> outputStream = <span class="keyword">new</span> FileOutputStream(javastack)) &#123;</span><br><span class="line">    inputStream.transferTo(outputStream);<span class="comment">//把输入流中的所有数据直接自动地复制到输出流中</span></span><br><span class="line">&#125;</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure><h3 id="移除的一些其他内容"><a href="#移除的一些其他内容" class="headerlink" title="移除的一些其他内容"></a>移除的一些其他内容</h3><p><strong>移除项</strong>：</p><ol><li><p>移除了com.sun.awt.AWTUtilities</p></li><li><p>移除了sun.misc.Unsafe.defineClass，</p><p>使用java.lang.invoke.MethodHandles.Lookup.defineClass来替代</p></li><li><p>移除了Thread.destroy()以及 Thread.stop(Throwable)方法</p></li><li><p>移除了sun.nio.ch.disableSystemWideOverlappingFileLockCheck</p><p>sun.locale.formatasdefault属性</p></li><li><p>移除了jdk.snmp模块</p></li><li><p>移除了javafx，openjdk估计是从java10版本就移除了，oracle jdk10还尚未移除javafx，而java11版本则oracle的jdk版本也移除了javafx</p></li><li><p>移除了Java Mission Control，从JDK中移除之后，需要自己单独下载</p></li><li><p>移除了这些Root Certificates ：Baltimore Cybertrust Code Signing CA，SECOM ，AOL and Swisscom</p></li></ol><p><strong>废弃项</strong>：</p><ol><li>-XX+AggressiveOpts选项</li><li>-XX:+UnlockCommercialFeatures</li><li>-XX:+LogCommercialFeatures选项也不再需要</li></ol><h3 id="标准Java异步HTTP客户端"><a href="#标准Java异步HTTP客户端" class="headerlink" title="标准Java异步HTTP客户端"></a>标准Java异步HTTP客户端</h3><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 java.net 包中找到这个 API。</p><p>来看一下 HTTP Client 的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(<span class="string">"https://javastack.cn"</span>))</span><br><span class="line">    .GET()</span><br><span class="line">    .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, </span><br><span class="line">                                            HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(HttpResponse::body)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><p>上面的 .GET() 可以省略，默认请求方式为 Get！</p><p>更多使用示例可以看这个 API，后续再做演示。</p><p>现在 Java 自带了这个 HTTP Client API，我们以后还有必要用 Apache 的 HttpClient 工具包吗？</p><h3 id="更简化的编译运行程序"><a href="#更简化的编译运行程序" class="headerlink" title="更简化的编译运行程序"></a>更简化的编译运行程序</h3><p>JEP 330 : 增强java启动器支持运行单个java源代码文件的程序.</p><blockquote><p><strong>注意点</strong> :</p><ol><li>执行源文件中的第一个类, 第一个类必须包含主方法</li><li>并且不可以使用别源文件中的自定义类, 本文件中的自定义类是可以使用的.</li></ol></blockquote><p>一个命令编译运行源代码</p><p>看下面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 编译</span><br><span class="line">javac Javastack.java</span><br><span class="line">// 运行</span><br><span class="line">java Javastack</span><br></pre></td></tr></table></figure><p>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Javastack.java</span><br></pre></td></tr></table></figure><h3 id="Unicode-10"><a href="#Unicode-10" class="headerlink" title="Unicode 10"></a>Unicode 10</h3><p>Unicode 10 增加了8518个字符, 总计达到了136690个字符. 并且增加了4个脚本.同时还有56个新的emoji表情符号.</p><h3 id="Remove-the-JavaEE-and-CORBA-Moudles"><a href="#Remove-the-JavaEE-and-CORBA-Moudles" class="headerlink" title="Remove the JavaEE and CORBA Moudles"></a>Remove the JavaEE and CORBA Moudles</h3><p>在java11中移除了不太使用的JavaEE模块和CORBA技术<br>CORBA来自于二十世纪九十年代，Oracle说，现在用CORBA开发现代Java应用程序已经没有意义了，维护CORBA的成本已经超过了保留它带来的好处。</p><p>但是删除CORBA将使得那些依赖于JDK提供部分CORBA API的CORBA实现无法运行。目前还没有第三方CORBA版本，也不确定是否会有第三方愿意接手CORBA API的维护工作。</p><p>在java11中将java9标记废弃的Java EE及CORBA模块移除掉，具体如下：</p><ol><li>xml相关的，<br>java.xml.ws,<br>java.xml.bind，<br>java.xml.ws，<br>java.xml.ws.annotation，<br>jdk.xml.bind，<br>jdk.xml.ws被移除，<br>只剩下java.xml，java.xml.crypto,jdk.xml.dom这几个模块；</li><li>java.corba，<br>java.se.ee，<br>java.activation，<br>java.transaction被移除，<br>但是java11新增一个java.transaction.xa模块</li></ol><h3 id="JEP-335-Deprecate-the-Nashorn-JavaScript-Engine"><a href="#JEP-335-Deprecate-the-Nashorn-JavaScript-Engine" class="headerlink" title="JEP : 335 : Deprecate the Nashorn JavaScript Engine"></a>JEP : 335 : Deprecate the Nashorn JavaScript Engine</h3><p>废除Nashorn javascript引擎，在后续版本准备移除掉，有需要的可以考虑使用GraalVM</p><h3 id="JEP-336-Deprecate-the-Pack200-Tools-and-API"><a href="#JEP-336-Deprecate-the-Pack200-Tools-and-API" class="headerlink" title="JEP : 336 : Deprecate the Pack200 Tools and API"></a>JEP : 336 : Deprecate the Pack200 Tools and API</h3><p>Java5中带了一个压缩工具:Pack200，这个工具能对普通的jar文件进行高效压缩。其实现原理是根据Java类特有的结构，合并常数池，去掉无用信息等来实现对java类的高效压缩。由于是专门对Java类进行压缩的，所以对普通文件的压缩和普通压缩软件没有什么两样，但是对于Jar  文件却能轻易达到10-40%的压缩率。这在Java应用部署中很有用，尤其对于移动Java计算，能够大大减小代码下载量。<br>Java5中还提供了这一技术的API接口，你可以将其嵌入到你的程序中使用。使用的方法很简单，下面的短短几行代码即可以实现jar的压缩和解压：</p><ol><li>压缩<br>Packer packer=Pack200.newPacker();<br>OutputStream output=new BufferedOutputStream(new  FileOutputStream(outfile));<br>packer.pack(new JarFile(jarFile), output);<br>output.close(); </li><li>解压<br>Unpacker unpacker=Pack200.newUnpacker();<br>output=new JarOutputStream(new FileOutputStream(jarFile));<br>unpacker.unpack(pack200File, output);<br>output.close(); </li></ol><p>Pack200的压缩和解压缩速度是比较快的，而且压缩率也是很惊人的，在我是使用  的包4.46MB压缩后成了1.44MB（0.322%），而且随着包的越大压缩率会更加明显，据说如果jar包都是class类可以压缩到1/9的大  小。其实JavaWebStart还有很多功能，例如可以按不同的jar包进行lazy下载和 单独更新，设置可以根据jar中的类变动进行class粒度的下载。</p><p>但是在java11中废除了pack200以及unpack200工具以及java.util.jar中的Pack200 API。因为Pack200主要是用来压缩jar包的工具，由于网络下载速度的提升以及java9引入模块化系统之后不再依赖Pack200，因此这个版本将其移除掉。</p><h3 id="新的Epsilon垃圾收集器"><a href="#新的Epsilon垃圾收集器" class="headerlink" title="新的Epsilon垃圾收集器"></a>新的Epsilon垃圾收集器</h3><p>A NoOp Garbage Collector<br>JDK上对这个特性的描述是: 开发一个处理内存分配但不实现任何实际内存回收机制的GC, 一旦可用堆内存用完, JVM就会退出.<br>如果有System.gc()调用, 实际上什么也不会发生(这种场景下和-XX:+DisableExplicitGC效果一样), 因为没有内存回收, 这个实现可能会警告用户尝试强制GC是徒劳.</p><p>用法 : <code>-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Garbage</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span> + <span class="string">" : "</span> + n + <span class="string">" is dying"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EpsilonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">List&lt;Garbage&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (flag) &#123;</span><br><span class="line">list.add(<span class="keyword">new</span> Garbage());</span><br><span class="line"><span class="keyword">if</span> (list.size() == <span class="number">1000000</span> &amp;&amp; count == <span class="number">0</span>) &#123;</span><br><span class="line">list.clear();</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"程序结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用选项-XX:+UseEpsilonGC, 程序很快就因为堆空间不足而退出</p><p>使用这个选项的原因 :<br>提供完全被动的GC实现, 具有有限的分配限制和尽可能低的延迟开销,但代价是内存占用和内存吞吐量.<br>众所周知, java实现可广泛选择高度可配置的GC实现. 各种可用的收集器最终满足不同的需求, 即使它们的可配置性使它们的功能相交. 有时更容易维护单独的实现, 而不是在现有GC实现上堆积另一个配置选项.</p><p>主要用途如下 :</p><pre><code>1. 性能测试(它可以帮助过滤掉GC引起的性能假象)2. 内存压力测试(例如,知道测试用例 应该分配不超过1GB的内存, 我们可以使用-Xmx1g –XX:+UseEpsilonGC, 如果程序有问题, 则程序会崩溃)3. 非常短的JOB任务(对象这种任务, 接受GC清理堆那都是浪费空间)4. VM接口测试5. Last-drop 延迟&amp;吞吐改进</code></pre><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>这应该是JDK11最为瞩目的特性, 没有之一. 但是后面带了Experimental, 说明这还不建议用到生产环境</p><ol><li>GC暂停时间不会超过10ms</li><li>既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)</li><li>和G1相比, 应用吞吐能力不会下降超过15%</li><li>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础</li><li>初始只支持64位系统</li></ol><p>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。</p><p>GC是java主要优势之一. 然而, 当GC停顿太长, 就会开始影响应用的响应时间.消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力的平台. 此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高效的方式充分利用这些内存, 并且无需长时间的GC暂停时间.</p><p>STW – stop the world</p><p>ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会STW, 因此GC停顿时间不会随着堆的增长和存活对象的增长而变长.</p><p>ZGC : avg 1.091ms    max:1.681<br>G1   : avg 156.806  max:543.846</p><p>用法 : -XX:+UnlockExperimentalVMOptions –XX:+UseZGC, 因为ZGC还处于实验阶段, 所以需要通过JVM参数来解锁这个特性</p><h3 id="完全支持Linux容器（包括Docker）"><a href="#完全支持Linux容器（包括Docker）" class="headerlink" title="完全支持Linux容器（包括Docker）"></a>完全支持Linux容器（包括Docker）</h3><p>许多运行在Java虚拟机中的应用程序（包括Apache Spark和Kafka等数据服务以及传统的企业应用程序）都可以在Docker容器中运行。但是在Docker容器中运行Java应用程序一直存在一个问题，那就是在容器中运行JVM程序在设置内存大小和CPU使用率后，会导致应用程序的性能下降。这是因为Java应用程序没有意识到它正在容器中运行。随着Java 10的发布，这个问题总算得以解决，JVM现在可以识别由容器控制组（cgroups）设置的约束。可以在容器中使用内存和CPU约束来直接管理Java应用程序，其中包括：</p><p>遵守容器中设置的内存限制<br>在容器中设置可用的CPU<br>在容器中设置CPU约束<br>Java 10的这个改进在Docker for Mac、Docker for Windows以及Docker Enterprise Edition等环境均有效。</p><p>容器的内存限制<br>在Java 9之前，JVM无法识别容器使用标志设置的内存限制和CPU限制。而在Java 10中，内存限制会自动被识别并强制执行。</p><p>Java将服务器类机定义为具有2个CPU和2GB内存，以及默认堆大小为物理内存的1/4。例如，Docker企业版安装设置为2GB内存和4个CPU的环境，我们可以比较在这个Docker容器上运行Java 8和Java 10的区别。</p><p>首先，对于Java 8：</p><p>docker container run -it -m512 –entrypoint bash openjdk:latest<br>$ docker-java-home/bin/java -XX:+PrintFlagsFinal -version | grep MaxHeapSize<br>uintx MaxHeapSize                              := 524288000                          {product}<br>openjdk version “1.8.0_162”<br>1<br>2<br>3<br>4<br>最大堆大小为512M或Docker EE安装设置的2GB的1/4，而不是容器上设置的512M限制。</p><p>相比之下，在Java 10上运行相同的命令表明，容器中设置的内存限制与预期的128M非常接近：</p><p>docker container run -it -m512M –entrypoint bash openjdk:10-jdk<br>$ docker-java-home/bin/java -XX:+PrintFlagsFinal -version | grep MaxHeapSize<br>size_t MaxHeapSize                              = 134217728                          {product} {ergonomic}<br>openjdk version “10” 2018-03-20<br>1<br>2<br>3<br>4<br>设置可用的CPU<br>默认情况下，每个容器对主机CPU周期的访问是无限的。可以设置各种约束来限制给定容器对主机CPU周期的访问。Java 10可以识别这些限制：</p><p>docker container run -it –cpus 2 openjdk:10-jdk<br>jshell&gt; Runtime.getRuntime().availableProcessors()<br>$1 ==&gt; 2<br>1<br>2<br>3<br>分配给Docker EE的所有CPU会获得相同比例的CPU周期。这个比例可以通过修改容器的CPU share权重来调整，而CPU share权重与其它所有运行在容器中的权重相关。此比例仅适用于正在运行的CPU密集型的进程。当某个容器中的任务空闲时，其他容器可以使用余下的CPU时间。实际的CPU时间的数量取决于系统上运行的容器的数量。这些可以在Java 10中设置：</p><p>docker container run -it –cpu-shares 2048 openjdk:10-jdk<br>jshell&gt; Runtime.getRuntime().availableProcessors()<br>$1 ==&gt; 2<br>1<br>2<br>3<br>cpuset约束设置了哪些CPU允许在Java 10中执行。</p><p>docker run -it –cpuset-cpus=”1,2,3” openjdk:10-jdk<br>jshell&gt; Runtime.getRuntime().availableProcessors()<br>$1 ==&gt; 3<br>1<br>2<br>3<br>分配内存和CPU<br>使用Java 10，可以使用容器设置来估算部署应用程序所需的内存和CPU的分配。我们假设已经确定了容器中运行的每个进程的内存堆和CPU需求，并设置了JAVA_OPTS配置。例如，如果有一个跨10个节点分布的应用程序，其中五个节点每个需要512Mb的内存和1024个CPU-shares，另外五个节点每个需要256Mb和512个CPU-shares。</p><p>请注意，1个CPU share比例由1024表示。</p><p>对于内存，应用程序至少需要分配5Gb。</p><p>512Mb × 5 = 2.56Gb<br>256Mb × 5 = 1.28Gb<br>该应用程序需要8个CPU才能高效运行。</p><p>1024 x 5 = 5个CPU<br>512 x 5 = 3个CPU<br>最佳实践是建议分析应用程序以确定运行在JVM中的每个进程实际需要多少内存和分配多少CPU。但是，Java 10消除了这种猜测，可以通过调整容器大小以防止Java应用程序出现内存不足的错误以及分配足够的CPU来处理工作负载。</p><h3 id="支持G1上的并行完全垃圾收集"><a href="#支持G1上的并行完全垃圾收集" class="headerlink" title="支持G1上的并行完全垃圾收集"></a>支持G1上的并行完全垃圾收集</h3><p>对于 G1 GC，相比于 JDK 8，升级到 JDK 11 即可免费享受到：并行的 Full GC，快速的 CardTable 扫描，自适应的堆占用比例调整（IHOP），在并发标记阶段的类型卸载等等。这些都是针对 G1 的不断增强，其中串行 Full GC 等甚至是曾经被广泛诟病的短板，你会发现 GC 配置和调优在 JDK11 中越来越方便。</p><h3 id="JEP-331-Low-Overhead-Heap-Profiling免费的低耗能飞行记录仪和堆分析仪"><a href="#JEP-331-Low-Overhead-Heap-Profiling免费的低耗能飞行记录仪和堆分析仪" class="headerlink" title="JEP 331 : Low-Overhead Heap Profiling免费的低耗能飞行记录仪和堆分析仪"></a>JEP 331 : Low-Overhead Heap Profiling免费的低耗能飞行记录仪和堆分析仪</h3><p>通过JVMTI的SampledObjectAlloc回调提供了一个开销低的heap分析方式</p><p>提供一个低开销的, 为了排错java应用问题, 以及JVM问题的数据收集框架, 希望达到的目标如下 :</p><ol><li>提供用于生产和消费数据作为事件的API</li><li>提供缓存机制和二进制数据格式</li><li>允许事件配置和事件过滤</li><li>提供OS,JVM和JDK库的事件</li></ol><h3 id="JEP-329-实现RFC7539中指定的ChaCha20和Poly1305两种加密算法-代替RC4"><a href="#JEP-329-实现RFC7539中指定的ChaCha20和Poly1305两种加密算法-代替RC4" class="headerlink" title="JEP 329 : 实现RFC7539中指定的ChaCha20和Poly1305两种加密算法, 代替RC4"></a>JEP 329 : 实现RFC7539中指定的ChaCha20和Poly1305两种加密算法, 代替RC4</h3><p>实现 RFC 7539的ChaCha20 and ChaCha20-Poly1305加密算法</p><p>RFC7748定义的秘钥协商方案更高效, 更安全. JDK增加两个新的接口<br>XECPublicKey 和 XECPrivateKey</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KeyPairGenerator kpg = KeyPairGenerator.getInstance(“XDH”);</span><br><span class="line">NamedParameterSpec paramSpec = <span class="keyword">new</span> NamedParameterSpec(“X25519”);</span><br><span class="line">kpg.initialize(paramSpec);</span><br><span class="line">KeyPair kp = kgp.generateKeyPair();</span><br><span class="line"></span><br><span class="line">KeyFactory kf = KeyFactory.getInstance(“XDH”);</span><br><span class="line">BigInteger u = <span class="keyword">new</span> BigInteger(“xxx”);</span><br><span class="line">XECPublicKeySpec pubSpec = <span class="keyword">new</span> XECPublicKeySpec(paramSpec, u);</span><br><span class="line">PublicKey pubKey = kf.generatePublic(pubSpec);</span><br><span class="line"></span><br><span class="line">KeyAgreement ka = KeyAgreement.getInstance(“XDH”);</span><br><span class="line">ka.init(kp.getPrivate());</span><br><span class="line">ka.doPhase(pubKey, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">byte</span>[] secret = ka.generateSecret();</span><br></pre></td></tr></table></figure><h3 id="新的默认根权限证书集"><a href="#新的默认根权限证书集" class="headerlink" title="新的默认根权限证书集"></a>新的默认根权限证书集</h3><h3 id="JEP-332最新的HTTPS安全协议TLS-1-3"><a href="#JEP-332最新的HTTPS安全协议TLS-1-3" class="headerlink" title="JEP 332最新的HTTPS安全协议TLS 1.3"></a>JEP 332最新的HTTPS安全协议TLS 1.3</h3><p>实现TLS协议1.3版本, TLS允许客户端和服务器端通过互联网以一种防止窃听, 篡改以及消息伪造的方式进行通信.</p><h3 id="Java-Flight-Recorder"><a href="#Java-Flight-Recorder" class="headerlink" title="Java Flight Recorder"></a>Java Flight Recorder</h3><p>Flight Recorder源自飞机的黑盒子</p><p>Flight Recorder以前是商业版的特性，在java11当中开源出来，它可以导出事件到文件中，之后可以用Java Mission Control来分析。可以在应用启动时配置java -XX:StartFlightRecording，或者在应用启动之后，使用jcmd来录制，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> jcmd &lt;pid&gt; JFR.start</span><br><span class="line"><span class="meta">$</span> jcmd &lt;pid&gt; JFR.dump filename=recording.jfr</span><br><span class="line"><span class="meta">$</span> jcmd &lt;pid&gt; JFR.stop</span><br></pre></td></tr></table></figure><p>是 Oracle 刚刚开源的强大特性。我们知道在生产系统进行不同角度的 Profiling，有各种工具、框架，但是能力范围、可靠性、开销等，大都差强人意，要么能力不全面，要么开销太大，甚至不可靠可能导致 Java 应用进程宕机。<br>而 JFR 是一套集成进入 JDK、JVM 内部的事件机制框架，通过良好架构和设计的框架，硬件层面的极致优化，生产环境的广泛验证，它可以做到极致的可靠和低开销。在 SPECjbb2015 等基准测试中，JFR 的性能开销最大不超过 1%，所以，工程师可以基本没有心理负担地在大规模分布式的生产系统使用，这意味着，我们既可以随时主动开启 JFR 进行特定诊断，也可以让系统长期运行 JFR，用以在复杂环境中进行“After-the-fact”分析。还需要苦恼重现随机问题吗？JFR 让问题简化了很多。<br>在保证低开销的基础上，JFR 提供的能力也令人眼前一亮，例如：我们无需 BCI 就可以进行 Object Allocation Profiling，终于不用担心 BTrace 之类把进程搞挂了。对锁竞争、阻塞、延迟，JVM GC、SafePoint 等领域，进行非常细粒度分析。甚至深入 JIT Compiler 内部，全面把握热点方法、内联、逆优化等等。JFR 提供了标准的 Java、C++ 等扩展 API，可以与各种层面的应用进行定制、集成，为复杂的企业应用栈或者复杂的分布式应用，提供 All-in-One 解决方案。而这一切都是内建在 JDK 和 JVM 内部的，并不需要额外的依赖，开箱即用。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-附录A</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E9%99%84%E5%BD%95A/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E9%99%84%E5%BD%95A/</url>
      
        <content type="html"><![CDATA[<h1 id="附录A-常用应用程序属性"><a href="#附录A-常用应用程序属性" class="headerlink" title="附录A.常用应用程序属性"></a>附录A.常用应用程序属性</h1><p>可以在<code>application.properties</code>文件内部<code>application.yml</code>，文件内部或命令行开关中指定各种属性。本附录提供了常见Spring Boot属性的列表以及对使用它们的基础类的引用。</p><blockquote><p>Spring Boot提供了各种具有高级值格式的转换机制，请务必查看<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-conversion" target="_blank" rel="noopener">属性转换部分</a>。</p></blockquote><blockquote><p>属性贡献可以来自类路径上的其他jar文件，因此您不应将此视为详尽的列表。此外，您可以定义自己的属性。</p></blockquote><blockquote><p>此示例文件仅供参考。千万<strong>不能</strong>复制和粘贴的全部内容到应用程序中。相反，只选择您需要的属性。</p></blockquote><h2 id="CORE-PROPERTIES"><a href="#CORE-PROPERTIES" class="headerlink" title="CORE PROPERTIES"></a>CORE PROPERTIES</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">＃---------------------------------------- </span><br><span class="line">#CORE PROPERTIES </span><br><span class="line">＃----- ----------------------------------- </span><br><span class="line">debug = false ＃启用调试日志。</span><br><span class="line">trace = false ＃启用跟踪日志。</span><br></pre></td></tr></table></figure><h3 id="LOGGING"><a href="#LOGGING" class="headerlink" title="LOGGING"></a>LOGGING</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#logGING </span><br><span class="line">logging.config = ＃日志配置文件的位置。例如，Logback的`classpath：logback.xml`。</span><br><span class="line">logging.exception-conversion-word =％wEx ＃记录异常时使用的转换字。</span><br><span class="line">logging.file = ＃日志文件名（例如，`myapp.log`）。名称可以是精确位置或相对于当前目录。</span><br><span class="line">logging.file.max-history = 0 ＃要保留的归档日志文件的最大值。仅支持默认的logback设置。</span><br><span class="line">logging.file.max-size = 10MB ＃最大日志文件大小。仅支持默认的logback设置。</span><br><span class="line">logging.group。* =＃记录组以同时快速更改多个记录器。例如，`logging.level.db = org.hibernate，org.springframework.jdbc`。</span><br><span class="line">logging.level。* = ＃日志级别严重性映射。例如，`logging.level.org.springframework = DEBUG`。</span><br><span class="line">logging.path = ＃日志文件的位置。例如，`/ var / log`。</span><br><span class="line">logging.pattern.console = ＃用于输出到控制台的Appender模式。仅支持默认的Logback设置。</span><br><span class="line">logging.pattern.dateformat = yyyy-MM-dd HH：mm：ss.SSS ＃日志日期格式的Appender模式。仅支持默认的Logback设置。</span><br><span class="line">logging.pattern.file =＃用于输出到文件的Appender模式。仅支持默认的Logback设置。</span><br><span class="line">logging.pattern.level =％5p ＃日志级别的Appender模式。仅支持默认的Logback设置。</span><br><span class="line">logging.register-shutdown-hook = false ＃在日志记录系统初始化时注册一个关闭钩子。</span><br></pre></td></tr></table></figure><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">＃AOP </span><br><span class="line">spring.aop.auto = true ＃添加@EnableAspectJAutoProxy。</span><br><span class="line">spring.aop.proxy-target-class = true ＃是否要创建基于子类的（CGLIB）代理（true），而不是基于标准Java接口的代理（false）。</span><br></pre></td></tr></table></figure><h3 id="IDENTITY-（ContextIdApplicationContextInitializer）"><a href="#IDENTITY-（ContextIdApplicationContextInitializer）" class="headerlink" title="IDENTITY （ContextIdApplicationContextInitializer）"></a>IDENTITY （ContextIdApplicationContextInitializer）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name = #应用名</span><br></pre></td></tr></table></figure><h3 id="DINAND-（SpringApplicationAdminJmxAutoConfiguration）"><a href="#DINAND-（SpringApplicationAdminJmxAutoConfiguration）" class="headerlink" title="DINAND （SpringApplicationAdminJmxAutoConfiguration）"></a>DINAND （SpringApplicationAdminJmxAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.admin.enabled = false ＃是否为应用程序启用管理功能。</span><br><span class="line">spring.application.admin.jmx-name = org.springframework.boot：type = Admin，name = SpringApplication #JMX 应用程序管理员MBean的名称。</span><br></pre></td></tr></table></figure><h3 id="AUTO-CONFIGURATION"><a href="#AUTO-CONFIGURATION" class="headerlink" title="AUTO-CONFIGURATION"></a>AUTO-CONFIGURATION</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.autoconfigure.exclude = ＃要排除的自动配置类</span><br></pre></td></tr></table></figure><h3 id="BANNER"><a href="#BANNER" class="headerlink" title="BANNER"></a>BANNER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.banner.charset = UTF-8 ＃横幅文件编码。</span><br><span class="line">spring.banner.location = classpath：banner.txt ＃横幅文本资源位置。</span><br><span class="line">spring.banner.image.location = classpath：banner.gif ＃横幅图像文件位置（也可以使用jpg或png）。</span><br><span class="line">spring.banner.image.width = 76 ＃字符中的横幅图像的宽度。</span><br><span class="line">spring.banner.image.height = #crs 中横幅图像的高度（默认基于图像高度）。</span><br><span class="line">spring.banner.image.margin = 2 ＃字符中的左手图像边距。</span><br><span class="line">spring.banner.image.invert = false ＃是否应针对暗终端主题反转图像。</span><br></pre></td></tr></table></figure><h3 id="SPRING-CORE"><a href="#SPRING-CORE" class="headerlink" title="SPRING CORE"></a>SPRING CORE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.beaninfo.ignore = true ＃是否跳过BeanInfo类的搜索</span><br></pre></td></tr></table></figure><h3 id="SPRING-CACHE（CacheProperties）"><a href="#SPRING-CACHE（CacheProperties）" class="headerlink" title="SPRING CACHE（CacheProperties）"></a>SPRING CACHE（CacheProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names = #Cmama 分隔的要创建的缓存名称列表（如果底层缓存管理器支持）。</span><br><span class="line">spring.cache.caffeine.spec = ＃用于创建缓存的规范。有关规格格式的更多详细信息，请参阅CaffeineSpec。</span><br><span class="line">spring.cache.couchbase.expiration = ＃条目到期。默认情况下，条目永不过期。请注意，此值最终会转换为秒。</span><br><span class="line">spring.cache.ehcache.config = ＃用于初始化EhCache的配置文件的位置。</span><br><span class="line">spring.cache.infinispan.config = ＃用于初始化Infinispan的配置文件的位置。</span><br><span class="line">spring.cache.jcache.config = ＃用于初始化缓存管理器的配置文件的位置。</span><br><span class="line">spring.cache.jcache.provider = #CachingProvider实现的完全限定名称，用于检索符合JSR-107的缓存管理器。仅当类路径上有多个JSR-107实现时才需要。</span><br><span class="line">spring.cache.redis.cache-null-values = true ＃允许缓存空值。</span><br><span class="line">spring.cache.redis.key-prefix = ＃键前缀。</span><br><span class="line">spring.cache.redis.time-to-live = ＃条目到期。默认情况下，条目永不过期。</span><br><span class="line">spring.cache.redis.use-key-prefix = true＃写入Redis时是否使用密钥前缀。</span><br><span class="line">spring.cache.type = #Cache 类型。默认情况下，根据环境自动检测。</span><br></pre></td></tr></table></figure><h3 id="SPRING-CONFIG-仅使用环境属性（ConfigFileApplicationListener）"><a href="#SPRING-CONFIG-仅使用环境属性（ConfigFileApplicationListener）" class="headerlink" title="SPRING CONFIG  - 仅使用环境属性（ConfigFileApplicationListener）"></a>SPRING CONFIG  - 仅使用环境属性（ConfigFileApplicationListener）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.config.additional-location = ＃配置除默认值之外使用的文件位置。</span><br><span class="line">spring.config.location = ＃配置替换默认值的文件位置。</span><br><span class="line">spring.config.name = application ＃配置文件名</span><br></pre></td></tr></table></figure><h3 id="HAZELCAST（HazelcastProperties）"><a href="#HAZELCAST（HazelcastProperties）" class="headerlink" title="HAZELCAST（HazelcastProperties）"></a>HAZELCAST（HazelcastProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.hazelcast.config = ＃用于初始化Hazelcast的配置文件的位置</span><br></pre></td></tr></table></figure><h3 id="PROJECT-INFORMATION（ProjectInfoProperties）"><a href="#PROJECT-INFORMATION（ProjectInfoProperties）" class="headerlink" title="PROJECT INFORMATION（ProjectInfoProperties）"></a>PROJECT INFORMATION（ProjectInfoProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.info.build.encoding = UTF-8 ＃文件编码。</span><br><span class="line">spring.info.build.location = classpath：META-INF / build-info.properties ＃生成的build-info.properties文件的位置。</span><br><span class="line">spring.info.git.encoding = UTF-8 ＃文件编码。</span><br><span class="line">spring.info.git.location =类路径：git.properties 生成的git.properties文件＃所在</span><br></pre></td></tr></table></figure><h3 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.jmx.default域 = ＃JMX域名。</span><br><span class="line">spring.jmx.enabled = true ＃将管理bean公开给JMX域。</span><br><span class="line">spring.jmx.server = mbeanServer ＃MBeanServer bean name。</span><br><span class="line">spring.jmx.unique-names = false ＃是否应确保唯一的运行时对象名称</span><br></pre></td></tr></table></figure><h3 id="Email-（MailProperties）"><a href="#Email-（MailProperties）" class="headerlink" title="Email （MailProperties）"></a>Email （MailProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.default-encoding = UTF-8 ＃默认MimeMessage编码。</span><br><span class="line">spring.mail.host = #SMTP 服务器主机。例如，`smtp.example.com`。</span><br><span class="line">spring.mail.jndi-name = ＃会话JNDI名称。设置时，优先于其他会话设置。</span><br><span class="line">spring.mail.password = #SMTP 服务器的登录密码。</span><br><span class="line">spring.mail.port = #SMTP 服务器端口。</span><br><span class="line">spring.mail.properties。* = ＃其他JavaMail会话属性。</span><br><span class="line">spring.mail.protocol = smtp ＃SMTP服务器使用的协议。</span><br><span class="line">spring.mail.test-connection = false＃是否在启动时测试邮件服务器是否可用。</span><br><span class="line">spring.mail.username = #SMTP 服务器的登录用户</span><br></pre></td></tr></table></figure><h3 id="APICING-SETTINGS（SpringApplication）"><a href="#APICING-SETTINGS（SpringApplication）" class="headerlink" title="APICING SETTINGS（SpringApplication）"></a>APICING SETTINGS（SpringApplication）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.main.allow-bean-definition-overriding = false ＃是否允许通过注册与现有定义同名的定义来覆盖bean定义。</span><br><span class="line">spring.main.banner-mode = console ＃模式用于在应用程序运行时显示横幅。</span><br><span class="line">spring.main.sources = 要包含在ApplicationContext中的</span><br></pre></td></tr></table></figure><h3 id="Sources-（类名，包名或XML资源位置）"><a href="#Sources-（类名，包名或XML资源位置）" class="headerlink" title="Sources （类名，包名或XML资源位置）"></a>Sources （类名，包名或XML资源位置）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.main.web-application-type = ＃用于显式请求特定类型的Web应用程序的标志。如果未设置，则基于类路径自动检测。</span><br></pre></td></tr></table></figure><h3 id="FILE-ENCODING（FileEncodingApplicationListener）"><a href="#FILE-ENCODING（FileEncodingApplicationListener）" class="headerlink" title="FILE ENCODING（FileEncodingApplicationListener）"></a>FILE ENCODING（FileEncodingApplicationListener）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mandatory-file-encoding = ＃应用程序必须使用的预期字符编码</span><br></pre></td></tr></table></figure><h3 id="INTERINGIZATION-（MessageSourceProperties）"><a href="#INTERINGIZATION-（MessageSourceProperties）" class="headerlink" title="INTERINGIZATION （MessageSourceProperties）"></a>INTERINGIZATION （MessageSourceProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.always-use-message-format = false ＃是否始终应用MessageFormat规则，甚至解析不带参数的消息。</span><br><span class="line">spring.messages.basename = messages ＃逗号分隔的basenames列表（本质上是一个完全限定的类路径位置），每个都遵循ResourceBundle约定，轻松支持基于斜杠的位置。</span><br><span class="line">spring.messages.cache-duration = ＃加载的资源包文件缓存持续时间。未设置时，捆绑包将永久缓存。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.messages.encoding = UTF-8 ＃消息包编码。</span><br><span class="line">spring.messages.fallback-to-system-locale = true ＃如果找不到特定区域设置的文件，是否回退到系统区域设置。</span><br><span class="line">spring.messages.use-code-as-default-message = false ＃是否使用消息代码作为默认消息而不是抛出“NoSuchMessageException”。仅在开发期间推荐。</span><br></pre></td></tr></table></figure><h3 id="OUTPUT"><a href="#OUTPUT" class="headerlink" title="OUTPUT"></a>OUTPUT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.output.ansi.enabled =检测＃配置的ANSI输出</span><br></pre></td></tr></table></figure><h3 id="PID-FILE（ApplicationPidFileWriter）"><a href="#PID-FILE（ApplicationPidFileWriter）" class="headerlink" title="PID FILE（ApplicationPidFileWriter）"></a>PID FILE（ApplicationPidFileWriter）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.pid.fail-on-write-error = ＃如果使用ApplicationPidFileWriter但它无法写入PID文件，则失败。</span><br><span class="line">spring.pid.file = ＃要写入的PID文件的位置（如果使用ApplicationPidFileWriter）</span><br></pre></td></tr></table></figure><h3 id="PROFILES"><a href="#PROFILES" class="headerlink" title="PROFILES"></a>PROFILES</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active = ＃逗号分隔的有源配置文件列表。可以通过命令行开关覆盖。</span><br><span class="line">spring.profiles.include = ＃无条件地激活指定的逗号分隔的配置文件列表（如果使用YAML，则激活配置文件列表）。</span><br></pre></td></tr></table></figure><h3 id="Quartz调度器（QuartzProperties）"><a href="#Quartz调度器（QuartzProperties）" class="headerlink" title="Quartz调度器（QuartzProperties）"></a>Quartz调度器（QuartzProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.auto-启动 =真＃是否自动启动初始化后的调度。</span><br><span class="line">spring.quartz.jdbc.comment-prefix =  - #SQL 初始化脚本中单行注释的前缀。</span><br><span class="line">spring.quartz.jdbc.initialize-schema = embedded ＃数据库模式初始化模式。</span><br><span class="line">spring.quartz.jdbc.schema = classpath：org / quartz / impl / jdbcjobstore / tables_ @ @ platform @@ .sql ＃用于初始化数据库模式的SQL文件的路径。</span><br><span class="line">spring.quartz.job-store-type = memory ＃Quartz作业存储类型。</span><br><span class="line">spring.quartz.overwrite-existing-jobs = false ＃配置的作业是否应覆盖现有的作业定义。</span><br><span class="line">spring.quartz.properties。* = ＃其他Quartz Scheduler属性。</span><br><span class="line">spring.quartz.scheduler-name = quartzScheduler ＃调度程序的名称。</span><br><span class="line">spring.quartz.startup-delay = 0s ＃一旦初始化完成，调度程序启动之后的延迟。</span><br><span class="line">spring.quartz.wait-for-jobs-to-complete-on-shutdown = false ＃是否等待在关闭时运行的作业完成。</span><br></pre></td></tr></table></figure><h3 id="REACTOR-（ReactorCoreProperties）"><a href="#REACTOR-（ReactorCoreProperties）" class="headerlink" title="REACTOR （ReactorCoreProperties）"></a>REACTOR （ReactorCoreProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.reactor.stacktrace -mode.enabled = false #Reactor 是否应该在运行时收集堆栈跟踪信息。</span><br></pre></td></tr></table></figure><h3 id="SENDGRID（SendGridAutoConfiguration）"><a href="#SENDGRID（SendGridAutoConfiguration）" class="headerlink" title="SENDGRID（SendGridAutoConfiguration）"></a>SENDGRID（SendGridAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.sendgrid.api-key = ＃SendGrid API密钥。</span><br><span class="line">spring.sendgrid.proxy.host = ＃SendGrid代理主机。</span><br><span class="line">spring.sendgrid.proxy.port = ＃SendGrid代理端口。</span><br></pre></td></tr></table></figure><h3 id="TASK-EXECUTION（TaskExecutionProperties）"><a href="#TASK-EXECUTION（TaskExecutionProperties）" class="headerlink" title="TASK EXECUTION（TaskExecutionProperties）"></a>TASK EXECUTION（TaskExecutionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.task.execution.pool.allow-core-thread-timeout = true ＃是否允许核心线程超时。这可以实现池的动态增长和收缩。</span><br><span class="line">spring.task.execution.pool.core-size = 8 ＃核心线程数。</span><br><span class="line">spring.task.execution.pool.keep-alive = 60s ＃终止之前线程可能保持空闲的时间限制。</span><br><span class="line">spring.task.execution.pool.max-size = ＃允许的最大线程数。如果任务正在填满队列，则池可以扩展到该大小以适应负载。如果队列无限制，则忽略。</span><br><span class="line">spring.task.execution.pool.queue-capacity =＃队列容量。无限制的容量不会增加池，因此会忽略“max-size”属性。</span><br><span class="line">spring.task.execution.thread-name-prefix = task- ＃用于新创建的线程名称的前缀。</span><br></pre></td></tr></table></figure><h3 id="TASK-SCHEDULING（TaskSchedulingProperties）"><a href="#TASK-SCHEDULING（TaskSchedulingProperties）" class="headerlink" title="TASK SCHEDULING（TaskSchedulingProperties）"></a>TASK SCHEDULING（TaskSchedulingProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.task.scheduling.pool.size = 1 ＃允许的最大线程数。</span><br><span class="line">spring.task.scheduling.thread-name-prefix = scheduling- ＃用于新创建的线程名称的前缀。</span><br></pre></td></tr></table></figure><h2 id="WEB-PROPERTIES"><a href="#WEB-PROPERTIES" class="headerlink" title="WEB PROPERTIES"></a>WEB PROPERTIES</h2><h3 id="EmbEDDED-SERVER-CONFIGURATION（ServerProperties）"><a href="#EmbEDDED-SERVER-CONFIGURATION（ServerProperties）" class="headerlink" title="EmbEDDED SERVER CONFIGURATION（ServerProperties）"></a>EmbEDDED SERVER CONFIGURATION（ServerProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">server.address = ＃服务器应绑定到的网络地址。</span><br><span class="line">server.compression.enabled = false ＃是否启用了响应压缩。</span><br><span class="line">server.compression.excluded-user-agents = ＃逗号分隔的用户代理列表，不应压缩响应。</span><br><span class="line">server.compression.mime-types = text / html，text / xml，text / plain，text / css，text / javascript，application / javascript，application / json，application / xml ＃逗号分隔的MIME类型列表应该是压缩。</span><br><span class="line">server.compression.min-response-size = 2KB＃执行压缩所需的最小“Content-Length”值。</span><br><span class="line">server.connection-timeout = ＃连接器在关闭连接之前等待另一个HTTP请求的时间。未设置时，将使用连接器的特定于容器的默认值。使用值-1表示没有（即无限）超时。</span><br><span class="line">server.error.include-exception = false ＃包含“exception”属性。</span><br><span class="line">server.error.include-stacktrace = never ＃何时包含“stacktrace”属性。</span><br><span class="line">server.error.path = / error ＃错误控制器的路径。</span><br><span class="line">server.error.whitelabel.enabled = true＃是否在服务器出错时启用浏览器中显示的默认错误页面。</span><br><span class="line">server.http2.enabled = false ＃是否启用HTTP / 2支持，如果当前环境支持它。</span><br><span class="line">server.jetty.acceptors = -1 ＃要使用的接受者线程数。当值为-1（默认值）时，接受器的数量是从操作环境派生的。</span><br><span class="line">server.jetty.accesslog.append = false ＃追加到日志。</span><br><span class="line">server.jetty.accesslog.date-format = dd / MMM / yyyy：HH：mm：ss Z ＃请求日志的时间戳格式。</span><br><span class="line">server.jetty.accesslog.enabled = false ＃启用访问日志。</span><br><span class="line">server.jetty.accesslog.extended-format = false＃启用扩展NCSA格式。</span><br><span class="line">server.jetty.accesslog.file-date-format = ＃日期文件名中的日期格式。</span><br><span class="line">server.jetty.accesslog.filename = ＃日志文件名。如果未指定，则日志重定向到“System.err”。</span><br><span class="line">server.jetty.accesslog.locale = ＃请求日志的区域设置。</span><br><span class="line">server.jetty.accesslog.log-cookies = false ＃启用请求cookie的记录。</span><br><span class="line">server.jetty.accesslog.log-latency = false ＃启用请求处理时间的记录。</span><br><span class="line">server.jetty.accesslog.log-server = false ＃启用请求主机名的日志记录。</span><br><span class="line">server.jetty.accesslog.retention-period = 31＃删除旋转日志文件之前的天数。</span><br><span class="line">server.jetty.accesslog.time-zone = GMT ＃请求日志的时区。</span><br><span class="line">server.jetty.max-http-post-size = 200000B #HTTP post或put内容的最大大小。</span><br><span class="line">server.jetty.selectors = -1 ＃要使用的选择器线程数。当值为-1（默认值）时，选择器的数量是从操作环境派生的。</span><br><span class="line">server.max-http-header-size = 8KB #HTTP 邮件头的最大大小。</span><br><span class="line">server.port = 8080 ＃服务器HTTP端口。</span><br><span class="line">server.server-header = ＃用于Server响应头的值（如果为空，则不发送头）。</span><br><span class="line">server.use-forward-headers = ＃是否应将X-Forwarded- *标头应用于HttpRequest。</span><br><span class="line">server.servlet.context-parameters。* = ＃Servlet context init参数。</span><br><span class="line">server.servlet.context-path = ＃应用程序的上下文路径。</span><br><span class="line">server.servlet.application-display-name = application ＃显示</span><br><span class="line">应用程序的名称。server.servlet.jsp.class-name = org.apache.jasper.servlet.JspServlet ＃用于JSP的servlet的类名。</span><br><span class="line">server.servlet.jsp.init-parameters。* = ＃用于配置JSP servlet的Init参数。</span><br><span class="line">server.servlet.jsp.registered = true＃是否已注册JSP servlet。</span><br><span class="line">server.servlet.session.cookie.comment = ＃会话cookie的评论。</span><br><span class="line">server.servlet.session.cookie.domain = ＃会话cookie的域名。</span><br><span class="line">server.servlet.session.cookie.http-only = ＃是否对会话cookie使用“HttpOnly”cookie。</span><br><span class="line">server.servlet.session.cookie.max-age = ＃会话cookie的最大年龄。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">server.servlet.session.cookie.name = ＃会话cookie名称。</span><br><span class="line">server.servlet.session.cookie.path = ＃会话cookie的路径。</span><br><span class="line">server.servlet.session.cookie.secure =＃是否始终将会话cookie标记为安全。</span><br><span class="line">server.servlet.session.persistent = false ＃是否在重新启动之间保留会话数据。</span><br><span class="line">server.servlet.session.store-dir = ＃用于存储会话数据的目录。</span><br><span class="line">server.servlet.session.timeout = 30m ＃会话超时。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">server.servlet.session.tracking-modes = ＃会话跟踪模式。</span><br><span class="line">server.ssl.ciphers = ＃支持的SSL密码。</span><br><span class="line">server.ssl.client-auth = ＃客户端身份验证模式。</span><br><span class="line">server.ssl.enabled = true ＃是否启用SSL支持。</span><br><span class="line">server.ssl.enabled-protocols = ＃启用SSL协议。</span><br><span class="line">server.ssl.key-alias = ＃标识密钥库中密钥的别名。</span><br><span class="line">server.ssl.key-password = ＃用于访问密钥库中密钥的密码。</span><br><span class="line">server.ssl.key-store = ＃保存SSL证书的密钥库的路径（通常是jks文件）。</span><br><span class="line">server.ssl.key-store-password = ＃用于访问密钥库的密码。</span><br><span class="line">server.ssl.key-store-provider = ＃密钥库的提供者。</span><br><span class="line">server.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">server.ssl.protocol = TLS ＃要使用的SSL协议。</span><br><span class="line">server.ssl.trust-store = ＃持有SSL证书的信任存储。</span><br><span class="line">server.ssl.trust-store-password = ＃用于访问信任库的密码。</span><br><span class="line">server.ssl.trust-store-provider = ＃信任存储的提供者。</span><br><span class="line">server.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">server.tomcat.accept-count = 100 ＃当所有可能的请求处理线程都在使用时，传入连接请求的最大队列长度。</span><br><span class="line">server.tomcat.accesslog.buffered = true ＃是否缓冲输出，使其仅定期刷新。</span><br><span class="line">server.tomcat.accesslog.directory = logs＃创建日志文件的目录。可以绝对或相对于Tomcat基础目录。</span><br><span class="line">server.tomcat.accesslog.enabled = false ＃启用访问日志。</span><br><span class="line">server.tomcat.accesslog.file-date-format = .yyyy-MM-dd ＃要放在日志文件名中的日期格式。</span><br><span class="line">server.tomcat.accesslog.pattern = common ＃访问日志的格式模式。</span><br><span class="line">server.tomcat.accesslog.prefix = access_log ＃日志文件名前缀。</span><br><span class="line">server.tomcat.accesslog.rename-on-rotate = false ＃是否延迟在文件名中包含日期戳，直到旋转时间。</span><br><span class="line">server.tomcat.accesslog.request-attributes-enabled = false＃设置请求的IP地址，主机名，协议和端口的请求属性。</span><br><span class="line">server.tomcat.accesslog.rotate = true ＃是否启用访问日志轮换。</span><br><span class="line">server.tomcat.accesslog.suffix = .log ＃日志文件名后缀。</span><br><span class="line">server.tomcat.additional-tld-skip-patterns = ＃逗号分隔的其他模式列表，这些模式匹配要忽略的TLD扫描的jar。</span><br><span class="line">server.tomcat.background-processor-delay = 10s #backgroundProcess 方法调用之间的延迟。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">server.tomcat.basedir = #Tomcat 基目录。如果未指定，则使用临时目录。</span><br><span class="line">server.tomcat.internal-proxies = 10 \\.\\ d &#123;1,3&#125; \\.\\ d &#123;1,3&#125; \\.\\ d &#123;1,3&#125; | \\</span><br><span class="line">.192 \\ 168 \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; | \\</span><br><span class="line">.169 \\ 254 \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; | \\</span><br><span class="line">.127 \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; | \\</span><br><span class="line">172 \\ 1 [6-9] &#123;1&#125; \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; |..\\</span><br><span class="line">172 \\ 2 [0-9] &#123;1&#125; \\ d &#123;1,3&#125; \\ d &#123;1,3&#125; |..\\</span><br><span class="line">172 \\.3 [0-1] &#123;1&#125; \\.\\ d &#123;1,3&#125; \\.\\ d &#123;1,3&#125; \\</span><br><span class="line">0：0：0：0：0：0：0：1 \\</span><br><span class="line"> :: 1 ＃正则表达式匹配要信任的代理。</span><br><span class="line">server.tomcat.max-connections = 10000 ＃服务器在任何给定时间接受和处理的最大连接数。</span><br><span class="line">server.tomcat.max-http-post-size = 2MB #HTTP 帖子内容的最大大小。</span><br><span class="line">server.tomcat.max-swallow-size = 2MB ＃要吞咽的请求正文的最大数量。</span><br><span class="line">server.tomcat.max-threads = 200 ＃最大工作线程数。</span><br><span class="line">server.tomcat.min-spare-threads = 10 ＃最小工作线程数。</span><br><span class="line">server.tomcat.port-header = X-Forwarded-Port＃用于覆盖原始端口值的HTTP头的名称。</span><br><span class="line">server.tomcat.protocol-header = ＃包含传入协议的头文件，通常命名为“X-Forwarded-Proto”。</span><br><span class="line">server.tomcat.protocol-header-https-value = https ＃协议标头的值，指示传入请求是否使用SSL。</span><br><span class="line">server.tomcat.redirect-context-root = true ＃是否应通过在路径中附加/来重定向对上下文根的请求。</span><br><span class="line">server.tomcat.remote-ip-header = ＃从中提取远程IP的HTTP头的名称。例如，`X-FORWARDED-FOR`。</span><br><span class="line">server.tomcat.resource.allow-caching = true＃是否允许此Web应用程序使用静态资源缓存。</span><br><span class="line">server.tomcat.resource.cache-ttl = ＃静态资源缓存的生存时间。</span><br><span class="line">server.tomcat.uri-encoding = UTF-8 ＃用于解码URI的字符编码。</span><br><span class="line">server.tomcat.use-relative-redirects = ＃通过调用sendRedirect生成的HTTP 1.1和更高版本的位置标头是使用相对还是绝对重定向。</span><br><span class="line">server.undertow.accesslog.dir = #Undertow 访问日志目录。</span><br><span class="line">server.undertow.accesslog.enabled = false ＃是否启用访问日志。</span><br><span class="line">server.undertow.accesslog.pattern = common ＃访问日志的格式模式。</span><br><span class="line">server.undertow.accesslog.prefix = access_log。＃日志文件名前缀。</span><br><span class="line">server.undertow.accesslog.rotate = true ＃是否启用访问日志轮换。</span><br><span class="line">server.undertow.accesslog.suffix = log ＃日志文件名后缀。</span><br><span class="line">server.undertow.buffer-size = ＃每个缓冲区的大小。</span><br><span class="line">server.undertow.direct-buffers = ＃是否在Java堆外部分配缓冲区。默认值源自JVM可用的最大内存量。</span><br><span class="line">server.undertow.eager-filter-init = true ＃是否应在启动时初始化servlet过滤器。</span><br><span class="line">server.undertow.io-threads =＃为worker创建的I / O线程数。默认值源自可用处理器的数量。</span><br><span class="line">server.undertow.max-http-post-size = -1B #HTTP 帖子内容的最大大小。当值为-1时，默认值为大小无限制。</span><br><span class="line">server.undertow.worker-threads = ＃工作线程数。默认值是I / O线程数的8倍。</span><br></pre></td></tr></table></figure><h3 id="FREEMARKER（FreeMarkerProperties）"><a href="#FREEMARKER（FreeMarkerProperties）" class="headerlink" title="FREEMARKER（FreeMarkerProperties）"></a>FREEMARKER（FreeMarkerProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring.freemarker.allow-request-override = false ＃是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.freemarker.allow-session-override = false ＃是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.freemarker.cache = false ＃是否启用模板缓存。</span><br><span class="line">spring.freemarker.charset = UTF-8 ＃模板编码。</span><br><span class="line">spring.freemarker.check-template-location = true ＃是否检查模板位置是否存在。</span><br><span class="line">spring.freemarker.content-type = text / html ＃Content-Type value。</span><br><span class="line">spring.freemarker.enabled = true ＃是否为此技术启用MVC视图分辨率。</span><br><span class="line">spring.freemarker.expose-request-attributes = false ＃是否应在与模板合并之前将所有请求属性添加到模型中。</span><br><span class="line">spring.freemarker.expose-session-attributes = false ＃是否应在与模板合并之前将所有HttpSession属性添加到模型中。</span><br><span class="line">spring.freemarker.expose-spring-macro-helpers = true ＃是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。</span><br><span class="line">spring.freemarker.prefer-file-system-access = true ＃是否更喜欢文件系统访问以进行模板加载。文件系统访问可以热检测模板更改。</span><br><span class="line">spring.freemarker.prefix = ＃在构建URL时添加前缀以查看名称的前缀。</span><br><span class="line">spring.freemarker.request-context-attribute = ＃所有视图的</span><br><span class="line">RequestContext属性的名称。spring.freemarker.settings。* = ＃众所周知的FreeMarker密钥，传递给FreeMarker的配置。</span><br><span class="line">spring.freemarker.suffix = .ftl ＃在构建URL时附加到视图名称的后缀。</span><br><span class="line">spring.freemarker.template-loader-path = classpath：/ templates /＃逗号分隔的模板路径列表。</span><br><span class="line">spring.freemarker.view-names = ＃可以解析的视图名称的白名单。</span><br></pre></td></tr></table></figure><h3 id="GLOVY-TEMPLATES（GroovyTemplateProperties）"><a href="#GLOVY-TEMPLATES（GroovyTemplateProperties）" class="headerlink" title="GLOVY TEMPLATES（GroovyTemplateProperties）"></a>GLOVY TEMPLATES（GroovyTemplateProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring.groovy.template.allow-request-override = false ＃是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.groovy.template.allow-session-override = false ＃是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.groovy.template.cache = false ＃是否启用模板缓存。</span><br><span class="line">spring.groovy.template.charset = UTF-8 ＃模板编码。</span><br><span class="line">spring.groovy.template.check-template-location = true＃是否检查模板位置是否存在。</span><br><span class="line">spring.groovy.template.configuration。* = ＃请参阅GroovyMarkupConfigurer </span><br><span class="line">spring.groovy.template.content-type = text / html ＃Content-Type value。</span><br><span class="line">spring.groovy.template.enabled = true ＃是否为此技术启用MVC视图分辨率。</span><br><span class="line">spring.groovy.template.expose-request-attributes = false ＃是否应在与模板合并之前将所有请求属性添加到模型中。</span><br><span class="line">spring.groovy.template.expose-session-attributes = false ＃在与模板合并之前是否应将所有HttpSession属性添加到模型中。</span><br><span class="line">spring.groovy.template.expose-spring-macro-helpers = true ＃是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。</span><br><span class="line">spring.groovy.template.prefix = ＃在构建URL时添加前缀以查看名称的前缀。</span><br><span class="line">spring.groovy.template.request-context-attribute = ＃所有视图的</span><br><span class="line">RequestContext属性的名称。spring.groovy.template.resource-loader-path = classpath：/ templates / ＃Template path。</span><br><span class="line">spring.groovy.template.suffix = .tpl ＃在构建URL时附加到视图名称的后缀。</span><br><span class="line">spring.groovy.template.view-names =＃可以解析的视图名称的白名单。</span><br></pre></td></tr></table></figure><h3 id="SPRING-HATEOAS（HateoasProperties）"><a href="#SPRING-HATEOAS（HateoasProperties）" class="headerlink" title="SPRING HATEOAS（HateoasProperties）"></a>SPRING HATEOAS（HateoasProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.hateoas.use-hal-as-default-json-media-type = true ＃是否应将application / hal + json响应发送给接受application / json的请求。</span><br></pre></td></tr></table></figure><h3 id="HTTP-（HttpProperties）"><a href="#HTTP-（HttpProperties）" class="headerlink" title="HTTP （HttpProperties）"></a>HTTP （HttpProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.http.converters.preferred-json-mapper = ＃用于HTTP消息转换的首选JSON映射器。默认情况下，根据环境自动检测。</span><br><span class="line">spring.http.encoding.charset = UTF-8 #HTTP 请求和响应的字符集。如果未明确设置，则添加到“Content-Type”标头。</span><br><span class="line">spring.http.encoding.enabled = true ＃是否启用http编码支持。</span><br><span class="line">spring.http.encoding.force = ＃是否在HTTP请求和响应上强制编码到已配置的字符集。</span><br><span class="line">spring.http.encoding.force-request =＃是否在HTTP请求中强制编码到配置的字符集。如果未指定“force”，则默认为true。</span><br><span class="line">spring.http.encoding.force-response = ＃是否在HTTP响应中强制编码到配置的字符集。</span><br><span class="line">spring.http.encoding.mapping = ＃用于编码映射的Locale。</span><br><span class="line">spring.http.log-request-details = false ＃是否允许在DEBUG和TRACE级别记录（可能敏感的）请求详细信息。</span><br></pre></td></tr></table></figure><h3 id="MULTIPART-（MultipartProperties）"><a href="#MULTIPART-（MultipartProperties）" class="headerlink" title="MULTIPART （MultipartProperties）"></a>MULTIPART （MultipartProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.servlet.multipart.enabled = true ＃是否启用分段上传支持。</span><br><span class="line">spring.servlet.multipart.file-size-threshold = 0B ＃将文件写入磁盘后的阈值。</span><br><span class="line">spring.servlet.multipart.location = ＃上传文件的中间位置。</span><br><span class="line">spring.servlet.multipart.max-file-size = 1MB ＃最大文件大小。</span><br><span class="line">spring.servlet.multipart.max-request-size = 10MB ＃最大请求大小。</span><br><span class="line">spring.servlet.multipart.resolve-lazily = false ＃是否在文件或参数访问时懒惰地解析多部分请求。</span><br></pre></td></tr></table></figure><h3 id="JACKSON-（JacksonProperties）"><a href="#JACKSON-（JacksonProperties）" class="headerlink" title="JACKSON （JacksonProperties）"></a>JACKSON （JacksonProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring.jackson.date-format = ＃日期格式字符串或完全限定的日期格式类名。例如，`yyyy-MM-dd HH：mm：ss`。</span><br><span class="line">spring.jackson.default-property-inclusion = ＃控制序列化期间包含的属性。配置了Jackson的JsonInclude.Include枚举中的一个值。</span><br><span class="line">spring.jackson.deserialization。* = #Jackson on / off功能会影响Java对象的反序列化方式。</span><br><span class="line">spring.jackson.generator。* = ＃Jackson开/关功能的发电机。</span><br><span class="line">spring.jackson.joda-date-time-format =#Joda日期时间格式字符串。如果未配置，如果使用格式字符串配置，则使用“date-format”作为后备。</span><br><span class="line">spring.jackson.locale = ＃用于格式化的区域设置。</span><br><span class="line">spring.jackson.mapper。* = #Jackson 通用开/关功能。</span><br><span class="line">spring.jackson.parser。* = ＃Jackson开启/关闭解析器的功能。</span><br><span class="line">spring.jackson.property-naming-strategy = #Jackson PropertyNamingStrategy的常数之一。也可以是PropertyNamingStrategy子类的完全限定类名。</span><br><span class="line">spring.jackson.serialization。* = #Jacker on / off功能会影响Java对象的序列化方式。</span><br><span class="line">spring.jackson.time-zone =＃格式化日期时使用的时区。例如，“America / Los_Angeles”或“GMT + 10”。</span><br><span class="line">spring.jackson.visibility。* = #Jackson 可见性阈值，可用于限制自动检测哪些方法（和字段）。</span><br></pre></td></tr></table></figure><h3 id="GSON（GsonProperties）"><a href="#GSON（GsonProperties）" class="headerlink" title="GSON（GsonProperties）"></a>GSON（GsonProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring.gson.date-format = ＃序列化Date对象时使用的格式。</span><br><span class="line">spring.gson.disable -html-escaping = ＃是否禁用HTML字符的转义，例如&apos;&lt;&apos;，&apos;&gt;&apos;等</span><br><span class="line">spring.gson.disable-inner-class-serialization = ＃是否在内容类中排除内部类序列化。</span><br><span class="line">spring.gson.enable-complex-map-key-serialization = ＃是否启用复杂映射键（即非基元）的序列化。</span><br><span class="line">spring.gson.exclude-fields-without-expose-annotation = ＃是否排除所有不考虑序列化或反序列化但没有“Expose”注释的字段。</span><br><span class="line">spring.gson.field-naming-policy = ＃在序列化和反序列化期间应该应用于对象字段的命名策略。</span><br><span class="line">spring.gson.generate-non-executable-json = ＃是否通过在输出前添加一些特殊文本来生成不可执行的JSON。</span><br><span class="line">spring.gson.lenient = ＃是否宽容解析不符合RFC 4627的</span><br><span class="line">JSON.chring.gson.long-serialization-policy = ＃长和长类型的序列化策略。</span><br><span class="line">spring.gson.pretty-printing = ＃是否输出适合页面的序列化JSON以进行漂亮的打印。</span><br><span class="line">spring.gson.serialize-nulls = ＃是否序列化空字段。</span><br></pre></td></tr></table></figure><h3 id="JERSEY-（JerseyProperties）"><a href="#JERSEY-（JerseyProperties）" class="headerlink" title="JERSEY （JerseyProperties）"></a>JERSEY （JerseyProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.jersey.application-path = ＃作为应用程序基URI的路径。如果指定，则覆盖“@ApplicationPath”的值。</span><br><span class="line">spring.jersey.filter.order = 0 ＃Jersey过滤链顺序。</span><br><span class="line">spring.jersey.init。* = ＃通过servlet或过滤器传递给Jersey的Init参数。</span><br><span class="line">spring.jersey.servlet.load-on-startup = -1 ＃加载Jersey servlet的启动优先级。</span><br><span class="line">spring.jersey.type = servlet ＃Jersey集成类型。</span><br></pre></td></tr></table></figure><h3 id="SPRING-LDAP（LdapProperties）"><a href="#SPRING-LDAP（LdapProperties）" class="headerlink" title="SPRING LDAP（LdapProperties）"></a>SPRING LDAP（LdapProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.anonymous-read-only = false ＃只读操作是否应使用匿名环境。</span><br><span class="line">spring.ldap.base = #Base 后缀，所有操作都应该来自该后缀。</span><br><span class="line">spring.ldap.base-environment。* = #LDAP 规范设置。</span><br><span class="line">spring.ldap.password = ＃服务器的登录密码。</span><br><span class="line">spring.ldap.urls = ＃服务器的LDAP URL。</span><br><span class="line">spring.ldap.username = ＃登录服务器的用户名。</span><br></pre></td></tr></table></figure><h3 id="EMBEDDED-LDAP（EmbeddedLdapProperties）"><a href="#EMBEDDED-LDAP（EmbeddedLdapProperties）" class="headerlink" title="EMBEDDED LDAP（EmbeddedLdapProperties）"></a>EMBEDDED LDAP（EmbeddedLdapProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.embedded.base-dn = ＃基本DN列表。</span><br><span class="line">spring.ldap.embedded.credential.username = ＃嵌入式LDAP用户名。</span><br><span class="line">spring.ldap.embedded.credential.password = ＃嵌入式LDAP密码。</span><br><span class="line">spring.ldap.embedded.ldif = classpath：schema.ldif #Schema （LDIF）脚本资源引用。</span><br><span class="line">spring.ldap.embedded.port = 0 ＃嵌入式LDAP端口。</span><br><span class="line">spring.ldap.embedded.validation.enabled = true ＃是否启用LDAP模式验证。</span><br><span class="line">spring.ldap.embedded.validation.schema = ＃自定义架构的路径。</span><br></pre></td></tr></table></figure><h3 id="MUSTACHE-TEMPLATES（MustacheAutoConfiguration）"><a href="#MUSTACHE-TEMPLATES（MustacheAutoConfiguration）" class="headerlink" title="MUSTACHE TEMPLATES（MustacheAutoConfiguration）"></a>MUSTACHE TEMPLATES（MustacheAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring.mustache.allow-request-override = false ＃是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.mustache.allow-session-override = false ＃是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。</span><br><span class="line">spring.mustache.cache = false ＃是否启用模板缓存。</span><br><span class="line">spring.mustache.charset = UTF-8 ＃模板编码。</span><br><span class="line">spring.mustache.check-template-location = true ＃是否检查模板位置是否存在。</span><br><span class="line">spring.mustache.content-type = text / html ＃Content-Type value。</span><br><span class="line">spring.mustache.enabled = true ＃是否为此技术启用MVC视图分辨率。</span><br><span class="line">spring.mustache.expose-request-attributes = false ＃在与模板合并之前是否应将所有请求属性添加到模型中。</span><br><span class="line">spring.mustache.expose-session-attributes = false ＃在与模板合并之前是否应将所有HttpSession属性添加到模型中。</span><br><span class="line">spring.mustache.expose-spring-macro-helpers = true ＃是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。</span><br><span class="line">spring.mustache.prefix= classpath：/ templates / ＃适用于模板名称的前缀。</span><br><span class="line">spring.mustache.request-context-attribute = ＃所有视图的</span><br><span class="line">RequestContext属性的名称。spring.mustache.suffix = .mustache ＃后缀应用于模板名称。</span><br><span class="line">spring.mustache.view-names = ＃可以解析的视图名称的白名单。</span><br></pre></td></tr></table></figure><h3 id="SPRING-MVC（WebMvcProperties）"><a href="#SPRING-MVC（WebMvcProperties）" class="headerlink" title="SPRING MVC（WebMvcProperties）"></a>SPRING MVC（WebMvcProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.async.request-timeout = ＃异步请求处理超时之前的时间。</span><br><span class="line">spring.mvc.contentnegotiation.favor-parameter = false ＃是否应使用请求参数（默认为“format”）来确定请求的媒体类型。</span><br><span class="line">spring.mvc.contentnegotiation.favor-path-extension = false ＃是否应使用URL路径中的路径扩展来确定所请求的媒体类型。</span><br><span class="line">spring.mvc.contentnegotiation.media-types。* = ＃映射内容协商的媒体类型的文件扩展名。例如，yml到text / yaml。</span><br><span class="line">spring.mvc.contentnegotiation.parameter-name =＃启用“favor-parameter”时要使用的查询参数名称。</span><br><span class="line">spring.mvc.date-format = ＃要使用的日期格式。例如，`dd / MM / yyyy`。</span><br><span class="line">spring.mvc.dispatch-trace-request = false ＃是否将TRACE请求分派给FrameworkServlet doService方法。</span><br><span class="line">spring.mvc.dispatch-options-request = true ＃是否将OPTIONS请求分派给FrameworkServlet doService方法。</span><br><span class="line">spring.mvc.favicon.enabled = true ＃是否启用favicon.ico的解析。</span><br><span class="line">spring.mvc.formcontent.filter.enabled = true ＃是否启用Spring的FormContentFilter。</span><br><span class="line">spring.mvc.hiddenmethod.filter.enabled = true＃是否启用Spring的HiddenHttpMethodFilter。</span><br><span class="line">spring.mvc.ignore-default-model-on-redirect = true ＃在重定向场景中是否应忽略“默认”模型的内容。</span><br><span class="line">spring.mvc.locale = ＃要使用的语言环境。默认情况下，“Accept-Language”标头会覆盖此区域设置。</span><br><span class="line">spring.mvc.locale-resolver = accept-header ＃定义应如何解析语言环境。</span><br><span class="line">spring.mvc.log-resolved-exception = false ＃是否启用由“HandlerExceptionResolver”解析的异常的警告日志记录，“DefaultHandlerExceptionResolver”除外。</span><br><span class="line">spring.mvc.message-codes-resolver-format =＃格式化消息代码的策略。例如，`PREFIX_ERROR_CODE`。</span><br><span class="line">spring.mvc.pathmatch.use-registered-suffix-pattern = false ＃后缀模式匹配是否仅适用于使用“spring.mvc.contentnegotiation.media-types。*”注册的扩展。</span><br><span class="line">spring.mvc.pathmatch.use-suffix-pattern = false ＃将模式与请求匹配时是否使用后缀模式匹配（“。*”）。</span><br><span class="line">spring.mvc.servlet.load-on-startup = -1 ＃加载调度程序servlet的启动优先级。</span><br><span class="line">spring.mvc.servlet.path = / ＃调度程序servlet的路径。</span><br><span class="line">spring.mvc.static-path-pattern = / ** ＃用于静态资源的路径模式。</span><br><span class="line">spring.mvc.throw-exception-if-no-handler-found = false ＃如果没有找到Handler来处理请求，是否应该抛出“NoHandlerFoundException”。</span><br><span class="line">spring.mvc.view.prefix = #Spring MVC视图前缀。</span><br><span class="line">spring.mvc.view.suffix = #Spring MVC视图后缀。</span><br></pre></td></tr></table></figure><h3 id="SPRING-RESOURCES-HANDLING（ResourceProperties）"><a href="#SPRING-RESOURCES-HANDLING（ResourceProperties）" class="headerlink" title="SPRING RESOURCES HANDLING（ResourceProperties）"></a>SPRING RESOURCES HANDLING（ResourceProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.add-mappings = true ＃是否启用默认资源处理。</span><br><span class="line">spring.resources.cache.cachecontrol.cache-private = ＃表示响应消息仅供单个用户使用，不得由共享高速缓存存储。</span><br><span class="line">spring.resources.cache.cachecontrol.cache-public = ＃表示任何缓存都可以存储响应。</span><br><span class="line">spring.resources.cache.cachecontrol.max-age = ＃应该缓存响应的最长时间，如果未指定持续时间后缀，则以秒为单位。</span><br><span class="line">spring.resources.cache.cachecontrol.must-revalidate =＃表示一旦它变得陈旧，缓存一定不能使用响应而不用服务器重新验证它。</span><br><span class="line">spring.resources.cache.cachecontrol.no-cache = ＃表示只有在与服务器重新验证时才能重用缓存的响应。</span><br><span class="line">spring.resources.cache.cachecontrol.no-store = ＃表示在任何情况下都不缓存响应。</span><br><span class="line">spring.resources.cache.cachecontrol.no-transform = ＃表明他们不应该转换响应内容的中介（缓存和其他人）。</span><br><span class="line">spring.resources.cache.cachecontrol.proxy-revalidate = ＃与“must-revalidate”指令的含义相同，但它不适用于私有缓存。</span><br><span class="line">spring.resources.cache.cachecontrol.s-max-age = ＃共享缓存应缓存响应的最长时间，如果未指定持续时间后缀，则以秒为单位。</span><br><span class="line">spring.resources.cache.cachecontrol.stale-if-error = ＃遇到错误时可以使用响应的最长时间，如果未指定持续时间后缀，则以秒为单位。</span><br><span class="line">spring.resources.cache.cachecontrol.stale-while-revalidate = ＃响应变为失效后可以响应的最长时间，如果未指定持续时间后缀，则以秒为单位。</span><br><span class="line">spring.resources.cache.period = ＃资源处理程序所服务资源的缓存周期。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.resources.chain.cache= true ＃是否在资源链中启用缓存。</span><br><span class="line">spring.resources.chain.compressed = false ＃是否启用已压缩资源的解析（gzip，brotli）。</span><br><span class="line">spring.resources.chain.enabled = ＃是否启用Spring资源处理链。默认情况下，禁用，除非至少启用了一个策略。</span><br><span class="line">spring.resources.chain.html-application-cache = false ＃是否启用HTML5应用程序缓存清单重写。</span><br><span class="line">spring.resources.chain.strategy.content.enabled = false ＃是否启用内容版本策略。</span><br><span class="line">spring.resources.chain.strategy.content.paths = / **＃逗号分隔的模式列表，应用于内容版本策略。</span><br><span class="line">spring.resources.chain.strategy.fixed.enabled = false ＃是否启用固定版本策略。</span><br><span class="line">spring.resources.chain.strategy.fixed.paths = / ** ＃以逗号分隔的模式列表应用于固定版本策略。</span><br><span class="line">spring.resources.chain.strategy.fixed.version = ＃用于固定版本策略的版本字符串。</span><br><span class="line">spring.resources.static-locations = classpath：/ META-INF / resources /，classpath：/ resources /，classpath：/ static /，classpath：/ public / ＃静态资源的位置。</span><br></pre></td></tr></table></figure><h3 id="SPRING-SESSION（SessionProperties）"><a href="#SPRING-SESSION（SessionProperties）" class="headerlink" title="SPRING SESSION（SessionProperties）"></a>SPRING SESSION（SessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.session.store-type = ＃会话存储类型。</span><br><span class="line">spring.session.timeout = ＃会话超时。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.session.servlet.filter-order = -2147483598 ＃会话存储库过滤顺序。</span><br><span class="line">spring.session.servlet.filter-dispatcher-types = async，error，request ＃会话存储库过滤器调度程序类型。</span><br></pre></td></tr></table></figure><h3 id="SPRING-SESSION-HAZELCAST（HazelcastSessionProperties）"><a href="#SPRING-SESSION-HAZELCAST（HazelcastSessionProperties）" class="headerlink" title="SPRING SESSION HAZELCAST（HazelcastSessionProperties）"></a>SPRING SESSION HAZELCAST（HazelcastSessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.session.hazelcast.flush-mode = on-save #sessions flush mode。</span><br><span class="line">spring.session.hazelcast.map-name = spring：session：sessions ＃用于存储会话的地图的名称。</span><br></pre></td></tr></table></figure><h3 id="SPRING-SESSION-JDBC（JdbcSessionProperties）"><a href="#SPRING-SESSION-JDBC（JdbcSessionProperties）" class="headerlink" title="SPRING SESSION JDBC（JdbcSessionProperties）"></a>SPRING SESSION JDBC（JdbcSessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.session.jdbc.cleanup-cron = 0 * * * * * #cron 表达式用于过期的会话清理作业。</span><br><span class="line">spring.session.jdbc.initialize-schema = embedded ＃数据库模式初始化模式。</span><br><span class="line">spring.session.jdbc.schema = classpath中：组织/ springframework的/会话/ JDBC / schema- @ @ 平台@ @ .SQL ＃的路径SQL文件，以用于初始化数据库架构。</span><br><span class="line">spring.session.jdbc.table-name = SPRING_SESSION ＃用于存储会话的数据库表的名称。</span><br></pre></td></tr></table></figure><h3 id="SPRING-SESSION-MONGODB（MongoSessionProperties）"><a href="#SPRING-SESSION-MONGODB（MongoSessionProperties）" class="headerlink" title="SPRING SESSION MONGODB（MongoSessionProperties）"></a>SPRING SESSION MONGODB（MongoSessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.mongodb.collection-name = sessions ＃用于存储会话的集合名称。</span><br></pre></td></tr></table></figure><h3 id="SPRING-SESSION-REDIS（RedisSessionProperties）"><a href="#SPRING-SESSION-REDIS（RedisSessionProperties）" class="headerlink" title="SPRING SESSION REDIS（RedisSessionProperties）"></a>SPRING SESSION REDIS（RedisSessionProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.session.redis.cleanup-cron = 0 * * * * * #cron 表达式用于过期的会话清理作业。</span><br><span class="line">spring.session.redis.flush-mode = on-save #sessions flush mode。</span><br><span class="line">spring.session.redis.namespace = spring：session ＃用于存储会话的密钥的命名空间。</span><br></pre></td></tr></table></figure><h3 id="THYMELEAF（ThymeleafAutoConfiguration）"><a href="#THYMELEAF（ThymeleafAutoConfiguration）" class="headerlink" title="THYMELEAF（ThymeleafAutoConfiguration）"></a>THYMELEAF（ThymeleafAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring.thymeleaf.cache = true ＃是否启用模板缓存。</span><br><span class="line">spring.thymeleaf.check-template = true ＃是否在呈现模板之前检查模板是否存在。</span><br><span class="line">spring.thymeleaf.check-template-location = true ＃是否检查模板位置是否存在。</span><br><span class="line">spring.thymeleaf.enabled = true ＃是否为Web框架启用Thymeleaf视图解析。</span><br><span class="line">spring.thymeleaf.enable-spring-el-compiler = false ＃在SpringEL表达式中启用SpringEL编译器。</span><br><span class="line">spring.thymeleaf.encoding = UTF-8 ＃模板文件编码。</span><br><span class="line">spring.thymeleaf.excluded-view-names = ＃逗号分隔的视图名称列表（允许的模式）应从分辨率中排除。</span><br><span class="line">spring.thymeleaf.mode = HTML ＃要应用于模板的模板模式。另请参见Thymeleaf的TemplateMode枚举。</span><br><span class="line">spring.thymeleaf.prefix = classpath：/ templates / ＃在构建URL时添加前缀以查看名称的前缀。</span><br><span class="line">spring.thymeleaf.reactive.chunked-mode-view-names = ＃逗号分隔的视图名称列表（允许的模式），当设置了最大块大小时，它应该是在CHUNKED模式下执行的唯一列表。</span><br><span class="line">spring.thymeleaf.reactive.full-mode-view-names =＃逗号分隔的视图名称列表（允许的模式），即使设置了最大块大小，也应该在FULL模式下执行。</span><br><span class="line">spring.thymeleaf.reactive.max-chunk-size = 0B ＃用于写入响应的数据缓冲区的最大大小。</span><br><span class="line">spring.thymeleaf.reactive.media-types = ＃视图技术支持的媒体类型。</span><br><span class="line">spring.thymeleaf.render-hidden-markers-before-checkboxes = false ＃是否应在复选框元素本身之前呈现隐藏的表单输入作为复选框的标记。</span><br><span class="line">spring.thymeleaf.servlet.content-type = text / html ＃Content-Type写入HTTP响应的值。</span><br><span class="line">spring.thymeleaf.servlet.produce-partial-output-while-processing = true#Thymeleaf是否应尽快开始编写部分输出或缓冲直到模板处理完成。</span><br><span class="line">spring.thymeleaf.suffix = .html ＃在构建URL时附加到视图名称的后缀。</span><br><span class="line">spring.thymeleaf.template-resolver-order = ＃链中模板解析器的顺序。</span><br><span class="line">spring.thymeleaf.view-names = ＃逗号分隔的视图名称列表（允许的模式），可以解析。</span><br></pre></td></tr></table></figure><h3 id="SPRING-WEBFLUX（WebFluxProperties）"><a href="#SPRING-WEBFLUX（WebFluxProperties）" class="headerlink" title="SPRING WEBFLUX（WebFluxProperties）"></a>SPRING WEBFLUX（WebFluxProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.webflux.date-format = ＃要使用的日期格式。例如，`dd / MM / yyyy`。</span><br><span class="line">spring.webflux.hiddenmethod.filter.enabled = true ＃是否启用Spring的HiddenHttpMethodFilter。</span><br><span class="line">spring.webflux.static-path-pattern = / ** ＃用于静态资源的路径模式。</span><br></pre></td></tr></table></figure><h3 id="SPRING-WEB-SERVICES（WebServicesProperties）"><a href="#SPRING-WEB-SERVICES（WebServicesProperties）" class="headerlink" title="SPRING WEB SERVICES（WebServicesProperties）"></a>SPRING WEB SERVICES（WebServicesProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.webservices.path = / services ＃作为服务基URI的路径。</span><br><span class="line">spring.webservices.servlet.init = ＃Servlet init参数传递给Spring Web Services。</span><br><span class="line">spring.webservices.servlet.load-on-startup = -1 ＃加载Spring Web Services servlet的启动优先级。</span><br><span class="line">spring.webservices.wsdl-locations = ＃逗号分隔的WSDL位置列表以及要作为bean公开的随附XSD。</span><br></pre></td></tr></table></figure><h2 id="SECURITY-PROPERTIES"><a href="#SECURITY-PROPERTIES" class="headerlink" title="SECURITY PROPERTIES"></a>SECURITY PROPERTIES</h2><h3 id="SECURITY（SecurityProperties）"><a href="#SECURITY（SecurityProperties）" class="headerlink" title="SECURITY（SecurityProperties）"></a>SECURITY（SecurityProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.security.filter.order = -100 ＃安全过滤器链顺序。</span><br><span class="line">spring.security.filter.dispatcher-types = async，error，request ＃安全过滤器链调度程序类型。</span><br><span class="line">spring.security.user.name = user ＃默认用户名。</span><br><span class="line">spring.security.user.password = ＃默认用户名的密码。</span><br><span class="line">spring.security.user.roles = ＃授予默认用户名的角色。</span><br></pre></td></tr></table></figure><h3 id="SECURITY-OAUTH2-CLIENT（OAuth2ClientProperties）"><a href="#SECURITY-OAUTH2-CLIENT（OAuth2ClientProperties）" class="headerlink" title="SECURITY OAUTH2 CLIENT（OAuth2ClientProperties）"></a>SECURITY OAUTH2 CLIENT（OAuth2ClientProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.provider。* = ＃OAuth提供商详细信息。</span><br><span class="line">spring.security.oauth2.client.registration。* = ＃OAuth客户注册。</span><br></pre></td></tr></table></figure><h3 id="SECURITY-OAUTH2-RESOURCE-SERVER（OAuth2ResourceServerProperties）"><a href="#SECURITY-OAUTH2-RESOURCE-SERVER（OAuth2ResourceServerProperties）" class="headerlink" title="SECURITY OAUTH2 RESOURCE SERVER（OAuth2ResourceServerProperties）"></a>SECURITY OAUTH2 RESOURCE SERVER（OAuth2ResourceServerProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.resourceserver.jwt.jwk-set-uri = ＃JSON用于验证JWT令牌的Web Key URI。</span><br><span class="line">spring.security.oauth2.resourceserver.jwt.issuer-uri = #OpenID Connect Provider声明为其颁发者标识符的URI。</span><br></pre></td></tr></table></figure><h2 id="DATA-PROPERTIES"><a href="#DATA-PROPERTIES" class="headerlink" title="DATA PROPERTIES"></a>DATA PROPERTIES</h2><h3 id="FLYWAY-（FlywayProperties）"><a href="#FLYWAY-（FlywayProperties）" class="headerlink" title="FLYWAY （FlywayProperties）"></a>FLYWAY （FlywayProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">spring.flyway.baseline-description = &lt;&lt; Flyway Baseline &gt;&gt; ＃描述在应用基线时标记现有模式。</span><br><span class="line">spring.flyway.baseline-on-migrate = false ＃是否在迁移非空架构时自动调用基线。</span><br><span class="line">spring.flyway.baseline-version = 1 ＃用于在执行基线时标记现有模式的版本。</span><br><span class="line">spring.flyway.check-location = true ＃是否检查迁移脚本位置是否存在。</span><br><span class="line">spring.flyway.clean-disabled = false ＃是否禁用数据库清理。</span><br><span class="line">spring.flyway.clean-on-validation-error = false＃发生验证错误时是否自动调用clean。</span><br><span class="line">spring.flyway.connect-retries = 0 ＃尝试连接数据库时的最大重试次数。</span><br><span class="line">spring.flyway.enabled = true ＃是否启用flyway。</span><br><span class="line">spring.flyway.encoding = UTF-8 #SQL 迁移的编码。</span><br><span class="line">spring.flyway.group = false ＃是否在应用它们时在同一事务中将所有挂起的迁移组合在一起。</span><br><span class="line">spring.flyway.ignore-future-migrations = true ＃在读取架构历史记录表时是否忽略未来的迁移。</span><br><span class="line">spring.flyway.ignore-ignored-migrations = false＃是否在读取模式历史记录表时忽略忽略的迁移。</span><br><span class="line">spring.flyway.ignore-missing-migrations = false ＃是否在读取模式历史记录表时忽略缺少的迁移。</span><br><span class="line">spring.flyway.ignore-pending-migrations = false ＃在读取架构历史记录表时是否忽略挂起的迁移。</span><br><span class="line">spring.flyway.init-sqls = ＃在获取连接后立即执行以初始化连接的SQL语句。</span><br><span class="line">spring.flyway.installed-by = ＃用户名在架构历史记录表中记录为已应用迁移。</span><br><span class="line">spring.flyway.locations = classpath：db / migration＃迁移脚本的位置。可以包含特殊的“&#123;vendor&#125;”占位符以使用特定于供应商的位置。</span><br><span class="line">spring.flyway.mixed = false ＃是否允许在同一迁移中混合事务和非事务语句。</span><br><span class="line">spring.flyway.out-of-order = false ＃是否允许迁移无序运行。</span><br><span class="line">spring.flyway.password = ＃要迁移的数据库的登录密码。</span><br><span class="line">spring.flyway.placeholder-prefix = $ &#123; ＃迁移脚本中占位符的前缀。</span><br><span class="line">spring.flyway.placeholder-replacement = true ＃在迁移脚本中执行占位符替换。</span><br><span class="line">spring.flyway.placeholder-suffix =&#125;＃迁移脚本中占位符的后缀。</span><br><span class="line">spring.flyway.placeholders = ＃占位符及其替换应用于sql迁移脚本。</span><br><span class="line">spring.flyway.repeatable-sql-migration-prefix = R ＃可重复SQL迁移的文件名前缀。</span><br><span class="line">spring.flyway.schemas = ＃由Flyway 管理的方案名称（区分大小写）。</span><br><span class="line">spring.flyway.skip-default-callbacks = false ＃是否跳过默认回调。如果为true，则仅使用自定义回调。</span><br><span class="line">spring.flyway.skip-default-resolvers = false ＃是否跳过默认的解析器。如果为true，则仅使用自定义解析程序。</span><br><span class="line">spring.flyway.sql-migration-prefix = V.#SQL迁移的文件名前缀。</span><br><span class="line">spring.flyway.sql-migration-separator = __ #SQL迁移的文件名分隔符。</span><br><span class="line">spring.flyway.sql-migration-suffixes = .sql #SQL迁移的文件名后缀。</span><br><span class="line">spring.flyway.table = flyway_schema_history ＃将由 Flyway 使用的架构架构历史记录表的名称。</span><br><span class="line">spring.flyway.target = ＃应考虑迁移的目标版本。</span><br><span class="line">spring.flyway.url = 要迁移的数据库的JDBC url。如果未设置，则使用主要配置的数据源。</span><br><span class="line">spring.flyway.user = ＃要迁移的数据库的登录用户。</span><br><span class="line">spring.flyway.validate-on-migrate = true ＃是否在执行迁移时自动调用validate。</span><br></pre></td></tr></table></figure><h3 id="LIQUIBASE（LiquibaseProperties）"><a href="#LIQUIBASE（LiquibaseProperties）" class="headerlink" title="LIQUIBASE（LiquibaseProperties）"></a>LIQUIBASE（LiquibaseProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring.liquibase.change-log = classpath：/db/changelog/db.changelog-master.yaml# 更改日志配置路径。</span><br><span class="line">spring.liquibase.check-change-log-location = true ＃是否检查更改日志位置是否存在。</span><br><span class="line">spring.liquibase.contexts = ＃逗号分隔的运行时上下文列表。</span><br><span class="line">spring.liquibase.database-change-log-lock-table = DATABASECHANGELOGLOCK ＃用于跟踪并发Liquibase用法的表的名称。</span><br><span class="line">spring.liquibase.database-change-log-table = DATABASECHANGELOG ＃用于跟踪更改历史记录的表的名称。</span><br><span class="line">spring.liquibase.default-model= ＃默认数据库架构。</span><br><span class="line">spring.liquibase.drop-first = false ＃是否首先删除数据库模式。</span><br><span class="line">spring.liquibase.enabled = true ＃是否启用Liquibase支持。</span><br><span class="line">spring.liquibase.labels = ＃逗号分隔的运行时标签列表。</span><br><span class="line">spring.liquibase.liquibase-schema = #Schema用于Liquibase对象。</span><br><span class="line">spring.liquibase.liquibase-tablespace = ＃用于Liquibase对象的表空间。</span><br><span class="line">spring.liquibase.parameters。* = ＃更改日志参数。</span><br><span class="line">spring.liquibase.password = ＃要迁移的数据库的登录密码。</span><br><span class="line">spring.liquibase.rollback-file = ＃执行更新时写入回滚SQL的文件。</span><br><span class="line">spring.liquibase.test-rollback-on-update = false ＃是否应在执行更新之前测试回滚。</span><br><span class="line">spring.liquibase.url = ＃JDBC要迁移的数据库的URL。如果未设置，则使用主要配置的数据源。</span><br><span class="line">spring.liquibase.user = ＃要迁移的数据库的登录用户。</span><br></pre></td></tr></table></figure><h3 id="COUCHBASE（CouchbaseProperties）"><a href="#COUCHBASE（CouchbaseProperties）" class="headerlink" title="COUCHBASE（CouchbaseProperties）"></a>COUCHBASE（CouchbaseProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring.couchbase.bootstrap-hosts = #Couchbase 节点（主机或IP地址）来自引导程序。</span><br><span class="line">spring.couchbase.bucket.name = default ＃要连接的存储桶的名称。</span><br><span class="line">spring.couchbase.bucket.password =   ＃桶的密码。</span><br><span class="line">spring.couchbase.env.endpoints.key-value = 1 ＃针对键/值服务的每个节点的套接字数。</span><br><span class="line">spring.couchbase.env.endpoints.queryservice.min-endpoints = 1 ＃每个节点的最小套接字数。</span><br><span class="line">spring.couchbase.env.endpoints.queryservice.max-endpoints = 1 ＃每个节点的最大套接字数。</span><br><span class="line">spring.couchbase.env.endpoints.viewservice.min-endpoints = 1 ＃每个节点的最小套接字数。</span><br><span class="line">spring.couchbase.env.endpoints.viewservice.max-endpoints = 1 ＃每个节点的最大套接字数。</span><br><span class="line">spring.couchbase.env.ssl.enabled = ＃是否启用SSL支持。除非另有说明，否则在提供“keyStore”时自动启用。</span><br><span class="line">spring.couchbase.env.ssl.key-store = ＃保存证书的JVM密钥库的路径。</span><br><span class="line">spring.couchbase.env.ssl.key-store-password = ＃用于访问密钥库的密码。</span><br><span class="line">spring.couchbase.env.timeouts.connect = 5000ms ＃桶连接超时。</span><br><span class="line">spring.couchbase.env.timeouts.key-value = 2500ms ＃对特定密钥超时执行的阻止操作。</span><br><span class="line">spring.couchbase.env.timeouts.query = 7500ms ＃N1QL查询操作超时。</span><br><span class="line">spring.couchbase.env.timeouts.socket-connect = 1000ms #Socket 连接超时。</span><br><span class="line">spring.couchbase.env.timeouts.view = 7500ms ＃常规和地理空间视图操作超时。</span><br></pre></td></tr></table></figure><h3 id="DAO-（PersistenceExceptionTranslationAutoConfiguration）"><a href="#DAO-（PersistenceExceptionTranslationAutoConfiguration）" class="headerlink" title="DAO （PersistenceExceptionTranslationAutoConfiguration）"></a>DAO （PersistenceExceptionTranslationAutoConfiguration）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.dao.exceptiontranslation.enabled = true ＃是否启用PersistenceExceptionTranslationPostProcessor。</span><br></pre></td></tr></table></figure><h3 id="CASSANDRA-（CassandraProperties）"><a href="#CASSANDRA-（CassandraProperties）" class="headerlink" title="CASSANDRA （CassandraProperties）"></a>CASSANDRA （CassandraProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring.data.cassandra.cluster-name = #Cassandra 集群的名称。</span><br><span class="line">spring.data.cassandra.compression = none ＃Cassandra二进制协议支持的压缩。</span><br><span class="line">spring.data.cassandra.connect-timeout = #Socket 选项：连接超时。</span><br><span class="line">spring.data.cassandra.consistency-level = ＃查询一致性级别。</span><br><span class="line">spring.data.cassandra.contact-points = localhost ＃群集节点地址。</span><br><span class="line">spring.data.cassandra.fetch-size = ＃查询默认提取大小。</span><br><span class="line">spring.data.cassandra.jmx-enabled = false＃是否启用JMX报告。</span><br><span class="line">spring.data.cassandra.keyspace-name = ＃要使用的Keyspace名称。</span><br><span class="line">spring.data.cassandra.port = #Cassandra 服务器的端口。</span><br><span class="line">spring.data.cassandra.password = ＃服务器的登录密码。</span><br><span class="line">spring.data.cassandra.pool.heartbeat-interval = 30s #Heartbeat interval，在此之后，在空闲连接上发送消息以确保它仍然存在。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.data.cassandra.pool.idle-timeout = 120s ＃删除空闲连接之前的空闲超时。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.data.cassandra.pool.max队列大小= 256 ＃如果没有可用连接，则排队的最大请求数。</span><br><span class="line">spring.data.cassandra.pool.pool-timeout = 5000ms ＃尝试从主机池获取连接时的池超时。</span><br><span class="line">spring.data.cassandra.read-timeout = #Socket 选项：读取超时。</span><br><span class="line">spring.data.cassandra.repositories.type = auto ＃要启用的Cassandra存储库的类型。</span><br><span class="line">spring.data.cassandra.serial-consistency-level = ＃查询串行一致性级别。</span><br><span class="line">spring.data.cassandra.schema-action = none ＃启动时要采取的架构操作。</span><br><span class="line">spring.data.cassandra.ssl = false ＃启用SSL支持。</span><br><span class="line">spring.data.cassandra.username = ＃服务器的登录用户。</span><br></pre></td></tr></table></figure><h3 id="DATA-COUCHBASE（CouchbaseDataProperties）"><a href="#DATA-COUCHBASE（CouchbaseDataProperties）" class="headerlink" title="DATA COUCHBASE（CouchbaseDataProperties）"></a>DATA COUCHBASE（CouchbaseDataProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.data.couchbase.auto-index = false ＃自动创建视图和索引。</span><br><span class="line">spring.data.couchbase.consistency = read-your-own-writes ＃在生成的查询中默认应用的一致性。</span><br><span class="line">spring.data.couchbase.repositories.type = auto ＃要启用的Couchbase存储库的类型。</span><br></pre></td></tr></table></figure><h3 id="ELASTICSEARCH（ElasticsearchProperties）"><a href="#ELASTICSEARCH（ElasticsearchProperties）" class="headerlink" title="ELASTICSEARCH（ElasticsearchProperties）"></a>ELASTICSEARCH（ElasticsearchProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.data.elasticsearch.cluster-name = elasticsearch ＃Elasticsearch集群名称。</span><br><span class="line">spring.data.elasticsearch.cluster-nodes = ＃逗号分隔的集群节点地址列表。</span><br><span class="line">spring.data.elasticsearch.properties。* = ＃用于配置客户端的其他属性。</span><br><span class="line">spring.data.elasticsearch.repositories.enabled = true ＃是否启用Elasticsearch存储库。</span><br></pre></td></tr></table></figure><h3 id="DATA-JDBC"><a href="#DATA-JDBC" class="headerlink" title="DATA JDBC"></a>DATA JDBC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.jdbc.repositories.enabled = true ＃是否启用JDBC存储库。</span><br></pre></td></tr></table></figure><h3 id="DATA-LDAP"><a href="#DATA-LDAP" class="headerlink" title="DATA LDAP"></a>DATA LDAP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.ldap.repositories.enabled = true ＃是否启用LDAP存储库。</span><br></pre></td></tr></table></figure><h3 id="MONGODB（MongoProperties）"><a href="#MONGODB（MongoProperties）" class="headerlink" title="MONGODB（MongoProperties）"></a>MONGODB（MongoProperties）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.authentication-database = ＃认证数据库名称。</span><br><span class="line">spring.data.mongodb.database = ＃数据库名称。</span><br><span class="line">spring.data.mongodb.field-naming-strategy = ＃要使用的FieldNamingStrategy的完全限定名称。</span><br><span class="line">spring.data.mongodb.grid-fs-database = ＃GridFS数据库名称。</span><br><span class="line">spring.data.mongodb.host = #Mongo 服务器主机。无法使用URI设置。</span><br><span class="line">spring.data.mongodb.password = #mongo 服务器的登录密码。无法使用URI设置。</span><br><span class="line">spring.data.mongodb.port = #Mongo 服务器端口。无法使用URI设置。</span><br><span class="line">spring.data.mongodb.repositories.type = auto ＃要启用的Mongo存储库的类型。</span><br><span class="line">spring.data.mongodb.uri = mongodb：// localhost / test ＃Mongo数据库URI。无法使用主机，端口和凭据进行设置。</span><br><span class="line">spring.data.mongodb.username = #mongo 服务器的登录用户。无法使用URI设置。</span><br></pre></td></tr></table></figure><h3 id="DATA-REDIS"><a href="#DATA-REDIS" class="headerlink" title="DATA REDIS"></a>DATA REDIS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.redis.repositories.enabled = true ＃是否启用Redis存储库。</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br></pre></td><td class="code"><pre><span class="line">#NEO4J（Neo4jProperties）</span><br><span class="line">spring.data.neo4j.auto-index = none ＃自动索引模式。</span><br><span class="line">spring.data.neo4j.embedded.enabled = true ＃如果嵌入式驱动程序可用，是否启用嵌入模式。</span><br><span class="line">spring.data.neo4j.open-in-view = true ＃注册OpenSessionInViewInterceptor。将Neo4j会话绑定到线程以进行整个请求处理。</span><br><span class="line">spring.data.neo4j.password = ＃服务器的登录密码。</span><br><span class="line">spring.data.neo4j.repositories.enabled = true ＃是否启用Neo4j存储库。</span><br><span class="line">spring.data.neo4j.uri = 驱动程序使用的#URL 。默认情况下自动检测。</span><br><span class="line">spring.data.neo4j.username = ＃服务器的登录用户。</span><br><span class="line"></span><br><span class="line">#DATA REST（RepositoryRestProperties）</span><br><span class="line">spring.data.rest.base-path = #Spring Data REST用于公开存储库资源的基本路径。</span><br><span class="line">spring.data.rest.default-media-type = ＃未指定时用作默认值的内容类型。</span><br><span class="line">spring.data.rest.default-page-size = ＃默认页面大小。</span><br><span class="line">spring.data.rest.detection-strategy = default ＃用于确定暴露哪些存储库的策略。</span><br><span class="line">spring.data.rest.enable-enum-translation = ＃是否通过Spring Data REST默认资源包启用枚举值转换。</span><br><span class="line">spring.data.rest.limit-param-name =#URL查询字符串参数的名称，指示一次返回多少结果。</span><br><span class="line">spring.data.rest.max-page-size = ＃最大页面大小。</span><br><span class="line">spring.data.rest.page-param-name = #URL 查询字符串参数的名称，指示要返回的页面。</span><br><span class="line">spring.data.rest.return-body-on-create = ＃是否在创建实体后返回响应正文。</span><br><span class="line">spring.data.rest.return-body-on-update = ＃更新实体后是否返回响应正文。</span><br><span class="line">spring.data.rest.sort-param-name = #URL 查询字符串参数的名称，指示对结果进行排序的方向。</span><br><span class="line"></span><br><span class="line">#SOLR （SolrProperties）</span><br><span class="line">spring.data.solr.host = http：//127.0.0.1：8983 / solr #Solr host。如果设置了“zk-host”，则忽略。</span><br><span class="line">spring.data.solr.repositories.enabled = true ＃是否启用Solr存储库。</span><br><span class="line">spring.data.solr.zk-host = ＃ZooKeeper主机地址，格式为HOST：PORT。</span><br><span class="line"></span><br><span class="line">#DATA WEB（SpringDataWebProperties）</span><br><span class="line">spring.data.web.pageable.default页大小 = 20 ＃缺省页大小。</span><br><span class="line">spring.data.web.pageable.max-page-size = 2000 ＃要接受的最大页面大小。</span><br><span class="line">spring.data.web.pageable.one-indexed-parameters = false ＃是否公开和假设从1开始的页码索引。</span><br><span class="line">spring.data.web.pageable.page-parameter = page ＃页面索引参数名称。</span><br><span class="line">spring.data.web.pageable.prefix = ＃常用前缀，用于页码和页面大小参数。</span><br><span class="line">spring.data.web.pageable.qualifier-delimiter = _＃限定符与实际页码和大小属性之间使用的分隔符。</span><br><span class="line">spring.data.web.pageable.size-parameter = size ＃页面大小参数名称。</span><br><span class="line">spring.data.web.sort.sort-parameter = sort ＃排序参数名称。</span><br><span class="line"></span><br><span class="line">#DATASOURCE （DataSourceAutoConfiguration＆DataSourceProperties）</span><br><span class="line">spring.datasource.continue-on-error = false ＃初始化数据库时是否发生错误时停止。</span><br><span class="line">spring.datasource.data = #Data （DML）脚本资源引用。</span><br><span class="line">spring.datasource.data-username = ＃用于执行DML脚本的数据库的用户名（如果不同）。</span><br><span class="line">spring.datasource.data-password = ＃执行DML脚本的数据库的密码（如果不同）。</span><br><span class="line">spring.datasource.dbcp2。* = ＃Commons DBCP2特定设置</span><br><span class="line">spring.datasource.driver-class-name =#JDBC驱动程序的完全限定名称。默认情况下，基于URL自动检测。</span><br><span class="line">spring.datasource.generate-unique-name = false ＃是否生成随机数据源名称。</span><br><span class="line">spring.datasource.hikari。* = ＃Hikari特定设置</span><br><span class="line">spring.datasource.initialization-mode = embedded ＃使用可用的DDL和DML脚本初始化数据源。</span><br><span class="line">spring.datasource.jmx-enabled = false ＃是否启用JMX支持（如果由基础池提供）。</span><br><span class="line">spring.datasource.jndi-name = ＃JNDI数据源的位置。设置时将忽略类，URL，用户名和密码。</span><br><span class="line">spring.datasource.name =＃数据源的名称。使用嵌入式数据库时默认为“testdb”。</span><br><span class="line">spring.datasource.password = ＃数据库的登录密码。</span><br><span class="line">spring.datasource.platform = all ＃在DDL或DML脚本中使用的平台（例如架构 -  $ &#123;platform&#125; .sql或data  -  $ &#123;platform&#125; .sql）。</span><br><span class="line">spring.datasource.schema = #Schema （DDL）脚本资源引用。</span><br><span class="line">spring.datasource.schema-username = ＃执行DDL脚本的数据库的用户名（如果不同）。</span><br><span class="line">spring.datasource.schema-password = ＃执行DDL脚本的数据库的密码（如果不同）。</span><br><span class="line">spring.datasource.separator =;#SQL初始化脚本中的语句分隔符。</span><br><span class="line">spring.datasource.sql-script-encoding = #SQL 脚本编码。</span><br><span class="line">spring.datasource.tomcat。* = ＃Tomcat数据源特定设置</span><br><span class="line">spring.datasource.type = ＃要使用的连接池实现的完全限定名称。默认情况下，它是从类路径中自动检测到的。</span><br><span class="line">spring.datasource.url = ＃JDBC数据库的URL。</span><br><span class="line">spring.datasource.username = ＃登录数据库的用户名。</span><br><span class="line">spring.datasource.xa.data-source-class-name = #XA 数据源完全限定名称。</span><br><span class="line">spring.datasource.xa.properties =＃传递给XA数据源的属性。</span><br><span class="line"></span><br><span class="line">#JEST （Elasticsearch HTTP客户端）（JestProperties）</span><br><span class="line">spring.elasticsearch.jest.connection-timeout = 3s ＃连接超时。</span><br><span class="line">spring.elasticsearch.jest.multi-threaded = true ＃是否从多个执行线程启用连接请求。</span><br><span class="line">spring.elasticsearch.jest.password = ＃登录密码。</span><br><span class="line">spring.elasticsearch.jest.proxy.host = #HTTP 客户端应使用的代理主机。</span><br><span class="line">spring.elasticsearch.jest.proxy.port = #HTTP 客户端应使用的代理端口。</span><br><span class="line">spring.elasticsearch.jest.read-timeout = 3s ＃读取超时。</span><br><span class="line">spring.elasticsearch.jest.uris = http：// localhost：9200＃逗号分隔的Elasticsearch实例列表。</span><br><span class="line">spring.elasticsearch.jest.username = ＃登录用户名。</span><br><span class="line"></span><br><span class="line">#Elasticsearch REST客户端（RestClientProperties）</span><br><span class="line">spring.elasticsearch.rest.password = ＃凭据密码。</span><br><span class="line">spring.elasticsearch.rest.uris = http：// localhost：9200 ＃要使用的以逗号分隔的Elasticsearch实例列表。</span><br><span class="line">spring.elasticsearch.rest.username = ＃凭据用户名。</span><br><span class="line"></span><br><span class="line">#H2 Web控制台（H2ConsoleProperties）</span><br><span class="line">spring.h2.console.enabled = false ＃是否启用控制台。</span><br><span class="line">spring.h2.console.path = / h2-console ＃控制台可用的路径。</span><br><span class="line">spring.h2.console.settings.trace = false ＃是否启用跟踪输出。</span><br><span class="line">spring.h2.console.settings.web-allow-others = false ＃是否启用远程访问。</span><br><span class="line"></span><br><span class="line">#InfluxDB（InfluxDbProperties）</span><br><span class="line">spring.influx.password = ＃登录密码。</span><br><span class="line">spring.influx.url = 要连接的InfluxDB实例的URL。</span><br><span class="line">spring.influx.user = ＃登录用户。</span><br><span class="line"></span><br><span class="line">#JOOQ （JooqProperties）</span><br><span class="line">spring.jooq.sql-dialect = #SQL 方言使用。默认情况下自动检测。</span><br><span class="line"></span><br><span class="line">#JDBC （JdbcProperties）</span><br><span class="line">spring.jdbc.template.fetch-size = -1 ＃需要更多行时应从数据库中提取的行数。</span><br><span class="line">spring.jdbc.template.max-rows = -1 ＃最大行数。</span><br><span class="line">spring.jdbc.template.query-timeout = ＃查询超时。默认是使用JDBC驱动程序的默认配置。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line"></span><br><span class="line">＃JPA （JpaBaseConfiguration，HibernateJpaAutoConfiguration）</span><br><span class="line">spring.data.jpa.repositories.bootstrap-mode = default #JAPA 存储库的Bootstrap模式。</span><br><span class="line">spring.data.jpa.repositories.enabled = true ＃是否启用JPA存储库。</span><br><span class="line">spring.jpa.database = ＃要操作的目标数据库，默认情况下自动检测。也可以使用“databasePlatform”属性进行设置。</span><br><span class="line">spring.jpa.database-platform = ＃要操作的目标数据库的名称，默认情况下自动检测。也可以使用“Database”枚举来设置。</span><br><span class="line">spring.jpa.generate-ddl = false ＃是否在启动时初始化架构。</span><br><span class="line">spring.jpa.hibernate.ddl-auto = ＃DDL模式。这实际上是“hibernate.hbm2ddl.auto”属性的快捷方式。使用嵌入式数据库时未默认为“create-drop”，并且未检测到架构管理器。否则，默认为“none”。</span><br><span class="line">spring.jpa.hibernate.naming.implicit-strategy = ＃隐式命名策略的完全限定名称。</span><br><span class="line">spring.jpa.hibernate.naming.physical-strategy = ＃物理命名策略的完全限定名称。</span><br><span class="line">spring.jpa.hibernate.use-new-id-generator-mappings = ＃是否将Hibernate的较新的IdentifierGenerator用于AUTO，TABLE和SEQUENCE。</span><br><span class="line">spring.jpa.mapping-resources =＃Mapping资源（相当于persistence.xml中的“mapping-file”条目）。</span><br><span class="line">spring.jpa.open-in-view = true ＃注册OpenEntityManagerInViewInterceptor。将JPA EntityManager绑定到线程以进行整个请求处理。</span><br><span class="line">spring.jpa.properties。* = ＃要在JPA提供程序上设置的其他本机属性。</span><br><span class="line">spring.jpa.show -sql = false ＃是否启用SQL语句的日志记录。</span><br><span class="line"></span><br><span class="line">#JTA （JtaAutoConfiguration）</span><br><span class="line">spring.jta.enabled = true ＃是否启用JTA支持。</span><br><span class="line">spring.jta.log-dir = #Transaction logs目录。</span><br><span class="line">spring.jta.transaction-manager-id = #Transaction manager唯一标识符。</span><br><span class="line"></span><br><span class="line">#ATOMIKOS（AtomikosProperties）</span><br><span class="line">spring.jta.atomikos.connectionfactory.borrow-connection-timeout = 30 ＃从池中借用连接的超时（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag = true ＃是否在创建会话时忽略事务处理标志。</span><br><span class="line">spring.jta.atomikos.connectionfactory.local-transaction-mode = false ＃是否需要本地事务。</span><br><span class="line">spring.jta.atomikos.connectionfactory.maintenance-interval = 60 ＃池维护线程运行之间的时间（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.connectionfactory.max-idle-time = 60＃从池中清除连接的时间（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.connectionfactory.max-lifetime = 0 ＃连接在被销毁之前可以合并的时间（以秒为单位）。0表示没有限制。</span><br><span class="line">spring.jta.atomikos.connectionfactory.max-pool-size = 1 ＃池的最大大小。</span><br><span class="line">spring.jta.atomikos.connectionfactory.min-pool-size = 1 ＃池的最小大小。</span><br><span class="line">spring.jta.atomikos.connectionfactory.reap-timeout = 0 ＃借用连接的reap超时（以秒为单位）。0表示没有限制。</span><br><span class="line">spring.jta.atomikos.connectionfactory.unique-resource-name = jmsConnectionFactory＃用于在恢复期间标识资源的唯一名称。</span><br><span class="line">spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name = #XAConnectionFactory的供应商特定实现。</span><br><span class="line">spring.jta.atomikos.connectionfactory.xa-properties = ＃供应商特定的XA属性。</span><br><span class="line">spring.jta.atomikos.datasource.borrow-connection-timeout = 30 ＃从池中借用连接的超时时间（秒）。</span><br><span class="line">spring.jta.atomikos.datasource.concurrent-connection-validation = ＃是否使用并发连接验证。</span><br><span class="line">spring.jta.atomikos.datasource.default-isolation-level = ＃池提供的连接的默认隔离级别。</span><br><span class="line">spring.jta.atomikos.datasource.login-timeout = ＃用于建立数据库连接的超时（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.datasource.maintenance-interval = 60 ＃池维护线程运行之间的时间（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.datasource.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。</span><br><span class="line">spring.jta.atomikos.datasource.max-lifetime = 0 ＃连接在被销毁之前可以合并的时间（以秒为单位）。0表示没有限制。</span><br><span class="line">spring.jta.atomikos.datasource.max-pool-size = 1 ＃池的最大大小。</span><br><span class="line">spring.jta.atomikos.datasource.min-pool-size = 1＃池的最小大小。</span><br><span class="line">spring.jta.atomikos.datasource.reap-timeout = 0 ＃借用连接的reap超时（以秒为单位）。0表示没有限制。</span><br><span class="line">spring.jta.atomikos.datasource.test-query = ＃用于在返回连接之前验证连接的SQL查询或语句。</span><br><span class="line">spring.jta.atomikos.datasource.unique-resource-name = dataSource ＃用于在恢复期间标识资源的唯一名称。</span><br><span class="line">spring.jta.atomikos.datasource.xa-data-source-class-name = #XAConnectionFactory的供应商特定实现。</span><br><span class="line">spring.jta.atomikos.datasource.xa-properties = ＃供应商特定的XA属性。</span><br><span class="line">spring.jta.atomikos.properties.allow-sub-transactions = true ＃指定是否允许子事务。</span><br><span class="line">spring.jta.atomikos.properties.checkpoint-interval = 500 ＃检查点之间的间隔，表示为两个检查点之间的日志写入次数。</span><br><span class="line">spring.jta.atomikos.properties.default -jta -timeout = 10000ms #JTA 事务的默认超时。</span><br><span class="line">spring.jta.atomikos.properties.default-max-wait-time-on-shutdown = 9223372036854775807 ＃正常关闭（no-force）等待事务完成的时间。</span><br><span class="line">spring.jta.atomikos.properties.enable-logging = true ＃是否启用磁盘日志记录。</span><br><span class="line">spring.jta.atomikos.properties.force-shutdown-on-vm-exit = false ＃虚拟机关闭是否应触发事务核心的强制关闭。</span><br><span class="line">spring.jta.atomikos.properties.log-base-dir = ＃应存储日志文件的目录。</span><br><span class="line">spring.jta.atomikos.properties.log-base-name = tmlog ＃Transactions日志文件基名。</span><br><span class="line">spring.jta.atomikos.properties.max-actives = 50 ＃最大活动事务数。</span><br><span class="line">spring.jta.atomikos.properties.max-timeout = 300000ms ＃事务允许的最大超时时间。</span><br><span class="line">spring.jta.atomikos.properties.recovery.delay = 10000ms ＃两次恢复扫描之间的延迟。</span><br><span class="line">spring.jta.atomikos.properties.recovery.forget- orphaned -log-entries-delay = 86400000ms ＃恢复之后的延迟可以清除挂起（&apos;孤立&apos;）日志条目。</span><br><span class="line">spring.jta.atomikos.properties.recovery.max-retries = 5 ＃在抛出异常之前提交事务的重试次数。</span><br><span class="line">spring.jta.atomikos.properties.recovery.retry-interval = 10000ms ＃重试尝试之间的延迟。</span><br><span class="line">spring.jta.atomikos.properties.serial-jta-transactions = true ＃是否应尽可能加入子事务。</span><br><span class="line">spring.jta.atomikos.properties.service = ＃应该启动的事务管理器实现。</span><br><span class="line">spring.jta.atomikos.properties.threaded-two-phase-commit = false ＃是否对参与资源使用不同（和并发）线程进行两阶段提交。</span><br><span class="line">spring.jta.atomikos.properties.transaction-manager-unique-name = ＃事务管理器的唯一名称。</span><br><span class="line"></span><br><span class="line">#BITRONIX </span><br><span class="line">spring.jta.bitronix.connectionfactory.acquire-increment = 1 ＃在增长池时创建的连接数。</span><br><span class="line">spring.jta.bitronix.connectionfactory.acquisition-interval = 1 ＃获取无效连接后再次尝试获取连接之前等待的时间（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.connectionfactory.acquisition-timeout = 30 ＃从池中获取连接的超时时间（秒）。</span><br><span class="line">spring.jta.bitronix.connectionfactory.allow-local-transactions = true ＃事务管理器是否应该允许混合XA和非XA事务。</span><br><span class="line">spring.jta.bitronix.connectionfactory.apply-transaction-timeout = false＃是否应在登记时在XAResource上设置事务超时。</span><br><span class="line">spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled = true ＃是否应自动登记和退出资源。</span><br><span class="line">spring.jta.bitronix.connectionfactory.cache-producer-consumers = true ＃是否应该缓存生产者和消费者。</span><br><span class="line">spring.jta.bitronix.connectionfactory.class-name = #XA 资源的底层实现类名。</span><br><span class="line">spring.jta.bitronix.connectionfactory.defer-connection-release = true ＃提供程序是否可以在同一连接上运行多个事务并支持事务交错。</span><br><span class="line">spring.jta.bitronix.connectionfactory.disabled= ＃是否禁用此资源，这意味着暂时禁止从其池中获取连接。</span><br><span class="line">spring.jta.bitronix.connectionfactory.driver-properties = ＃应在底层实现上设置的属性。</span><br><span class="line">spring.jta.bitronix.connectionfactory.failed = ＃将此资源生成器标记为失败。</span><br><span class="line">spring.jta.bitronix.connectionfactory.ignore-recovery-failures = false ＃是否应忽略恢复失败。</span><br><span class="line">spring.jta.bitronix.connectionfactory.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.connectionfactory.max-pool-size = 10＃池的最大大小。0表示没有限制。</span><br><span class="line">spring.jta.bitronix.connectionfactory.min-pool-size = 0 ＃池的最小大小。</span><br><span class="line">spring.jta.bitronix.connectionfactory.password = ＃用于连接JMS提供程序的密码。</span><br><span class="line">spring.jta.bitronix.connectionfactory.share-transaction-connections = false ＃是否可以在事务上下文中共享处于ACCESSIBLE状态的连接。</span><br><span class="line">spring.jta.bitronix.connectionfactory.test-connections = true ＃从池中获取时是否应测试连接。</span><br><span class="line">spring.jta.bitronix.connectionfactory.two-pc-ordering-position = 1＃在两阶段提交期间此资源应采取的位置（始终是第一个是Integer.MIN_VALUE，总是最后一个是Integer.MAX_VALUE）。</span><br><span class="line">spring.jta.bitronix.connectionfactory.unique-name = jmsConnectionFactory ＃用于在恢复期间标识资源的唯一名称。</span><br><span class="line">spring.jta.bitronix.connectionfactory.use -tm -join = true ＃启动XAResources时是否应该使用TMJOIN。spring.jta.bitronix.connectionfactory.user = ＃用于连接到JMS提供程序的用户。</span><br><span class="line">spring.jta.bitronix.datasource.acquire-increment = 1 ＃在增长池时创建的连接数。</span><br><span class="line">spring.jta.bitronix.datasource.acquisition-interval = 1＃在获取无效连接后再次尝试获取连接之前等待的时间（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.datasource.acquisition-timeout = 30 ＃从池中获取连接的超时时间（秒）。</span><br><span class="line">spring.jta.bitronix.datasource.allow-local-transactions = true ＃事务管理器是否应该允许混合XA和非XA事务。</span><br><span class="line">spring.jta.bitronix.datasource.apply-transaction-timeout = false ＃是否应在XAResource登记时设置事务超时。</span><br><span class="line">spring.jta.bitronix.datasource.automatic-enlisting-enabled = true ＃是否应自动登记和退出资源。</span><br><span class="line">spring.jta.bitronix.datasource.class-name = #XA 资源的底层实现类名。</span><br><span class="line">spring.jta.bitronix.datasource.cursor-holdability = ＃连接的默认光标可保持性。</span><br><span class="line">spring.jta.bitronix.datasource.defer-connection-release = true ＃数据库是否可以在同一连接上运行多个事务并支持事务交错。</span><br><span class="line">spring.jta.bitronix.datasource.disabled = ＃是否禁用此资源，这意味着暂时禁止从其池中获取连接。</span><br><span class="line">spring.jta.bitronix.datasource.driver-properties = ＃应在底层实现上设置的属性。</span><br><span class="line">spring.jta.bitronix.datasource.enable -jdbc4-connection-test = ＃从池中获取连接时是否调用Connection.isValid（）。</span><br><span class="line">spring.jta.bitronix.datasource.failed = ＃将此资源生成器标记为失败。</span><br><span class="line">spring.jta.bitronix.datasource.ignore-recovery-failures = false ＃是否应忽略恢复失败。</span><br><span class="line">spring.jta.bitronix.datasource.isolation-level = ＃连接的默认隔离级别。</span><br><span class="line">spring.jta.bitronix.datasource.local-auto-commit = ＃本地事务的默认自动提交模式。</span><br><span class="line">spring.jta.bitronix.datasource.login-timeout =＃建立数据库连接的超时时间（秒）。</span><br><span class="line">spring.jta.bitronix.datasource.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.datasource.max-pool-size = 10 ＃池的最大大小。0表示没有限制。</span><br><span class="line">spring.jta.bitronix.datasource.min-pool-size = 0 ＃池的最小大小。</span><br><span class="line">spring.jta.bitronix.datasource.prepared-statement-cache-size = 0 ＃预准备语句缓存的目标大小。0禁用缓存。</span><br><span class="line">spring.jta.bitronix.datasource.share-transaction-connections = false＃是否可以在事务上下文中共享处于ACCESSIBLE状态的连接。</span><br><span class="line">spring.jta.bitronix.datasource.test-query = ＃用于在返回连接之前验证连接的SQL查询或语句。</span><br><span class="line">spring.jta.bitronix.datasource.two-pc-ordering-position = 1 ＃此资源在两阶段提交期间应采取的位置（始终首先是Integer.MIN_VALUE，并且始终是最后一个是Integer.MAX_VALUE）。</span><br><span class="line">spring.jta.bitronix.datasource.unique-name = dataSource ＃用于在恢复期间标识资源的唯一名称。</span><br><span class="line">spring.jta.bitronix.datasource.use -tm -join = true ＃启动XAResources时是否应该使用TMJOIN。</span><br><span class="line">spring.jta.bitronix.properties.allow-multiple-lrc = false ＃是否允许多个LRC资源登记到同一事务中。</span><br><span class="line">spring.jta.bitronix.properties.asynchronous2-pc = false ＃是否启用异步执行两阶段提交。</span><br><span class="line">spring.jta.bitronix.properties.background-recovery-interval-seconds = 60 ＃在后台运行恢复过程的时间间隔（以秒为单位）。</span><br><span class="line">spring.jta.bitronix.properties.current-node-only-recovery = true ＃是否仅恢复当前节点。</span><br><span class="line">spring.jta.bitronix.properties.debug-zero-resource-transaction = false＃是否记录创建和提交没有单个登记资源的事务调用堆栈。</span><br><span class="line">spring.jta.bitronix.properties.default-transaction-timeout = 60 ＃默认事务超时，以秒为单位。</span><br><span class="line">spring.jta.bitronix.properties.disable-jmx = false ＃是否启用JMX支持。</span><br><span class="line">spring.jta.bitronix.properties.exception-analyzer = ＃设置要使用的异常分析器实现的完全限定名称。</span><br><span class="line">spring.jta.bitronix.properties.filter-log-status = false ＃是否启用日志过滤，以便只写入强制日志。</span><br><span class="line">spring.jta.bitronix.properties.force-batching-enabled = true＃是否批量磁盘强制。</span><br><span class="line">spring.jta.bitronix.properties.forced-write-enabled = true ＃是否强制将日志记录到磁盘。</span><br><span class="line">spring.jta.bitronix.properties.graceful-shutdown-interval = 60 ＃TM在关闭时中止事务之前等待事务完成的最大秒数。</span><br><span class="line">spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name = ＃TransactionSynchronizationRegistry的JNDI名称。</span><br><span class="line">spring.jta.bitronix.properties.jndi-user-transaction-name = ＃UserTransaction的JNDI名称。</span><br><span class="line">spring.jta.bitronix.properties.journal = disk ＃期刊的名称。可以是&apos;disk&apos;，&apos;null&apos;或类名。</span><br><span class="line">spring.jta.bitronix.properties.log-part1-filename = btm1.tlog ＃日志的第一个片段的名称。</span><br><span class="line">spring.jta.bitronix.properties.log-part2-filename = btm2.tlog ＃日志的第二个片段的名称。</span><br><span class="line">spring.jta.bitronix.properties.max-log-size-in-mb = 2 ＃日志片段的最大大小（兆字节）。</span><br><span class="line">spring.jta.bitronix.properties.resource-configuration-filename = ＃ResourceLoader配置文件名。</span><br><span class="line">spring.jta.bitronix.properties.server-id = #ASCII ID必须唯一标识此TM实例。默认为机器的IP地址。</span><br><span class="line">spring.jta.bitronix.properties.skip-corrupted-logs = false#Skip损坏的事务日志条目。</span><br><span class="line">spring.jta.bitronix.properties.warn-about-zero-resource-transaction = true ＃是否为没有单个登记资源的事务记录警告。</span><br><span class="line"></span><br><span class="line">#EMBEDDED MONGODB（EmbeddedMongoProperties）</span><br><span class="line">spring.mongodb.embedded.features = sync_delay ＃逗号分隔的要启用的功能列表。</span><br><span class="line">spring.mongodb.embedded.storage.database-dir = ＃用于数据存储的目录。</span><br><span class="line">spring.mongodb.embedded.storage.oplog-size = #oplog的最大大小。</span><br><span class="line">spring.mongodb.embedded.storage.repl-set-name = ＃副本集的名称。</span><br><span class="line">spring.mongodb.embedded.version = 3.5.5 ＃要使用的Mongo版本。</span><br><span class="line"></span><br><span class="line">#REDIS（RedisProperties）</span><br><span class="line">spring.redis.cluster.max -redirects = ＃在群集中执行命令时要遵循的最大重定向数。</span><br><span class="line">spring.redis.cluster.nodes = ＃逗号分隔的“host：port”对列表引导自。</span><br><span class="line">spring.redis.database = 0 ＃连接工厂使用的数据库索引。</span><br><span class="line">spring.redis.url = ＃连接URL。覆盖主机，端口和密码。用户被忽略。示例：redis：// user：password@example.com ：6379 </span><br><span class="line">spring.redis.host = localhost ＃Redis服务器主机。</span><br><span class="line">spring.redis.jedis.pool.max-active = 8＃池在给定时间可以分配的最大连接数。使用负值无限制。</span><br><span class="line">spring.redis.jedis.pool.max-idle = 8 ＃池中“空闲”连接的最大数量。使用负值表示无限数量的空闲连接。</span><br><span class="line">spring.redis.jedis.pool.max -wait = -1ms ＃在池耗尽时，在抛出异常之前连接分配应该阻塞的最长时间。使用负值无限期阻止。</span><br><span class="line">spring.redis.jedis.pool.min-idle = 0 ＃目标是池中维护的最小空闲连接数。此设置仅在其为正时才有效。</span><br><span class="line">spring.redis.lettuce.pool.max-active = 8＃池在给定时间可以分配的最大连接数。使用负值无限制。</span><br><span class="line">spring.redis.lettuce.pool.max-idle = 8 ＃池中“空闲”连接的最大数量。使用负值表示无限数量的空闲连接。</span><br><span class="line">spring.redis.lettuce.pool.max -wait = -1ms ＃在池耗尽时，在抛出异常之前连接分配应阻塞的最长时间。使用负值无限期阻止。</span><br><span class="line">spring.redis.lettuce.pool.min-idle = 0 ＃目标是池中维护的最小空闲连接数。此设置仅在其为正时才有效。</span><br><span class="line">spring.redis.lettuce.shutdown-timeout = 100ms＃关机超时。</span><br><span class="line">spring.redis.password = ＃redis服务器的登录密码。</span><br><span class="line">spring.redis.port = 6379 #Redis服务器端口。</span><br><span class="line">spring.redis.sentinel.master = #Redis服务器的名称。</span><br><span class="line">spring.redis.sentinel.nodes = ＃逗号分隔的“host：port”对列表。</span><br><span class="line">spring.redis.ssl = false ＃是否启用SSL支持。</span><br><span class="line">spring.redis.timeout = ＃连接超时。</span><br><span class="line"></span><br><span class="line">#TRANSACTION （TransactionProperties）</span><br><span class="line">spring.transaction.default-timeout = ＃默认事务超时。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.transaction.rollback-on-commit-failure = ＃是否回滚提交失败。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">＃---------------------------------------- </span><br><span class="line">＃INTEGRATION PROPERTIES </span><br><span class="line">＃----- -----------------------------------</span><br><span class="line"></span><br><span class="line">#ACTIVEMQ（ActiveMQProperties）</span><br><span class="line">spring.activemq.broker-url = ActiveMQ代理的URL。默认情况下自动生成。</span><br><span class="line">spring.activemq.close-timeout = 15s ＃在考虑结束完成之前等待的时间。</span><br><span class="line">spring.activemq.in-memory = true ＃默认代理URL是否应该在内存中。如果已指定显式代理，则忽略。</span><br><span class="line">spring.activemq.non-blocking-redelivery = false ＃是否在从回滚事务重新传递消息之前停止消息传递。这意味着启用此消息顺序时不会保留消息顺序。</span><br><span class="line">spring.activemq.password = ＃代理的登录密码。</span><br><span class="line">spring.activemq.send-timeout = 0ms ＃等待消息发送响应的时间。将其设置为0以永远等待。</span><br><span class="line">spring.activemq.user = ＃代理的登录用户。</span><br><span class="line">spring.activemq.packages.trust-all = ＃是否信任所有包。</span><br><span class="line">spring.activemq.packages.trusted = ＃逗号分隔的要信任的特定包列表（不信任所有包时）。</span><br><span class="line">spring.activemq.pool.block-if-full = true ＃是否阻止请求连接并且池已满。将其设置为false以改为抛出“JMSException”。</span><br><span class="line">spring.activemq.pool.block-if-full-timeout = -1ms＃如果池仍然满，则在抛出异常之前阻塞。</span><br><span class="line">spring.activemq.pool.enabled = false ＃是否应创建JmsPoolConnectionFactory，而不是常规ConnectionFactory。</span><br><span class="line">spring.activemq.pool.idle-timeout = 30s ＃连接空闲超时。</span><br><span class="line">spring.activemq.pool.max-connections = 1 ＃最大池化连接数。</span><br><span class="line">spring.activemq.pool.max-sessions-per-connection = 500 ＃池中每个连接的最大池化会话数。</span><br><span class="line">spring.activemq.pool.time-between-expiration-check = -1ms ＃在空闲连接驱逐线程的运行之间休眠的时间。当为负时，没有空闲连接驱逐线程运行。</span><br><span class="line">spring.activemq.pool.use-anonymous-producer = true ＃是否只使用一个匿名“MessageProducer”实例。将其设置为false以在每次需要时创建一个“MessageProducer”。</span><br><span class="line"></span><br><span class="line">#ARTEMIS （ArtemisProperties）</span><br><span class="line">spring.artemis.embedded.cluster-password = ＃群集密码。默认情况下在启动时随机生成。</span><br><span class="line">spring.artemis.embedded.data-directory = #Journal 文件目录。如果关闭持久性，则没有必要。</span><br><span class="line">spring.artemis.embedded.enabled = true ＃如果Artemis服务器API可用，是否启用嵌入模式。</span><br><span class="line">spring.artemis.embedded.persistent = false ＃是否启用持久存储。</span><br><span class="line">spring.artemis.embedded.queues = ＃逗号分隔的队列，在启动时创建。</span><br><span class="line">spring.artemis.embedded.server-id =＃服务器ID。默认情况下，使用自动递增的计数器。</span><br><span class="line">spring.artemis.embedded.topics = ＃在启动时要创建的以逗号分隔的主题列表。</span><br><span class="line">spring.artemis.host = localhost ＃Artemis broker主机。</span><br><span class="line">spring.artemis.mode = ＃Artemis部署模式，默认情况下自动检测。</span><br><span class="line">spring.artemis.password = ＃代理的登录密码。</span><br><span class="line">spring.artemis.pool.block-if-full = true ＃是否在请求连接且池已满时阻止。将其设置为false以改为抛出“JMSException”。</span><br><span class="line">spring.artemis.pool.block-if-full-timeout = -1ms ＃如果池仍然满，则在抛出异常之前阻塞。</span><br><span class="line">spring.artemis.pool.enabled = false ＃是否应创建JmsPoolConnectionFactory，而不是常规ConnectionFactory。</span><br><span class="line">spring.artemis.pool.idle-timeout = 30s ＃连接空闲超时。</span><br><span class="line">spring.artemis.pool.max-connections = 1 ＃池化连接的最大数量。</span><br><span class="line">spring.artemis.pool.max-sessions-per-connection = 500 ＃池中每个连接的最大池化会话数。</span><br><span class="line">spring.artemis.pool.time-between-expiration-check = -1ms ＃在空闲连接驱逐线程的运行之间休眠的时间。当为负时，没有空闲连接驱逐线程运行。</span><br><span class="line">spring.artemis.pool.use-anonymous-producers = true＃是否只使用一个匿名“MessageProducer”实例。将其设置为false以在每次需要时创建一个“MessageProducer”。</span><br><span class="line">spring.artemis.port = 61616 #Artemis 经纪人端口。</span><br><span class="line">spring.artemis.user = ＃代理的登录用户。</span><br><span class="line"></span><br><span class="line">#SPRING BATCH（BatchProperties）</span><br><span class="line">spring.batch.initialize-schema = embedded ＃数据库模式初始化模式。</span><br><span class="line">spring.batch.job.enabled = true ＃在启动时执行上下文中的所有Spring Batch作业。</span><br><span class="line">spring.batch.job.names = ＃逗号分隔的要在启动时执行的作业名称列表（例如，`job1，job2`）。默认情况下，将执行上下文中找到的所有作业。</span><br><span class="line">spring.batch.schema = classpath中：组织/ springframework的/批号/核心/ schema- @ @ 平台@ @ .SQL ＃的路径SQL文件，以用于初始化数据库架构。</span><br><span class="line">spring.batch.table-prefix =＃所有批次元数据表的表前缀。</span><br><span class="line"></span><br><span class="line">#SPRING INTEGRATION（IntegrationProperties）</span><br><span class="line">spring.integration.jdbc.initialize-schema = embedded ＃数据库模式初始化模式。</span><br><span class="line">spring.integration.jdbc.schema = classpath中：组织/ springframework的/集成/ JDBC / schema- @ @ 平台@ @ .SQL ＃的路径SQL文件，以用于初始化数据库架构。</span><br><span class="line"></span><br><span class="line">#JMS （JmsProperties）</span><br><span class="line">spring.jms.cache.consumers = false ＃是否缓存消息使用者。</span><br><span class="line">spring.jms.cache.enabled = true ＃是否缓存会话。</span><br><span class="line">spring.jms.cache.producers = true ＃是否缓存消息生成器。</span><br><span class="line">spring.jms.cache.session-cache-size = 1 ＃会话缓存的大小（根据JMS会话类型）。</span><br><span class="line">spring.jms.jndi-name = ＃连接工厂JNDI名称。设置时，优先于其他连接工厂自动配置。</span><br><span class="line">spring.jms.listener.acknowledge-mode = ＃容器的确认模式。默认情况下，侦听器使用自动确认进行事务处理。</span><br><span class="line">spring.jms.listener.auto-startup = true ＃启动时自动启动容器。</span><br><span class="line">spring.jms.listener.concurrency = ＃最小并发使用者数。</span><br><span class="line">spring.jms.listener.max-concurrency = ＃最大并发使用者数。</span><br><span class="line">spring.jms.pub-sub-domain = false ＃默认目标类型是否为topic。</span><br><span class="line">spring.jms.template.default-destination = ＃用于没有目标参数的发送和接收操作的默认目标。</span><br><span class="line">spring.jms.template.delivery-delay = ＃用于发送呼叫的传递延迟。</span><br><span class="line">spring.jms.template.delivery-mode =＃交付模式。设置时启用QoS（服务质量）。</span><br><span class="line">spring.jms.template.priority = ＃发送时消息的优先级。设置时启用QoS（服务质量）。</span><br><span class="line">spring.jms.template.qos-enabled = ＃发送消息时是否启用显式QoS（服务质量）。</span><br><span class="line">spring.jms.template.receive-timeout = ＃用于接收呼叫的超时。</span><br><span class="line">spring.jms.template.time-to-live = ＃发送时消息的生存时间。设置时启用QoS（服务质量）。</span><br><span class="line"></span><br><span class="line">#APACHE KAFKA（KafkaProperties）</span><br><span class="line">spring.kafka.admin.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.admin.fail-fast = false ＃如果代理在启动时不可用，是否快速失败。</span><br><span class="line">spring.kafka.admin.properties。* = ＃用于配置客户端的其他特定于管理员的属性。</span><br><span class="line">spring.kafka.admin.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.admin.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.admin.ssl.key-store-password =＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.admin.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.admin.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.admin.ssl.trust-store-location = ＃信任库文件的位置。</span><br><span class="line">spring.kafka.admin.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.admin.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。除非被覆盖，否则适用于所有组件。</span><br><span class="line">spring.kafka.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.consumer.auto-commit-interval = ＃如果&apos;enable.auto.commit&apos;设置为true，则将消费者偏移自动提交给Kafka的频率。</span><br><span class="line">spring.kafka.consumer.auto-offset-reset = ＃当Kafka中没有初始偏移量或者服务器上不再存在当前偏移量时该怎么办。</span><br><span class="line">spring.kafka.consumer.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。为消费者覆盖全球财产。</span><br><span class="line">spring.kafka.consumer.client-id =#ID在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.consumer.enable-auto-commit = ＃是否在后台定期提交消费者的偏移量。</span><br><span class="line">spring.kafka.consumer.fetch-max-wait = ＃如果没有足够的数据立即满足“fetch-min-size”给出的要求，服务器在回答获取请求之前会阻塞的最长时间。</span><br><span class="line">spring.kafka.consumer.fetch-min-size = ＃服务器应为获取请求返回的最小数据量。</span><br><span class="line">spring.kafka.consumer.group-id = ＃唯一字符串，用于标识此使用者所属的使用者组。</span><br><span class="line">spring.kafka.consumer.heartbeat间隔= ＃心跳与消费者协调员之间的预期时间。</span><br><span class="line">spring.kafka.consumer.key-deserializer = #Deserializer 类的键。</span><br><span class="line">spring.kafka.consumer.max-poll-records = ＃一次调用poll（）时返回的最大记录数。</span><br><span class="line">spring.kafka.consumer.properties。* = ＃用于配置客户端的其他特定于使用者的属性。</span><br><span class="line">spring.kafka.consumer.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.consumer.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.consumer.ssl.key-store-password =＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.consumer.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.consumer.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.consumer.ssl.trust-store-location = ＃信任存储文件的位置。</span><br><span class="line">spring.kafka.consumer.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.consumer.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.consumer.value-deserializer = #Deserializer 类的值。</span><br><span class="line">spring.kafka.jaas.control-flag = required ＃登录配置的控制标志。</span><br><span class="line">spring.kafka.jaas.enabled = false ＃是否启用JAAS配置。</span><br><span class="line">spring.kafka.jaas.login-module = com.sun.security.auth.module.Krb5LoginModule ＃登录模块。</span><br><span class="line">spring.kafka.jaas.options = ＃其他JAAS选项。</span><br><span class="line">spring.kafka.listener.ack-count = ＃当ackMode为“COUNT”或“COUNT_TIME”时，偏移提交之间的记录数。</span><br><span class="line">spring.kafka.listener.ack-mode = ＃Listener AckMode。请参阅spring-kafka文档。</span><br><span class="line">spring.kafka.listener.ack-time = ＃当ackMode为“TIME”或“COUNT_TIME”时，偏移提交之间的时间。</span><br><span class="line">spring.kafka.listener.client-id =＃侦听器的使用者client.id属性的前缀。</span><br><span class="line">spring.kafka.listener.concurrency = ＃在侦听器容器中运行的线程数。</span><br><span class="line">spring.kafka.listener.idle-event-interval = ＃发布空闲消费者事件（未收到数据）之间的时间。</span><br><span class="line">spring.kafka.listener.log-container-config = ＃是否在初始化期间记录容器配置（INFO级别）。</span><br><span class="line">spring.kafka.listener.monitor-interval = ＃检查无响应的消费者之间的时间。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.kafka.listener.no-poll-threshold =#Multiplier应用于“pollTimeout”以确定消费者是否无响应。</span><br><span class="line">spring.kafka.listener.poll-timeout = ＃轮询消费者时使用的超时。</span><br><span class="line">spring.kafka.listener.type = single ＃Listener类型。</span><br><span class="line">spring.kafka.producer.acks = ＃生产者要求领导者在考虑完成请求之前收到的确认数。</span><br><span class="line">spring.kafka.producer.batch-size = ＃默认批量大小。</span><br><span class="line">spring.kafka.producer.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。为生产者覆盖全球财产。</span><br><span class="line">spring.kafka.producer.buffer-memory = ＃生产者可用于缓冲等待发送到服务器的记录的总内存大小。</span><br><span class="line">spring.kafka.producer.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.producer.compression-type = ＃生产者生成的所有数据的压缩类型。</span><br><span class="line">spring.kafka.producer.key-serializer = ＃密码的Serializer类。</span><br><span class="line">spring.kafka.producer.properties。* = ＃用于配置客户端的其他特定于生产者的属性。</span><br><span class="line">spring.kafka.producer.retries = ＃大于零时，启用重试失败的发送。</span><br><span class="line">spring.kafka.producer.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.producer.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.producer.ssl.key-store-password = ＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.producer.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.producer.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.producer.ssl.trust-store-location = ＃信任库文件的位置。</span><br><span class="line">spring.kafka.producer.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.producer.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.producer.transaction-id-prefix = ＃非空时，为生产者启用事务支持。</span><br><span class="line">spring.kafka.producer.value-serializer = #Serializer 类的值。</span><br><span class="line">spring.kafka.properties。* = ＃用于配置客户端的生产者和使用者共有的附加属性。</span><br><span class="line">spring.kafka.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.ssl.key-store-password =＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.ssl.trust-store-location = ＃信任库文件的位置。</span><br><span class="line">spring.kafka.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.streams.application-id = #Kafka streams application.id property; 默认spring.application.name。</span><br><span class="line">spring.kafka.streams.auto-startup = true ＃是否自动启动流工厂bean。</span><br><span class="line">spring.kafka.streams.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。覆盖流的全局属性。</span><br><span class="line">spring.kafka.streams.cache-max-size-buffering = ＃用于跨所有线程缓冲的最大内存大小。</span><br><span class="line">spring.kafka.streams.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。</span><br><span class="line">spring.kafka.streams.properties。* = ＃用于配置流的其他Kafka属性。</span><br><span class="line">spring.kafka.streams.replication-factor =＃流处理应用程序创建的更改日志主题和重新分区主题的复制因子。</span><br><span class="line">spring.kafka.streams.ssl.key-password = ＃密钥库文件中私钥的密码。</span><br><span class="line">spring.kafka.streams.ssl.key-store-location = ＃密钥库文件的位置。</span><br><span class="line">spring.kafka.streams.ssl.key-store-password = ＃存储密钥库文件的密码。</span><br><span class="line">spring.kafka.streams.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">spring.kafka.streams.ssl.protocol = ＃要使用的SSL协议。</span><br><span class="line">spring.kafka.streams.ssl.trust-store-location = ＃信任库文件的位置。</span><br><span class="line">spring.kafka.streams.ssl.trust-store-password = ＃存储信任存储文件的密码。</span><br><span class="line">spring.kafka.streams.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line">spring.kafka.streams.state-dir = ＃状态存储的目录位置。</span><br><span class="line">spring.kafka.template.default-topic = ＃发送消息的默认主题。</span><br><span class="line"></span><br><span class="line">#RABBIT（RabbitProperties）</span><br><span class="line">spring.rabbitmq.addresses = ＃逗号分隔的客户端应连接的地址列表。</span><br><span class="line">spring.rabbitmq.cache.channel.checkout-timeout = ＃达到缓存大小后等待获取通道的持续时间。</span><br><span class="line">spring.rabbitmq.cache.channel.size = ＃要在缓存中保留的通道数。</span><br><span class="line">spring.rabbitmq.cache.connection.mode = channel ＃连接工厂缓存模式。</span><br><span class="line">spring.rabbitmq.cache.connection.size = ＃缓存的连接数。</span><br><span class="line">spring.rabbitmq.connection-timeout = ＃连接超时。将其设置为零以永远等待。</span><br><span class="line">spring.rabbitmq.dynamic = true ＃是否创建AmqpAdmin bean。</span><br><span class="line">spring.rabbitmq.host = localhost ＃RabbitMQ主机。</span><br><span class="line">spring.rabbitmq.listener.direct.acknowledge-mode = ＃容器的确认模式。</span><br><span class="line">spring.rabbitmq.listener.direct.auto-startup = true ＃是否在启动时自动启动容器。</span><br><span class="line">spring.rabbitmq.listener.direct.consumers-per-queue = ＃每个队列的消费者数量。</span><br><span class="line">spring.rabbitmq.listener.direct.default-requeue-rejected = ＃默认情况下，拒绝的交付是否重新排队。</span><br><span class="line">spring.rabbitmq.listener.direct.idle-event-interval =＃应该发布空闲容器事件的频率。</span><br><span class="line">spring.rabbitmq.listener.direct.missing-queues-fatal = false ＃如果容器声明的队列在代理上不可用，则是否失败。</span><br><span class="line">spring.rabbitmq.listener.direct.prefetch = ＃每个消费者可能未完成的未确认消息的最大数量。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.enabled = false ＃是否启用发布重试。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.initial-interval = 1000ms ＃第一次和第二次尝试传递消息之间的持续时间。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.max-attempts = 3＃传递邮件的最大尝试次数。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.max -interval = 10000ms ＃尝试之间的最长持续时间。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.multiplier = 1 ＃乘数应用于先前的重试间隔。</span><br><span class="line">spring.rabbitmq.listener.direct.retry.stateless = true ＃重试是无状态还是有状态。</span><br><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode = ＃容器的确认模式。</span><br><span class="line">spring.rabbitmq.listener.simple.auto-startup = true ＃是否在启动时自动启动容器。</span><br><span class="line">spring.rabbitmq.listener.simple.concurrency =＃侦听器调用者线程的最小数量。</span><br><span class="line">spring.rabbitmq.listener.simple.default-requeue-rejected = ＃默认情况下，拒绝的交付是否重新排队。</span><br><span class="line">spring.rabbitmq.listener.simple.idle-event-interval = ＃应该发布空闲容器事件的频率。</span><br><span class="line">spring.rabbitmq.listener.simple.max-concurrency = ＃侦听器调用者线程的最大数量。</span><br><span class="line">spring.rabbitmq.listener.simple.missing-queues-fatal = true ＃如果容器声明的队列在代理上不可用，则是否失败和/或如果在运行时删除一个或多个队列，是否停止容器。</span><br><span class="line">spring.rabbitmq.listener.simple.prefetch =＃每个消费者可能未完成的未确认消息的最大数量。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.enabled = false ＃是否启用发布重试。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.initial-interval = 1000ms ＃第一次和第二次尝试传递消息之间的持续时间。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.max-attempts = 3 ＃传递邮件的最大尝试次数。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.max -interval = 10000ms ＃尝试之间的最长持续时间。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.multiplier = 1 ＃乘数应用于上一个重试间隔。</span><br><span class="line">spring.rabbitmq.listener.simple.retry.stateless = true ＃重试是无状态还是有状态。</span><br><span class="line">spring.rabbitmq.listener.simple.transaction-size = ＃确认模式为AUTO时要在acks之间处理的消息数。如果大于预取，则预取将增加到此值。</span><br><span class="line">spring.rabbitmq.listener.type = simple ＃Listener容器类型。</span><br><span class="line">spring.rabbitmq.password = guest ＃登录以对代理进行身份验证。</span><br><span class="line">spring.rabbitmq.port = 5672 ＃RabbitMQ端口。</span><br><span class="line">spring.rabbitmq.publisher-confirms = false ＃是否启用发布者确认。</span><br><span class="line">spring.rabbitmq.publisher-returns = false＃是否启用发布者返回。</span><br><span class="line">spring.rabbitmq.requested-heartbeat = ＃请求心跳超时; 零，没有。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line">spring.rabbitmq.ssl.algorithm = #SSL 算法使用。默认情况下，由Rabbit客户端库配置。</span><br><span class="line">spring.rabbitmq.ssl.enabled = false ＃是否启用SSL支持。</span><br><span class="line">spring.rabbitmq.ssl.key-store = ＃保存SSL证书的密钥库的路径。</span><br><span class="line">spring.rabbitmq.ssl.key-store-password = ＃用于访问密钥库的密码。</span><br><span class="line">spring.rabbitmq.ssl.key-store-type = PKCS12 ＃密钥库类型。</span><br><span class="line">spring.rabbitmq.ssl.trust-store = ＃持有SSL证书的信任存储。</span><br><span class="line">spring.rabbitmq.ssl.trust-store-password = ＃用于访问信任库的密码。</span><br><span class="line">spring.rabbitmq.ssl.trust-store-type = JKS #Trust store type。</span><br><span class="line">spring.rabbitmq.ssl.validate-server-certificate = true ＃是否启用服务器端证书验证。</span><br><span class="line">spring.rabbitmq.ssl.verify-hostname = true ＃是否启用主机名验证。</span><br><span class="line">spring.rabbitmq.template.default-receive-queue = ＃从明确指定none时接收消息的默认队列的名称。</span><br><span class="line">spring.rabbitmq.template.exchange =＃用于发送操作的默认交换的名称。</span><br><span class="line">spring.rabbitmq.template.mandatory = ＃是否启用强制消息。</span><br><span class="line">spring.rabbitmq.template.receive-timeout = ＃receive（）`操作的超时。</span><br><span class="line">spring.rabbitmq.template.reply-timeout = #outoutout用于`sendAndReceive（）`操作。</span><br><span class="line">spring.rabbitmq.template.retry.enabled = false ＃是否启用发布重试。</span><br><span class="line">spring.rabbitmq.template.retry.initial-interval = 1000ms ＃第一次和第二次尝试传递消息之间的持续时间。</span><br><span class="line">spring.rabbitmq.template.retry.max-attempts = 3 ＃传递邮件的最大尝试次数。</span><br><span class="line">spring.rabbitmq.template.retry.max -interval = 10000ms ＃尝试之间的最长持续时间。</span><br><span class="line">spring.rabbitmq.template.retry.multiplier = 1 ＃乘数应用于先前的重试间隔。</span><br><span class="line">spring.rabbitmq.template.routing-key = ＃用于发送操作的默认路由密钥的值。</span><br><span class="line">spring.rabbitmq.username = guest ＃登录用户以对代理进行身份验证。</span><br><span class="line">spring.rabbitmq.virtual-host = ＃连接到代理时使用的虚拟主机。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">＃---------------------------------------- </span><br><span class="line">＃ACTUATOR PROPERTIES </span><br><span class="line">＃----- -----------------------------------</span><br><span class="line"></span><br><span class="line">#MANAGEMENT HTTP SERVER（ManagementServerProperties）</span><br><span class="line">management.server.add-application-context-header = false ＃在每个响应中添加“X-Application-Context”HTTP标头。</span><br><span class="line">management.server.address = ＃管理端点应绑定到的网络地址。需要自定义management.server.port。</span><br><span class="line">management.server.port = ＃管理端点HTTP端口（默认情况下使用与应用程序相同的端口）。配置其他端口以使用特定于管理的SSL。</span><br><span class="line">management.server.servlet.context-path = ＃管理端点context-path（例如，`/ management`）。需要自定义management.server.port。</span><br><span class="line">management.server.ssl.ciphers= ＃支持的SSL密码。</span><br><span class="line">management.server.ssl.client-auth = ＃客户端身份验证模式。</span><br><span class="line">management.server.ssl.enabled = true ＃是否启用SSL支持。</span><br><span class="line">management.server.ssl.enabled-protocols = ＃启用SSL协议。</span><br><span class="line">management.server.ssl.key-alias = ＃标识密钥库中密钥的别名。</span><br><span class="line">management.server.ssl.key-password = ＃用于访问密钥库中密钥的密码。</span><br><span class="line">management.server.ssl.key-store = ＃保存SSL证书的密钥库的路径（通常是jks文件）。</span><br><span class="line">management.server.ssl.key-store-password =＃用于访问密钥库的密码。</span><br><span class="line">management.server.ssl.key-store-provider = ＃密钥库的提供者。</span><br><span class="line">management.server.ssl.key-store-type = ＃密钥库的类型。</span><br><span class="line">management.server.ssl.protocol = TLS ＃要使用的SSL协议。</span><br><span class="line">management.server.ssl.trust-store = ＃持有SSL证书的信任存储。</span><br><span class="line">management.server.ssl.trust-store-password = ＃用于访问信任库的密码。</span><br><span class="line">management.server.ssl.trust-store-provider = ＃信任存储的提供者。</span><br><span class="line">management.server.ssl.trust-store-type = ＃信任库的类型。</span><br><span class="line"></span><br><span class="line">#CLOUDFOUNDRY </span><br><span class="line">management.cloudfoundry.enabled = true ＃是否启用扩展的Cloud Foundry执行器端点。</span><br><span class="line">management.cloudfoundry.skip-ssl-validation = false ＃是否跳过Cloud Foundry执行器端点安全调用的SSL验证。</span><br><span class="line"></span><br><span class="line">#ENDPOINTS GENERAL CONFIGURATION </span><br><span class="line">management.endpoints.enabled-by-default = ＃默认情况下是否启用或禁用所有端点。</span><br><span class="line"></span><br><span class="line">#ENDPOINTS JMX CONFIGURATION（JmxEndpointProperties）</span><br><span class="line">management.endpoints.jmx.domain = org.springframework.boot #Endpoints JMX域名。如果设置，则回退到&apos;spring.jmx.default-domain&apos;。</span><br><span class="line">management.endpoints.jmx.exposure.include = * ＃应包含的端点ID或所有的“*”。</span><br><span class="line">management.endpoints.jmx.exposure.exclude = ＃应排除的端点ID或所有的&apos;*&apos;。</span><br><span class="line">management.endpoints.jmx.static-names = ＃附加的静态属性，附加到表示端点的MBean的所有ObjectName。</span><br><span class="line"></span><br><span class="line">#ENDPOINTS WEB CONFIGURATION（WebEndpointProperties）</span><br><span class="line">management.endpoints.web.exposure.include = health，info ＃应包含的端点ID或所有的“*”。</span><br><span class="line">management.endpoints.web.exposure.exclude = ＃应排除的端点ID或所有的&apos;*&apos;。</span><br><span class="line">management.endpoints.web.base-path = / actuator #Web端点的基本路径。相对于server.servlet.context-path或management.server.servlet.context-path，如果配置了management.server.port。</span><br><span class="line">management.endpoints.web.path-mapping = ＃端点ID与应公开它们的路径之间的映射。</span><br><span class="line"></span><br><span class="line">#ENDPOINTS CORS CONFIGURATION（CorsEndpointProperties）</span><br><span class="line">management.endpoints.web.cors.allow-credentials = ＃是否支持凭据。未设置时，不支持凭据。</span><br><span class="line">management.endpoints.web.cors.allowed-headers = ＃逗号分隔的请求中允许的标头列表。&apos;*&apos;允许所有标题。</span><br><span class="line">management.endpoints.web.cors.allowed-methods = ＃逗号分隔的允许方法列表。&apos;*&apos;允许所有方法。未设置时，默认为GET。</span><br><span class="line">management.endpoints.web.cors.allowed-origins = ＃逗号分隔的原始列表允许。&apos;*&apos;允许所有来源。未设置时，将禁用CORS支持。</span><br><span class="line">management.endpoints.web.cors.exposed-headers = ＃逗号分隔的标题列表，包含在响应中。</span><br><span class="line">management.endpoints.web.cors.max-age = 1800s ＃客户端缓存来自飞行前请求的响应的时间。如果未指定持续时间后缀，则将使用秒。</span><br><span class="line"></span><br><span class="line">#AUDIT EVENTS ENDPOINT（AuditEventsEndpoint）</span><br><span class="line">management.endpoint.auditevents.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.auditevents.enabled = true ＃是否启用auditevents端点。</span><br><span class="line"></span><br><span class="line">#BEANS ENDPOINT（BeansEndpoint）</span><br><span class="line">management.endpoint.beans.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.beans.enabled = true ＃是否启用beans端点。</span><br><span class="line"></span><br><span class="line">#CACHES ENDPOINT（CachesEndpoint）</span><br><span class="line">management.endpoint.caches.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.caches.enabled = true ＃是否启用缓存端点。</span><br><span class="line"></span><br><span class="line">#条件报告ENDPOINT（ConditionsReportEndpoint）</span><br><span class="line">management.endpoint.conditions.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.conditions.enabled = true ＃是否启用条件端点。</span><br><span class="line"></span><br><span class="line">#CONFIGURATION PROPERTIES REPORT ENDPOINT（ConfigurationPropertiesReportEndpoint，ConfigurationPropertiesReportEndpointProperties）</span><br><span class="line">management.endpoint.configprops.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.configprops.enabled = true ＃是否启用configprops端点。</span><br><span class="line">management.endpoint.configprops.keys-to-sanitize = password，secret，key，token，。* credentials。*，vcap_services，sun.java.command ＃应该清理的密钥。键可以是属性结尾的简单字符串或正则表达式。</span><br><span class="line"></span><br><span class="line">#ENVEST ENDPOINT（EnvironmentEndpoint，EnvironmentEndpointProperties）</span><br><span class="line">management.endpoint.env.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.env.enabled = true ＃是否启用env端点。</span><br><span class="line">management.endpoint.env.keys-to-sanitize = password，secret，key，token，。* credentials。*，vcap_services，sun.java.command ＃应该清理的密钥。键可以是属性结尾的简单字符串或正则表达式。</span><br><span class="line"></span><br><span class="line">#FLYWAY ENDPOINT（FlywayEndpoint）</span><br><span class="line"> management.endpoint.flyway.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.flyway.enabled = true ＃是否启用flyway端点。</span><br><span class="line"></span><br><span class="line">#HEEC ENDPOINT（HealthEndpoint，HealthEndpointProperties）</span><br><span class="line">management.endpoint.health.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.health.enabled = true ＃是否启用运行状况端点。</span><br><span class="line">management.endpoint.health.roles = ＃用于确定是否授权用户显示详细信息的角色。为空时，所有经过身份验证的用户都被授权。</span><br><span class="line">management.endpoint.health.show-details = never ＃何时显示完整的健康详细信息。</span><br><span class="line"></span><br><span class="line">#HEAP DUMP ENDPOINT（HeapDumpWebEndpoint）</span><br><span class="line">management.endpoint.heapdump.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.heapdump.enabled = true ＃是否启用heapdump端点。</span><br><span class="line"></span><br><span class="line">#HTTP TRACE ENDPOINT（HttpTraceEndpoint）</span><br><span class="line">management.endpoint.httptrace.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.httptrace.enabled = true ＃是否启用httptrace端点。</span><br><span class="line"></span><br><span class="line">#INFO ENDPOINT（InfoEndpoint）</span><br><span class="line">info = ＃要添加到信息端点的任意属性。</span><br><span class="line">management.endpoint.info.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.info.enabled = true ＃是否启用信息端点。</span><br><span class="line"></span><br><span class="line">#INTEGRATION GRAPH ENDPOINT（IntegrationGraphEndpoint）</span><br><span class="line">management.endpoint.integrationgraph.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.integrationgraph.enabled = true ＃是否启用集成图终结点。</span><br><span class="line"></span><br><span class="line">#JOLOKIA ENDPOINT（JolokiaProperties）</span><br><span class="line">management.endpoint.jolokia.config。* = ＃Jolokia设置。有关更多详细信息，请参阅Jolokia的文档。</span><br><span class="line">management.endpoint.jolokia.enabled = true ＃是否启用jolokia端点。</span><br><span class="line"></span><br><span class="line">#LIQUIBASE ENDPOINT（LiquibaseEndpoint）</span><br><span class="line">management.endpoint.liquibase.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.liquibase.enabled = true ＃是否启用liquibase端点。</span><br><span class="line"></span><br><span class="line">＃LOG FILE ENDPOINT（LogFileWebEndpoint，LogFileWebEndpointProperties）</span><br><span class="line">management.endpoint.logfile.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.logfile.enabled = true ＃是否启用日志文件端点。</span><br><span class="line">management.endpoint.logfile.external-file = ＃要访问的外部日志文件。如果日志文件由输出重定向而不是日志记录系统本身写入，则可以使用。</span><br><span class="line"></span><br><span class="line">＃LOGGERS ENDPOINT（LoggersEndpoint）</span><br><span class="line">management.endpoint.loggers.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.loggers.enabled = true ＃是否启用记录器端点。</span><br><span class="line"></span><br><span class="line">#REQUEST MAPPING ENDPOINT（MappingsEndpoint）</span><br><span class="line">management.endpoint.mappings.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.mappings.enabled = true ＃是否启用映射端点。</span><br><span class="line"></span><br><span class="line">#METRICS ENDPOINT（MetricsEndpoint）</span><br><span class="line">management.endpoint.metrics.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.metrics.enabled = true ＃是否启用指标端点。</span><br><span class="line"></span><br><span class="line">#PROMETHEUS ENDPOINT（PrometheusScrapeEndpoint）</span><br><span class="line">management.endpoint.prometheus.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.prometheus.enabled = true ＃是否启用prometheus端点。</span><br><span class="line"></span><br><span class="line">#STEEDEDED TASKS ENDPOINT（ScheduledTasksEndpoint）</span><br><span class="line">management.endpoint.scheduledtasks.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.scheduledtasks.enabled = true ＃是否启用scheduledtasks端点。</span><br><span class="line"></span><br><span class="line">#SESSIONS ENDPOINT（SessionsEndpoint）</span><br><span class="line">management.endpoint.sessions.enabled = true ＃是否启用会话端点。</span><br><span class="line"></span><br><span class="line">#SHUTDOWN ENDPOINT（ShutdownEndpoint）</span><br><span class="line">management.endpoint.shutdown.enabled = false ＃是否启用关闭端点。</span><br><span class="line"></span><br><span class="line">#THREAD DUMP ENDPOINT（ThreadDumpEndpoint）</span><br><span class="line">management.endpoint.threaddump.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。</span><br><span class="line">management.endpoint.threaddump.enabled = true ＃是否启用threaddump端点。</span><br><span class="line"></span><br><span class="line">#HEALTH INDICATORS </span><br><span class="line">management.health.db.enabled = true ＃是否启用数据库运行状况检查。</span><br><span class="line">management.health.cassandra.enabled = true ＃是否启用Cassandra运行状况检查。</span><br><span class="line">management.health.couchbase.enabled = true ＃是否启用Couchbase运行状况检查。</span><br><span class="line">management.health.defaults.enabled = true ＃是否启用默认健康指标。</span><br><span class="line">management.health.diskspace.enabled = true ＃是否启用磁盘空间运行状况检查。</span><br><span class="line">management.health.diskspace.path = ＃用于计算可用磁盘空间的路径。</span><br><span class="line">management.health.diskspace.threshold = 10MB＃应该可用的最小磁盘空间。</span><br><span class="line">management.health.elasticsearch.enabled = true ＃是否启用Elasticsearch运行状况检查。</span><br><span class="line">management.health.elasticsearch.indices = ＃逗号分隔的索引名称。</span><br><span class="line">management.health.elasticsearch.response-timeout = 100ms ＃等待集群响应的时间。</span><br><span class="line">management.health.influxdb.enabled = true ＃是否启用InfluxDB运行状况检查。</span><br><span class="line">management.health.jms.enabled = true ＃是否启用JMS运行状况检查。</span><br><span class="line">management.health.ldap.enabled = true ＃是否启用LDAP运行状况检查。</span><br><span class="line">management.health.mail.enabled = true＃是否启用邮件健康检查。</span><br><span class="line">management.health.mongo.enabled = true ＃是否启用MongoDB运行状况检查。</span><br><span class="line">management.health.neo4j.enabled = true ＃是否启用Neo4j运行状况检查。</span><br><span class="line">management.health.rabbit.enabled = true ＃是否启用RabbitMQ运行状况检查。</span><br><span class="line">management.health.redis.enabled = true ＃是否启用Redis运行状况检查。</span><br><span class="line">management.health.solr.enabled = true ＃是否启用Solr运行状况检查。</span><br><span class="line">management.health.status.http-mapping = ＃将健康状态映射到HTTP状态代码。默认情况下，已注册的运行状况映射到合理的默认值（例如，UP映射到200）。</span><br><span class="line">management.health.status.order = DOWN，OUT_OF_SERVICE，UP，UNKNOWN ＃以逗号分隔的健康状态列表，按严重程度排序。</span><br><span class="line"></span><br><span class="line">#HTTP TRACING（HttpTraceProperties）</span><br><span class="line">management.trace.http.enabled = true ＃是否启用HTTP请求 - 响应跟踪。</span><br><span class="line">management.trace.http.include =请求标头，响应标头，cookie，错误＃要包含在跟踪中的项目。</span><br><span class="line"></span><br><span class="line">#INFO CONTRIBUTORS（InfoContributorProperties）</span><br><span class="line">management.info.build.enabled = true ＃是否启用构建信息。</span><br><span class="line">management.info.defaults.enabled = true ＃是否启用默认信息贡献者。</span><br><span class="line">management.info.env.enabled = true ＃是否启用环境信息。</span><br><span class="line">management.info.git.enabled = true ＃是否启用git信息。</span><br><span class="line">management.info.git.mode = simple ＃用于公开git信息的模式。</span><br><span class="line"></span><br><span class="line">#METRICS </span><br><span class="line">management.metrics.distribution.maximum-expected-value。* = ＃预计将以指定名称开始计量ID的最大值。</span><br><span class="line">management.metrics.distribution.minimum-expected-value。* = ＃预计将以指定名称开始的仪表ID的最小值。</span><br><span class="line">management.metrics.distribution.percentiles。* = ＃特定计算的非可聚合百分位数，用于以指定名称开始的仪表ID发送到后端。</span><br><span class="line">management.metrics.distribution.percentiles-histogram。* = ＃是否以指定名称开头的米ID应发布百分位直方图。</span><br><span class="line">management.metrics.distribution.sla。* =＃以指定名称开头的仪表ID的特定SLA边界。最长的比赛获胜。</span><br><span class="line">management.metrics.enable。* = ＃应启用是否以指定名称开始的仪表ID。最长的匹配获胜，关键的“all”也可以用于配置所有的米。</span><br><span class="line">management.metrics.export.appoptics.api-token = #AppOptics API令牌。</span><br><span class="line">management.metrics.export.appoptics.batch-size = 500 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.appoptics.connect-timeout = 5s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.appoptics.enabled= true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.appoptics.host-tag = instance ＃将指标发送到AppOptics时将映射到“@host”的标记。</span><br><span class="line">management.metrics.export.appoptics.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.appoptics.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.appoptics.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.appoptics.uri = https://api.appoptics.com/v1/measurements# 将指标发送到的URI。</span><br><span class="line">management.metrics.export.atlas.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.atlas.config-refresh-frequency = 10s ＃从LWC服务刷新配置设置的频率。</span><br><span class="line">management.metrics.export.atlas.config-time-to-live = 150s #LWC服务订阅的生存时间。</span><br><span class="line">management.metrics.export.atlas.config-uri = http：// localhost：7101 / lwc / api / v1 / expressions / local-dev #Atlas LWC端点的URI，用于检索当前订阅。</span><br><span class="line">management.metrics.export.atlas.connect-timeout = 1s＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.atlas.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.atlas.eval-uri = http：// localhost：7101 / lwc / api / v1 / evaluate ＃用于评估订阅数据的Atlas LWC端点的URI。</span><br><span class="line">management.metrics.export.atlas.lwc-enabled = false ＃是否启用流式传输到Atlas LWC。</span><br><span class="line">management.metrics.export.atlas.meter-time-to-live = 15m ＃没有任何活动的米的生存时间。在此期限之后，仪表将被视为已过期且不会报告。</span><br><span class="line">management.metrics.export.atlas.num-threads = 2＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.atlas.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.atlas.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.atlas.uri = http：// localhost：7101 / api / v1 / publish #Atlas服务器的URI。</span><br><span class="line">management.metrics.export.datadog.api-key = ＃Datadog API密钥。</span><br><span class="line">management.metrics.export.datadog.application-key = ＃Datadog应用程序密钥。不是严格要求，但通过向Datadog发送仪表描述，类型和基本单位来改进Datadog体验。</span><br><span class="line">management.metrics.export.datadog.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.datadog.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.datadog.descriptions = true ＃是否将描述元数据发布到Datadog。将其关闭以最小化发送的元数据量。</span><br><span class="line">management.metrics.export.datadog.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.datadog.host-tag = instance＃将指标发送到Datadog时将映射到“主机”的标记。</span><br><span class="line">management.metrics.export.datadog.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.datadog.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.datadog.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.datadog.uri = https://app.datadoghq.com# 将指标发送到的URI。如果需要将指标发布到到Datadog的内部代理，则可以使用此方法定义代理的位置。</span><br><span class="line">management.metrics.export.dynatrace.api-token =#Dynatrace身份验证令牌。</span><br><span class="line">management.metrics.export.dynatrace.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.dynatrace.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.dynatrace.device-id = 将度量标准导出到Dynatrace的自定义设备的ID。</span><br><span class="line">management.metrics.export.dynatrace.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.dynatrace.num-threads = 2＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.dynatrace.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.dynatrace.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.dynatrace.technology-type = java ＃导出的指标的技术类型。用于在Dynatrace UI中对逻辑技术名称下的度量标准进行分组。</span><br><span class="line">management.metrics.export.dynatrace.uri = 将指标发送到的URI。应该用于SaaS，自我管理的实例或通过内部代理途径。</span><br><span class="line">management.metrics.export.elastic.auto-create-index = true＃是否自动创建索引（如果不存在）。</span><br><span class="line">management.metrics.export.elastic.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.elastic.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.elastic.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.elastic.host = http：// localhost：9200 ＃将指标导出到的主机。</span><br><span class="line">management.metrics.export.elastic.index = metrics ＃将指标导出到的索引。</span><br><span class="line">management.metrics.export.elastic.index-date-format = yyyy-MM ＃用于滚动索引的索引日期格式。附加到索引名称后面加一个&apos; - &apos;。</span><br><span class="line">management.metrics.export.elastic.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.elastic.password = ＃弹性服务器的登录密码。</span><br><span class="line">management.metrics.export.elastic.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.elastic.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.elastic.timestamp-field-name = @ timestamp ＃时间戳字段的名称。 </span><br><span class="line">management.metrics.export.elastic.user-name = ＃弹性服务器的登录用户。</span><br><span class="line">management.metrics.export.ganglia.addressing-mode = multicast ＃UDP寻址模式，单播或多播。</span><br><span class="line">management.metrics.export.ganglia.duration- units =毫秒＃用于报告持续时间的基本时间单位。</span><br><span class="line">management.metrics.export.ganglia.enabled = true ＃是否启用向Ganglia导出指标。</span><br><span class="line">management.metrics.export.ganglia.host = localhost ＃Ganglia服务器的主机，用于接收导出的指标。</span><br><span class="line">management.metrics.export.ganglia.port = 8649 ＃Ganglia服务器端口，用于接收导出的指标。</span><br><span class="line">management.metrics.export.ganglia.protocol-version = 3.1 ＃Ganglia协议版本。必须是3.1或3.0。</span><br><span class="line">management.metrics.export.ganglia.rate- units = seconds ＃用于报告费率的基本时间单位。</span><br><span class="line">management.metrics.export.ganglia.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.ganglia.time-to-live = 1 ＃生活在Ganglia上的指标的时间。将多播生存时间设置为大于主机之间的跳数（路由器）的数量。</span><br><span class="line">management.metrics.export.graphite.duration-units =毫秒＃用于报告持续时间的基本时间单位。</span><br><span class="line">management.metrics.export.graphite.enabled = true＃是否启用将指标导出到Graphite。</span><br><span class="line">management.metrics.export.graphite.host = localhost ＃Graphite服务器的主机，用于接收导出的指标。</span><br><span class="line">management.metrics.export.graphite.port = 2004 ＃Graphite服务器的端口，用于接收导出的指标。</span><br><span class="line">management.metrics.export.graphite.protocol = pickled ＃在将数据发送到Graphite时使用的协议。</span><br><span class="line">management.metrics.export.graphite.rate-units = seconds ＃用于报告费率的基本时间单位。</span><br><span class="line">management.metrics.export.graphite.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.graphite.tags-as-prefix =＃对于默认命名约定，将指定的标记键转换为度量标准前缀的一部分。</span><br><span class="line">management.metrics.export.humio.api-token = ＃Humio API令牌。</span><br><span class="line">management.metrics.export.humio.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.humio.connect-timeout = 5s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.humio.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.humio.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.humio.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.humio.repository = sandbox ＃要将指标发布到的存储库的名称。</span><br><span class="line">management.metrics.export.humio.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.humio.tags。* = ＃Humio标签，用于描述将存储指标的数据源。Humio标签是与Micrometer标签不同的概念。千分尺的标签用于沿尺寸边界划分度量。</span><br><span class="line">management.metrics.export.humio.uri = https://cloud.humio.com#idex将指标发送到。如果您需要将指标发布到Humio的内部代理，您可以使用此方法定义代理的位置。</span><br><span class="line">management.metrics.export.influx.auto-create-db = true ＃在尝试向其发布指标之前，是否创建Influx数据库是否存在。</span><br><span class="line">management.metrics.export.influx.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.influx.compressed = true ＃是否对发布到Influx的度量批次启用GZIP压缩。</span><br><span class="line">management.metrics.export.influx.connect-timeout = 1s＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.influx.consistency = one ＃为每个点写一致性。</span><br><span class="line">management.metrics.export.influx.db = mydb ＃将指标发送到Influx时将映射到“主机”的标记。</span><br><span class="line">management.metrics.export.influx.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.influx.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.influx.password = ＃Influx服务器的登录密码。</span><br><span class="line">management.metrics.export.influx.read-timeout = 10s＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.influx.retention-duration = ＃Influx应在当前数据库中保留数据的时间段。</span><br><span class="line">management.metrics.export.influx.retention-shard-duration = ＃分片组覆盖的时间范围。</span><br><span class="line">management.metrics.export.influx.retention-policy = ＃要使用的保留策略（如果未指定，则Influx写入DEFAULT保留策略）。</span><br><span class="line">management.metrics.export.influx.retention-replication-factor = ＃在群集中存储了多少份数据副本。</span><br><span class="line">management.metrics.export.influx.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.influx.uri = http：// localhost：8086 ＃Influx服务器的URI。</span><br><span class="line">management.metrics.export.influx.user-name = ＃Influx服务器的登录用户。</span><br><span class="line">management.metrics.export.jmx.domain = metrics ＃Metrics JMX域名。</span><br><span class="line">management.metrics.export.jmx.enabled = true ＃是否已启用将度量标准导出到JMX。</span><br><span class="line">management.metrics.export.jmx.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.kairos.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.kairos.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.kairos.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.kairos.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.kairos.password = #KairosDB服务器的登录密码。</span><br><span class="line">management.metrics.export.kairos.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.kairos.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.kairos.uri = localhost：8080 / api / v1 /  datapoints #KairosDB服务器的URI。</span><br><span class="line">management.metrics.export.kairos.user-name = #KairosDB服务器的登录用户。</span><br><span class="line">management.metrics.export.newrelic.account-id = ＃新Relic帐户ID。</span><br><span class="line">management.metrics.export.newrelic.api-key = #New Relic API密钥。</span><br><span class="line">management.metrics.export.newrelic.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.newrelic.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.newrelic.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.newrelic.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.newrelic.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.newrelic.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.newrelic.uri = https：//insights-collector.newrelic.com #idex 将指标发送到。</span><br><span class="line">management.metrics.export.prometheus.descriptions = true＃是否将发布描述作为scrape有效负载的一部分启用到Prometheus。将其关闭以最小化每次刮擦发送的数据量。</span><br><span class="line">management.metrics.export.prometheus.enabled = true ＃是否启用将指标导出到Prometheus。</span><br><span class="line">management.metrics.export.prometheus.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.base-url = localhost：9091 ＃Pushgateway的基本URL。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.enabled = false ＃通过Prometheus Pushgateway启用发布。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.grouping-key =＃为推送的指标分组键。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.job = ＃此应用程序实例的作业标识符。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.push-rate = 1m ＃用于推送指标的频率。</span><br><span class="line">management.metrics.export.prometheus.pushgateway.shutdown-operation = ＃应该在关机时执行的操作。</span><br><span class="line">management.metrics.export.signalfx.access-token = #SignalFX访问令牌。</span><br><span class="line">management.metrics.export.signalfx.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.signalfx.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.signalfx.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.signalfx.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.signalfx.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.signalfx.source = ＃唯一标识正在向SignalFx发布指标的应用实例。默认为本地主机名。</span><br><span class="line">management.metrics.export.signalfx.step = 10s＃步骤大小（即报告频率）使用。</span><br><span class="line">management.metrics.export.signalfx.uri = https：//ingest.signalfx.com# 将指标发送到的URI。</span><br><span class="line">management.metrics.export.simple.enabled = true ＃在没有任何其他导出器的情况下，是否启用将指标导出到内存后端。</span><br><span class="line">management.metrics.export.simple.mode =累积＃计数模式。</span><br><span class="line">management.metrics.export.simple.step = 1m ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.statsd.enabled = true ＃是否启用将度量标准导出到StatsD。</span><br><span class="line">management.metrics.export.statsd.flavor = datadog#StatsD线路协议使用。</span><br><span class="line">management.metrics.export.statsd.host = localhost ＃StatsD服务器的主机，用于接收导出的指标。</span><br><span class="line">management.metrics.export.statsd.max-packet-length = 1400 ＃单个有效负载的总长度应保持在网络的MTU中。</span><br><span class="line">management.metrics.export.statsd.polling-frequency = 10s ＃测量仪表的频率。轮询仪表时，会重新计算其值，如果值已更改（或者publishUnchangedMeters为true），则会将其发送到StatsD服务器。</span><br><span class="line">management.metrics.export.statsd.port = 8125 ＃StatsD服务器的端口，用于接收导出的指标。</span><br><span class="line">management.metrics.export.statsd.publish-不变米= true ＃是否将未更改的计量表发送到StatsD服务器。</span><br><span class="line">management.metrics.export.wavefront.api-token = ＃将指标直接发布到Wavefront API主机时使用的API令牌。</span><br><span class="line">management.metrics.export.wavefront.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。</span><br><span class="line">management.metrics.export.wavefront.connect-timeout = 1s ＃对此后端的请求的连接超时。</span><br><span class="line">management.metrics.export.wavefront.enabled = true ＃是否启用将度量标准导出到此后端。</span><br><span class="line">management.metrics.export.wavefront.global-prefix =＃全局前缀用于将源自此应用程序的白盒工具的度量标准与在Wavefront UI中查看时源自其他Wavefront集成的度量标准分开。</span><br><span class="line">management.metrics.export.wavefront.num-threads = 2 ＃指标发布计划程序使用的线程数。</span><br><span class="line">management.metrics.export.wavefront.read-timeout = 10s ＃读取此后端请求的超时时间。</span><br><span class="line">management.metrics.export.wavefront.source = ＃应用程序实例的唯一标识符，该实例是发布到Wavefront的度量标准的来源。默认为本地主机名。</span><br><span class="line">management.metrics.export.wavefront.step = 10s ＃要使用的步长（即报告频率）。</span><br><span class="line">management.metrics.export.wavefront.uri = https://longboard.wavefront.com# 将指标发送到的URI。</span><br><span class="line">management.metrics.use-global-registry = true ＃是否应将自动配置的MeterRegistry实现绑定到Metrics上的全局静态注册表。</span><br><span class="line">management.metrics.tags。* = ＃应用于每个仪表的公共标签。</span><br><span class="line">management.metrics.web.client.max-uri-tags = 100 ＃允许的唯一URI标记值的最大数量。达到最大标记值数后，过滤器将拒绝具有其他标记值的度量标准。</span><br><span class="line">management.metrics.web.client.requests-metric-name = http.client.requests ＃已发送请求的度量标准的名称。</span><br><span class="line">management.metrics.web.server.auto-time-requests = true ＃是否应自动为Spring MVC，WebFlux或Jersey处理的请求定时。</span><br><span class="line">management.metrics.web.server.max-uri-tags = 100 ＃允许的唯一URI标记值的最大数量。达到最大标记值数后，过滤器将拒绝具有其他标记值的度量标准。</span><br><span class="line">management.metrics.web.server.requests-metric-name = http.server.requests ＃已接收请求的度量标准的名称。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">＃---------------------------------------- </span><br><span class="line">#DEDTOOLS PROPERTIES </span><br><span class="line">＃----------------------------------------</span><br><span class="line"></span><br><span class="line">#DESTOOLS（DevToolsProperties）</span><br><span class="line">spring.devtools.add-properties = true ＃是否启用开发属性默认值。</span><br><span class="line">spring.devtools.livereload.enabled = true ＃是否启用livereload.com兼容服务器。</span><br><span class="line">spring.devtools.livereload.port = 35729 ＃服务器端口。</span><br><span class="line">spring.devtools.restart.additional-exclude = ＃应该从触发完全重启中排除的其他模式。</span><br><span class="line">spring.devtools.restart.additional-paths = ＃要监视更改的其他路径。</span><br><span class="line">spring.devtools.restart.enabled = true ＃是否启用自动重启。</span><br><span class="line">spring.devtools.restart.exclude= META-INF /行家/ **，META-INF /资源/ **，资源/ **，静态/ **，公共/ **，模板/ **，** / *的Test.class，** / * Tests.class，git.properties，META-INF / build-info.properties ＃应该从触发完全重启中排除的模式。</span><br><span class="line">spring.devtools.restart.log-condition-evaluation-delta = true ＃是否在重新启动时记录条件评估增量。</span><br><span class="line">spring.devtools.restart.poll-interval = 1s ＃轮询类路径更改之间等待的时间。</span><br><span class="line">spring.devtools.restart.quiet-period = 400ms ＃触发重启之前没有任何类路径更改所需的安静时间量。</span><br><span class="line">spring.devtools.restart.trigger-file =＃特定文件的名称，当更改时，触发重新启动检查。如果未指定，则任何类路径文件更改都会触发重新启动。</span><br><span class="line"></span><br><span class="line">#remote DEVTOOLS（RemoteDevToolsProperties）</span><br><span class="line">spring.devtools.remote.context-path = /。~~ spring-boot！〜＃用于处理远程连接的上下文路径。</span><br><span class="line">spring.devtools.remote.proxy.host = ＃用于连接远程应用程序的代理主机。</span><br><span class="line">spring.devtools.remote.proxy.port = ＃用于连接远程应用程序的代理端口。</span><br><span class="line">spring.devtools.remote.restart.enabled = true ＃是否启用远程重启。</span><br><span class="line">spring.devtools.remote.secret = ＃建立连接所需的共享密钥（启用远程支持所需）。</span><br><span class="line">spring.devtools.remote.secret头名= X-AUTH-TOKEN ＃用于传输共享密钥的HTTP头。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">＃---------------------------------------- </span><br><span class="line">#TESTING PROPERTIES </span><br><span class="line">＃----- -----------------------------------</span><br><span class="line"></span><br><span class="line">spring.test.database.replace = any ＃要替换的现有DataSource的类型。</span><br><span class="line">spring.test.mockmvc.print =default #MVC 打印选项。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> properties </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-SpringMVC</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-SpringMVC/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>Spring Boot有许多包含Spring MVC的启动器。请注意，一些启动器包含对Spring MVC的依赖，而不是直接包含它。本节回答有关Spring MVC和Spring Boot的常见问题。</p><h2 id="编写JSON-REST服务"><a href="#编写JSON-REST服务" class="headerlink" title="编写JSON REST服务"></a>编写JSON REST服务</h2><p><code>@RestController</code>只要Jackson2在类路径中，Spring Boot应用程序中的任何Spring 都应默认呈现JSON响应，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/thing"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> MyThing <span class="title">thing</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyThing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要<code>MyThing</code>可以通过Jackson2序列化（对于普通的POJO或Groovy对象都是如此），则<code>localhost:8080/thing</code>默认为它提供JSON表示。请注意，在浏览器中，您有时可能会看到XML响应，因为浏览器倾向于发送更喜欢XML的接受标头。</p><h2 id="编写XML-REST服务"><a href="#编写XML-REST服务" class="headerlink" title="编写XML REST服务"></a>编写XML REST服务</h2><p>如果<code>jackson-dataformat-xml</code>在类路径上有Jackson XML扩展（），则可以使用它来呈现XML响应。我们用于JSON的前一个示例可以使用。要使用Jackson XML渲染器，请将以下依赖项添加到项目中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果Jackson的XML扩展不可用，则使用JAXB（默认情况下在JDK中提供），并附加要求<code>MyThing</code>注释为 <code>@XmlRootElement</code>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThing</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">// .. getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使服务器呈现XML而不是JSON，您可能必须发送 <code>Accept: text/xml</code>标头（或使用浏览器）。</p><h2 id="自定义Jackson-ObjectMapper"><a href="#自定义Jackson-ObjectMapper" class="headerlink" title="自定义Jackson ObjectMapper"></a>自定义Jackson ObjectMapper</h2><p>Spring MVC（客户端和服务器端）用于<code>HttpMessageConverters</code>协商HTTP交换中的内容转换。如果Jackson在类路径上，您已经获得了由其提供的默认转换器<code>Jackson2ObjectMapperBuilder</code>，其实例将自动为您配置。</p><p>该<code>ObjectMapper</code>（或<code>XmlMapper</code>为JacksonXML转换器）实例（默认创建）具有以下定义的属性：</p><ul><li><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code> 被禁用</li><li><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code> 被禁用</li><li><code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code> 被禁用</li></ul><p>Spring Boot还具有一些功能，可以更轻松地自定义此行为。</p><p>您可以使用环境配置<code>ObjectMapper</code>和<code>XmlMapper</code>实例。Jackson提供了一套广泛的简单开/关功能，可用于配置其处理的各个方面。这些功能在六个enum（在Jackson中）中描述，它们映射到环境中的属性：</p><table><thead><tr><th style="text-align:center">枚举</th><th style="text-align:center">属性</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center"><code>com.fasterxml.jackson.databind.DeserializationFeature</code></td><td style="text-align:center"><code>spring.jackson.deserialization.&lt;feature_name&gt;</code></td><td style="text-align:center"><code>true</code>， <code>false</code></td></tr><tr><td style="text-align:center"><code>com.fasterxml.jackson.core.JsonGenerator.Feature</code></td><td style="text-align:center"><code>spring.jackson.generator.&lt;feature_name&gt;</code></td><td style="text-align:center"><code>true</code>， <code>false</code></td></tr><tr><td style="text-align:center"><code>com.fasterxml.jackson.databind.MapperFeature</code></td><td style="text-align:center"><code>spring.jackson.mapper.&lt;feature_name&gt;</code></td><td style="text-align:center"><code>true</code>， <code>false</code></td></tr><tr><td style="text-align:center"><code>com.fasterxml.jackson.core.JsonParser.Feature</code></td><td style="text-align:center"><code>spring.jackson.parser.&lt;feature_name&gt;</code></td><td style="text-align:center"><code>true</code>， <code>false</code></td></tr><tr><td style="text-align:center"><code>com.fasterxml.jackson.databind.SerializationFeature</code></td><td style="text-align:center"><code>spring.jackson.serialization.&lt;feature_name&gt;</code></td><td style="text-align:center"><code>true</code>， <code>false</code></td></tr><tr><td style="text-align:center"><code>com.fasterxml.jackson.annotation.JsonInclude.Include</code></td><td style="text-align:center"><code>spring.jackson.default-property-inclusion</code></td><td style="text-align:center"><code>always</code>，<code>non_null</code>，<code>non_absent</code>，<code>non_default</code>，<code>non_empty</code></td></tr></tbody></table><p>例如，要启用漂亮打印，请设置<code>spring.jackson.serialization.indent_output=true</code>。需要注意的是，由于使用了<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-relaxed-binding" target="_blank" rel="noopener">松弛绑定</a>，所以<code>indent_output</code>不必匹配相应枚举常量的情况，即<code>INDENT_OUTPUT</code>。</p><p>此基于环境的配置应用于自动配置的 <code>Jackson2ObjectMapperBuilder</code>bean，并应用于使用构建器创建的任何映射器，包括自动配置的<code>ObjectMapper</code>bean。</p><p>上下文<code>Jackson2ObjectMapperBuilder</code>可以由一个或多个<code>Jackson2ObjectMapperBuilderCustomizer</code>bean 自定义 。可以订购这样的定制器bean（Boot自己的定制器的顺序为0），允许在Boot定制之前和之后应用其他定制。</p><p>任何类型的bean都会<code>com.fasterxml.jackson.databind.Module</code>自动注册自动配置<code>Jackson2ObjectMapperBuilder</code>，并应用于<code>ObjectMapper</code> 它创建的任何实例。这为您在应用程序中添加新功能时提供了一种提供自定义模块的全局机制。</p><p>如果要<code>ObjectMapper</code>完全替换默认值，请定义<code>@Bean</code>该类型的一个并将其标记为，<code>@Primary</code>或者，如果您更喜欢基于构建器的方法，请定义一个<code>Jackson2ObjectMapperBuilder</code> <code>@Bean</code>。请注意，在任何一种情况下，这样做都会禁用所有的自动配置<code>ObjectMapper</code>。</p><p>如果提供任何<code>@Beans</code>类型<code>MappingJackson2HttpMessageConverter</code>，则它们将替换MVC配置中的默认值。此外，<code>HttpMessageConverters</code>还提供了类型的便利bean （如果使用默认的MVC配置，则始终可用）。它有一些有用的方法来访问默认和用户增强的消息转换器。</p><p>有关详细信息，请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-customize-the-responsebody-rendering" target="_blank" rel="noopener">第79.4节</a> ” <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-customize-the-responsebody-rendering" target="_blank" rel="noopener">，“自定义@ResponseBody渲染</a> ”部分和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java" target="_blank" rel="noopener"><code>WebMvcAutoConfiguration</code></a> 源代码。</p><h2 id="自定义-ResponseBody渲染"><a href="#自定义-ResponseBody渲染" class="headerlink" title="自定义@ResponseBody渲染"></a>自定义@ResponseBody渲染</h2><p>Spring用于<code>HttpMessageConverters</code>渲染<code>@ResponseBody</code>（或响应 <code>@RestController</code>）。您可以通过在Spring Boot上下文中添加适当类型的bean来提供其他转换器。如果您添加的bean是默认包含的类型（例如<code>MappingJackson2HttpMessageConverter</code>JSON转换），则它将替换默认值。<code>HttpMessageConverters</code>提供了类型的便利bean， 如果您使用默认的MVC配置，它始终可用。它有一些有用的方法来访问默认和用户增强的消息转换器（例如，如果要手动将它们注入自定义，它可能很有用<code>RestTemplate</code>）。</p><p>与正常的MVC使用情况一样，<code>WebMvcConfigurer</code>您提供的任何bean也可以通过覆盖该<code>configureMessageConverters</code>方法来提供转换器。但是，与普通的MVC不同，您只能提供所需的其他转换器（因为Spring Boot使用相同的机制来提供其默认值）。最后，如果您通过提供自己的<code>@EnableWebMvc</code>配置选择退出Spring Boot默认MVC 配置，则可以完全控制并使用<code>getMessageConverters</code>from 手动完成所有操作 <code>WebMvcConfigurationSupport</code>。</p><p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java" target="_blank" rel="noopener"><code>WebMvcAutoConfiguration</code></a> 更多详细信息，请参阅 源代码。</p><h2 id="处理多部分文件上传"><a href="#处理多部分文件上传" class="headerlink" title="处理多部分文件上传"></a>处理多部分文件上传</h2><p>Spring Boot包含Servlet 3 <code>javax.servlet.http.Part</code>API以支持上传文件。默认情况下，Spring Boot配置Spring MVC，每个文件的最大大小为1MB，单个请求中的文件数据最大为10MB。您可以覆盖这些值，中间数据的存储位置（例如，到<code>/tmp</code> 目录），以及使用<code>MultipartProperties</code>类中公开的属性将数据刷新到磁盘的阈值。例如，如果要指定文件不受限制，请将<code>spring.servlet.multipart.max-file-size</code>属性设置为<code>-1</code>。</p><p>当您希望在Spring MVC控制器处理程序方法中接收多部分编码文件数据作为<code>@RequestParam</code>类型的注释参数时，多部分支持很有用<code>MultipartFile</code>。</p><p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/MultipartAutoConfiguration.java" target="_blank" rel="noopener"><code>MultipartAutoConfiguration</code></a> 详细信息，请参阅 源代码。</p><blockquote><p>建议使用容器的内置支持进行分段上传，而不是引入其他依赖项，例如Apache Commons File Upload。</p></blockquote><h2 id="关闭Spring-MVC-DispatcherServlet"><a href="#关闭Spring-MVC-DispatcherServlet" class="headerlink" title="关闭Spring MVC DispatcherServlet"></a>关闭Spring MVC DispatcherServlet</h2><p>默认情况下，所有内容都是从应用程序的根目录（<code>/</code>）提供的。如果您希望映射到其他路径，可以按如下方式配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.servlet.path=/acme</span><br></pre></td></tr></table></figure><p>如果你有额外的servlet，你可以声明一个<code>@Bean</code>类型<code>Servlet</code>或 <code>ServletRegistrationBean</code>每个servlet ，Spring Boot会将它们透明地注册到容器中。因为servlet是以这种方式注册的，所以可以将它们映射到<code>DispatcherServlet</code>不调用它的子上下文。</p><p>配置<code>DispatcherServlet</code>你自己是不寻常的，但如果你真的需要这样做，还必须提供一种 <code>@Bean</code>类型<code>DispatcherServletPath</code>来提供自定义的路径<code>DispatcherServlet</code>。</p><h2 id="关闭默认MVC配置"><a href="#关闭默认MVC配置" class="headerlink" title="关闭默认MVC配置"></a>关闭默认MVC配置</h2><p>完全控制MVC配置的最简单方法是为您自己 <code>@Configuration</code>提供<code>@EnableWebMvc</code>注释。这样做会将所有MVC配置留在您的手中。</p><h2 id="自定义ViewResolvers"><a href="#自定义ViewResolvers" class="headerlink" title="自定义ViewResolvers"></a>自定义ViewResolvers</h2><p>A<code>ViewResolver</code>是Spring MVC的一个核心组件，将视图名称转换 <code>@Controller</code>为实际<code>View</code>实现。请注意，<code>ViewResolvers</code>主要用于UI应用程序，而不是REST样式的服务（<code>View</code>不用于呈现 <code>@ResponseBody</code>）。有许多实现<code>ViewResolver</code>可供选择，而Spring本身并不反对你应该使用哪些实现。另一方面，Spring Boot会为您安装一个或两个，具体取决于它在类路径和应用程序上下文中找到的内容。它<code>DispatcherServlet</code>使用它在应用程序上下文中找到的所有解析器，依次尝试每个解析器直到获得结果，因此，如果添加自己的解析器，则必须知道顺序以及添加解析器的位置。</p><p><code>WebMvcAutoConfiguration</code>在<code>ViewResolvers</code>您的上下文中添加以下内容：</p><ul><li>一个<code>InternalResourceViewResolver</code>名为’defaultViewResolver’。这个可以通过使用<code>DefaultServlet</code>（包括静态资源和JSP页面，如果您使用它们）来查找可以呈现的物理资源。它将前缀和后缀应用于视图名称，然后在servlet上下文中查找具有该路径的物理资源（默认值为空，但可通过<code>spring.mvc.view.prefix</code>和访问外部配置 <code>spring.mvc.view.suffix</code>）。您可以通过提供相同类型的bean来覆盖它。</li><li>一个<code>BeanNameViewResolver</code>名为’beanNameViewResolver’。这是视图解析器链的一个有用成员，并获取与<code>View</code>正在解析的名称相同的任何bean 。没有必要覆盖或替换它。</li><li>一个<code>ContentNegotiatingViewResolver</code>名为“ViewResolver的”只如果有添加<strong>的</strong> 实际类型的豆类<code>View</code>存在。这是一个“主”解析器，委托给所有其他人，并尝试找到客户端发送的“Accept”HTTP标头的匹配项。有一个有用的 <a href="https://spring.io/blog/2013/06/03/content-negotiation-using-views" target="_blank" rel="noopener">博客 <code>ContentNegotiatingViewResolver</code></a>，您可能想要学习以了解更多信息，您也可以查看源代码以获取详细信息。您可以<code>ContentNegotiatingViewResolver</code>通过定义名为“viewResolver”的bean 来关闭自动配置 。</li><li>如果你使用Thymeleaf，你也有一个<code>ThymeleafViewResolver</code>名为’thymeleafViewResolver’。它通过使用前缀和后缀包围视图名称来查找资源。前缀是<code>spring.thymeleaf.prefix</code>，后缀是 <code>spring.thymeleaf.suffix</code>。前缀和后缀的值分别默认为“classpath：/ templates /”和“.html”。您可以<code>ThymeleafViewResolver</code>通过提供相同名称的bean 来覆盖 。</li><li>如果您使用FreeMarker，您还有一个<code>FreeMarkerViewResolver</code>名为’freeMarkerViewResolver’。它<code>spring.freemarker.templateLoaderPath</code>通过用前缀和后缀包围视图名称来查找加载器路径中的资源（外部化并具有默认值’classpath：/ templates /‘）。前缀外部<code>spring.freemarker.prefix</code>化为，后缀外部化为 <code>spring.freemarker.suffix</code>。前缀和后缀的默认值分别为空和“.ftl”。您可以<code>FreeMarkerViewResolver</code>通过提供相同名称的bean 来覆盖。<ul><li>如果您使用Groovy模板（实际上，如果<code>groovy-templates</code>在您的类路径中），您还有一个<code>GroovyMarkupViewResolver</code>名为<code>groovyMarkupViewResolver</code>。它通过用前缀和后缀（外部化为<code>spring.groovy.template.prefix</code>和<code>spring.groovy.template.suffix</code>）包围视图名称来查找加载器路径中的资源。前缀和后缀分别具有“classpath：/ templates /”和“.tpl”的默认值。您可以<code>GroovyMarkupViewResolver</code>通过提供相同名称的bean 来覆盖。</li></ul></li></ul><p>有关更多详细信息，请参阅以下部分：</p><ul><li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java" target="_blank" rel="noopener"><code>WebMvcAutoConfiguration</code></a></li><li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java" target="_blank" rel="noopener"><code>ThymeleafAutoConfiguration</code></a></li><li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java" target="_blank" rel="noopener"><code>FreeMarkerAutoConfiguration</code></a></li><li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java" target="_blank" rel="noopener"><code>GroovyTemplateAutoConfiguration</code></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rest </tag>
            
            <tag> spring </tag>
            
            <tag> mvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-嵌入式Web服务器</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E5%B5%8C%E5%85%A5%E5%BC%8FWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E5%B5%8C%E5%85%A5%E5%BC%8FWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式Web服务器"><a href="#嵌入式Web服务器" class="headerlink" title="嵌入式Web服务器"></a>嵌入式Web服务器</h1><p>每个Spring Boot Web应用程序都包含一个嵌入式Web服务器。此功能会导致许多操作方法问题，包括如何更改嵌入式服务器以及如何配置嵌入式服务器。本节回答了这些问题。</p><h2 id="使用其他Web服务器"><a href="#使用其他Web服务器" class="headerlink" title="使用其他Web服务器"></a>使用其他Web服务器</h2><p>许多Spring Boot启动器都包含默认的嵌入式容器。</p><ul><li>对于servlet堆栈应用程序，<code>spring-boot-starter-web</code>包括Tomcat <code>spring-boot-starter-tomcat</code>，但您可以使用<code>spring-boot-starter-jetty</code>或<code>spring-boot-starter-undertow</code>替代。</li><li>对于反应栈的应用，<code>spring-boot-starter-webflux</code>包括反应堆的Netty通过包括<code>spring-boot-starter-reactor-netty</code>，但你可以使用<code>spring-boot-starter-tomcat</code>， <code>spring-boot-starter-jetty</code>或<code>spring-boot-starter-undertow</code>代替。</li></ul><p>切换到其他HTTP服务器时，除了包含所需的依赖项外，还需要排除默认依赖项。Spring Boot为HTTP服务器提供单独的启动程序，以帮助使此过程尽可能简单。</p><p>以下Maven示例显示如何排除Tomcat并为Spring MVC包含Jetty：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-api.version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">servlet-api.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 排除Tomcat依赖项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用Jetty --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Servlet API的版本已被覆盖，因为与Tomcat 9和Undertow 2.0不同，Jetty 9.4不支持Servlet 4.0。</p></blockquote><p>以下Gradle示例显示如何排除Netty并包含Spring WebFlux的Undertow：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line"><span class="comment">//排除Reactor Netty</span></span><br><span class="line"><span class="keyword">compile</span>.<span class="keyword">exclude</span> module: <span class="string">'spring-boot-starter-reactor-netty'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"><span class="keyword">compile</span> <span class="string">'org.springframework.boot:spring-boot-starter-webflux'</span></span><br><span class="line"><span class="comment">//使用Undertow</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'org.springframework.boot:spring-boot-starter-undertow'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>spring-boot-starter-reactor-netty</code>需要使用<code>WebClient</code>该类，因此即使您需要包含不同的HTTP服务器，也可能需要依赖Netty。</p></blockquote><h2 id="禁用Web服务器"><a href="#禁用Web服务器" class="headerlink" title="禁用Web服务器"></a>禁用Web服务器</h2><p>如果您的类路径包含启动Web服务器所需的位，Spring Boot将自动启动它。要禁用此行为，请<code>WebApplicationType</code>在您的配置中进行配置<code>application.properties</code>，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.main.web-application-type=none</span><br></pre></td></tr></table></figure><h2 id="更改HTTP端口"><a href="#更改HTTP端口" class="headerlink" title="更改HTTP端口"></a>更改HTTP端口</h2><p>在独立应用程序中，主HTTP端口默认为<code>8080</code>但可以设置 <code>server.port</code>（例如，<code>application.properties</code>作为System属性或作为System属性）。由于轻松绑定<code>Environment</code>值，您还可以使用<code>SERVER_PORT</code>（例如，作为OS环境变量）。</p><p>要完全关闭HTTP端点但仍然创建一个<code>WebApplicationContext</code>，请使用<code>server.port=-1</code>。（这样做有时对测试很有用。）</p><p>有关更多详细信息，请参阅“ Spring Boot功能”部分中的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-customizing-embedded-containers" target="_blank" rel="noopener">第29.4.4节”“自定义嵌入式Servlet容器”</a>或 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java" target="_blank" rel="noopener"><code>ServerProperties</code></a>源代码。</p><h2 id="使用随机未分配的HTTP端口"><a href="#使用随机未分配的HTTP端口" class="headerlink" title="使用随机未分配的HTTP端口"></a>使用随机未分配的HTTP端口</h2><p>要扫描一个空闲端口（使用OS本机来防止冲突），请使用<code>server.port=0</code>。</p><h2 id="在运行时发现HTTP端口"><a href="#在运行时发现HTTP端口" class="headerlink" title="在运行时发现HTTP端口"></a>在运行时发现HTTP端口</h2><p>您可以从日志输出或<code>ServletWebServerApplicationContext</code>通过其输出访问服务器正在运行的端口 <code>WebServer</code>。获得它并确保它已被初始化的最佳方法是添加一个<code>@Bean</code>类型， <code>ApplicationListener&lt;ServletWebServerInitializedEvent&gt;</code>并在发布时将容器拉出事件。</p><p>使用的测试<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>还可以使用<code>@LocalServerPort</code>注释将实际端口注入字段，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment=WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebIntegrationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ServletWebServerApplicationContext server;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LocalServerPort</span></span><br><span class="line"><span class="keyword">int</span> port;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@LocalServerPort</code>是一个元注释<code>@Value(&quot;${local.server.port}&quot;)</code>。不要尝试在常规应用程序中注入端口。正如我们刚刚看到的那样，只有在容器初始化之后才设置该值。与测试相反，应用程序代码回调会尽早处理（在值实际可用之前）。</p></blockquote><h2 id="启用HTTP响应压缩"><a href="#启用HTTP响应压缩" class="headerlink" title="启用HTTP响应压缩"></a>启用HTTP响应压缩</h2><p>Jetty，Tomcat和Undertow支持HTTP响应压缩。它可以启用<code>application.properties</code>，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.compression.enabled=true</span><br></pre></td></tr></table></figure><p>默认情况下，响应必须至少为2048字节，才能执行压缩。您可以通过设置<code>server.compression.min-response-size</code>属性来配置此行为 。</p><p>默认情况下，只有在内容类型为以下内容之一时才会压缩响应：</p><ul><li><code>text/html</code></li><li><code>text/xml</code></li><li><code>text/plain</code></li><li><code>text/css</code></li><li><code>text/javascript</code></li><li><code>application/javascript</code></li><li><code>application/json</code></li><li><code>application/xml</code></li></ul><p>您可以通过设置<code>server.compression.mime-types</code>属性来配置此行为。</p><h2 id="配置SSL"><a href="#配置SSL" class="headerlink" title="配置SSL"></a>配置SSL</h2><p>可以通过设置各种<code>server.ssl.*</code>属性以声明方式配置SSL ，通常在<code>application.properties</code>或中<code>application.yml</code>。以下示例显示了在以下位置设置SSL属性<code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.port=8443</span><br><span class="line">server.ssl.key-store=classpath:keystore.jks</span><br><span class="line">server.ssl.key-store-password=secret</span><br><span class="line">server.ssl.key-password=another-secret</span><br></pre></td></tr></table></figure><p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/server/Ssl.java" target="_blank" rel="noopener"><code>Ssl</code></a>所有支持的属性的详细信息，请参阅。</p><p>使用上述示例之类的配置意味着应用程序不再支持端口8080上的普通HTTP连接器.Spring Boot不支持HTTP连接器和HTTPS连接器的配置<code>application.properties</code>。如果要同时使用两者，则需要以编程方式配置其中一个。我们建议使用 <code>application.properties</code>配置HTTPS，因为HTTP连接器更容易以编程方式配置。有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/spring-boot-sample-tomcat-multi-connectors" target="_blank" rel="noopener"><code>spring-boot-sample-tomcat-multi-connectors</code></a> 示例，请参阅 示例项目。</p><h2 id="配置HTTP-2"><a href="#配置HTTP-2" class="headerlink" title="配置HTTP / 2"></a>配置HTTP / 2</h2><p>您可以使用<code>server.http2.enabled</code>配置属性在Spring Boot应用程序中启用HTTP / 2支持 。此支持取决于所选的Web服务器和应用程序环境，因为JDK8不支持该协议。</p><blockquote><p>Spring Boot不支持<code>h2c</code>HTTP / 2协议的明文版本。因此，您必须先<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-ssl" target="_blank" rel="noopener">配置SSL</a>。</p></blockquote><h3 id="Undertow的HTTP-2"><a href="#Undertow的HTTP-2" class="headerlink" title="Undertow的HTTP / 2"></a>Undertow的HTTP / 2</h3><p>从Undertow 1.4.0+开始，支持HTTP / 2，对JDK8没有任何额外要求。</p><h3 id="Jetty的HTTP-2"><a href="#Jetty的HTTP-2" class="headerlink" title="Jetty的HTTP / 2"></a>Jetty的HTTP / 2</h3><p>从Jetty 9.4.8开始，<a href="https://www.conscrypt.org/" target="_blank" rel="noopener">Conscrypt库</a>也支持HTTP / 2 。要启用该支持，您的应用程序需要有两个额外的依赖项：<code>org.eclipse.jetty:jetty-alpn-conscrypt-server</code>和<code>org.eclipse.jetty.http2:http2-server</code>。</p><h3 id="Tomcat的HTTP-2"><a href="#Tomcat的HTTP-2" class="headerlink" title="Tomcat的HTTP / 2"></a>Tomcat的HTTP / 2</h3><p>Spring Boot默认使用Tomcat 9.0.x，它在使用JDK 9或更高版本时支持HTTP / 2开箱即用。或者，如果<code>libtcnative</code> 库及其依赖项安装在主机操作系统上，则可以在JDK 8上使用HTTP / 2 。</p><p>必须使库文件夹（如果尚未可用）到JVM库路径。您可以使用JVM参数来完成此操作 <code>-Djava.library.path=/usr/local/opt/tomcat-native/lib</code>。有关<a href="https://tomcat.apache.org/tomcat-9.0-doc/apr.html" target="_blank" rel="noopener">Tomcat官方文档的</a>更多 <a href="https://tomcat.apache.org/tomcat-9.0-doc/apr.html" target="_blank" rel="noopener">信息</a>。</p><p>在没有该本机支持的情况下在JDK 8上启动Tomcat 9.0.x会记录以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 8787 --- [           main] o.a.coyote.http11.Http11NioProtocol      : The upgrade handler [org.apache.coyote.http2.Http2Protocol] for [h2] only supports upgrade via ALPN but has beenconfigured for the ["https-jsse-nio-8443"] connector that does not support ALPN.</span><br></pre></td></tr></table></figure><p>此错误不是致命错误，应用程序仍以HTTP / 1.1 SSL支持启动。</p><h3 id="Reactor-Netty的HTTP-2"><a href="#Reactor-Netty的HTTP-2" class="headerlink" title="Reactor Netty的HTTP / 2"></a>Reactor Netty的HTTP / 2</h3><p>在<code>spring-boot-webflux-starter</code>默认情况下，反应堆的Netty作为服务器使用。可以使用JDK 9或更高版本的JDK支持为Reactor Netty配置HTTP / 2。对于JDK 8环境或最佳运行时性能，此服务器还支持具有本机库的HTTP / 2。要启用它，您的应用程序需要具有其他依赖项。</p><p>Spring Boot管理<code>io.netty:netty-tcnative-boringssl-static</code>“超级jar” 的版本 ，包含所有平台的本机库。开发人员可以选择使用分类器仅导入所需的依赖项（请参阅<a href="http://netty.io/wiki/forked-tomcat-native.html" target="_blank" rel="noopener">Netty官方文档</a>）。</p><h2 id="配置Web服务器"><a href="#配置Web服务器" class="headerlink" title="配置Web服务器"></a>配置Web服务器</h2><p>通常，您应首先考虑使用众多可用配置键中的一个，并通过在您的<code>application.properties</code>（ <code>application.yml</code>或环境等）中添加新条目来自定义您的Web服务器，请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-discover-build-in-options-for-external-properties" target="_blank" rel="noopener">第77.8节”，“发现外部属性的内置选项”</a> “） 。该<code>server.*</code> 命名空间是非常有用的在这里，它包括命名空间一样<code>server.tomcat.*</code>，<code>server.jetty.*</code>和其他人，了解特定服务器的功能。请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">附录A，<em>常见应用程序属性</em></a>列表。</p><p>前面的部分介绍了许多常见用例，例如压缩，SSL或HTTP / 2。但是，如果您的用例不存在配置密钥，则应该查看 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/web/server/WebServerFactoryCustomizer.html" target="_blank" rel="noopener"><code>WebServerFactoryCustomizer</code></a>。您可以声明这样的组件并获得与您选择的服务器工厂相关的访问权限：您应该为所选服务器（Tomcat，Jetty，Reactor Netty，Undertow）和所选Web堆栈（Servlet或Reactive）选择变体。</p><p>以下示例适用于具有<code>spring-boot-starter-web</code>（Servlet堆栈）的Tomcat ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTomcatWebServerCustomizer</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">TomcatServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(TomcatServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// customize the factory here</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外Spring Boot提供：</p><table><thead><tr><th style="text-align:center">服务器</th><th style="text-align:center">Servlet Stack</th><th style="text-align:center">Reactive Stack</th></tr></thead><tbody><tr><td style="text-align:center">Tomcat的</td><td style="text-align:center"><code>TomcatServletWebServerFactory</code></td><td style="text-align:center"><code>TomcatReactiveWebServerFactory</code></td></tr><tr><td style="text-align:center">码头</td><td style="text-align:center"><code>JettyServletWebServerFactory</code></td><td style="text-align:center"><code>JettyReactiveWebServerFactory</code></td></tr><tr><td style="text-align:center">暗潮</td><td style="text-align:center"><code>UndertowServletWebServerFactory</code></td><td style="text-align:center"><code>UndertowReactiveWebServerFactory</code></td></tr><tr><td style="text-align:center">反应堆</td><td style="text-align:center">N / A</td><td style="text-align:center"><code>NettyReactiveWebServerFactory</code></td></tr></tbody></table><p>一旦您有权访问a <code>WebServerFactory</code>，您通常可以向其添加定制器以配置特定部件，例如连接器，服务器资源或服务器本身 - 所有这些都使用特定于服务器的API。</p><p>作为最后的手段，您还可以声明自己的<code>WebServerFactory</code>组件，它将覆盖Spring Boot提供的组件。在这种情况下，您不能再依赖<code>server</code>命名空间中的配置属性。</p><h2 id="向应用程序添加Servlet，Filter或Listener"><a href="#向应用程序添加Servlet，Filter或Listener" class="headerlink" title="向应用程序添加Servlet，Filter或Listener"></a>向应用程序添加Servlet，Filter或Listener</h2><p>在servlet堆栈应用程序中，即使用<code>spring-boot-starter-web</code>，有两种方法可以向应用程序添加<code>Servlet</code>，<code>Filter</code>和<code>ServletContextListener</code>，以及Servlet API支持的其他侦听器：</p><ul><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-add-a-servlet-filter-or-listener-as-spring-bean" target="_blank" rel="noopener">部分78.10.1，“使用Spring Bean添加Servlet，过滤器或监听器”</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-add-a-servlet-filter-or-listener-using-scanning" target="_blank" rel="noopener">部分78.10.2，“使用类路径扫描添加Servlet，过滤器和监听器”</a></li></ul><h3 id="使用Spring-Bean添加"><a href="#使用Spring-Bean添加" class="headerlink" title="使用Spring Bean添加"></a>使用Spring Bean添加</h3><p>要添加<code>Servlet</code>，<code>Filter</code>或servlet <code>*Listener</code>使用的Spring bean，你必须提供一个<code>@Bean</code>它的定义。当您想要注入配置或依赖项时，这样做非常有用。但是，您必须非常小心，它们不会导致太多其他bean的初始化，因为它们必须在应用程序生命周期的早期安装在容器中。（例如，让它们依赖于您的<code>DataSource</code>或JPA配置并不是一个好主意。）您可以通过在首次使用而不是初始化时懒惰地初始化bean来解决此类限制。</p><p>在的情况下<code>Filters</code>和<code>Servlets</code>，还可以通过添加添加映射和初始化参数<code>FilterRegistrationBean</code>或<code>ServletRegistrationBean</code>代替或除了下面的部件。</p><blockquote><p>如果<code>dispatcherType</code>在过滤器注册中指定了no ，<code>REQUEST</code>则使用。这与Servlet规范的默认调度程序类型一致。</p></blockquote><p>像任何其他Spring bean一样，您可以定义Servlet过滤器bean的顺序; 请务必检查“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-embedded-container-servlets-filters-listeners-beans" target="_blank" rel="noopener">名为”将Servlet，过滤器和监听器注册为Spring Beans</a> “部分。</p><h4 id="禁用Servlet或过滤器的注册"><a href="#禁用Servlet或过滤器的注册" class="headerlink" title="禁用Servlet或过滤器的注册"></a>禁用Servlet或过滤器的注册</h4><p>正如<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-add-a-servlet-filter-or-listener-as-spring-bean" target="_blank" rel="noopener">前面所述</a>，任何 <code>Servlet</code>或<code>Filter</code>豆与servlet容器自动注册。要禁用特定<code>Filter</code>或<code>Servlet</code>bean的注册，请为其创建注册Bean并将其标记为已禁用，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">registration</span><span class="params">(MyFilter filter)</span> </span>&#123;</span><br><span class="line">FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean(filter);</span><br><span class="line">registration.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用类路径扫描添加"><a href="#使用类路径扫描添加" class="headerlink" title="使用类路径扫描添加"></a>使用类路径扫描添加</h3><p><code>@WebServlet</code>，<code>@WebFilter</code>和带<code>@WebListener</code>注释的类可以通过使用一个<code>@Configuration</code>类注释<code>@ServletComponentScan</code>并指定包含要注册的组件的包来自动注册嵌入式servlet容器。默认情况下，<code>@ServletComponentScan</code>从带注释的类的包中进行扫描。</p><h2 id="配置访问日志记录"><a href="#配置访问日志记录" class="headerlink" title="配置访问日志记录"></a>配置访问日志记录</h2><p>以通过各自的命名空间为Tomcat，Undertow和Jetty配置访问日志。</p><p>例如，以下设置使用<a href="https://tomcat.apache.org/tomcat-8.5-doc/config/valve.html#Access_Logging" target="_blank" rel="noopener">自定义模式</a>在Tomcat上记录访问权限 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.basedir=my-tomcat</span><br><span class="line">server.tomcat.accesslog.enabled=true</span><br><span class="line">server.tomcat.accesslog.pattern=%t %a &quot;%r&quot; %s (%D ms)</span><br></pre></td></tr></table></figure><p>日志存储在<code>logs</code>相对于应用程序工作目录的目录中。您可以通过设置<code>server.undertow.accesslog.directory</code>属性来自定义此位置 。</p><p>最后，Jetty的访问日志记录也可以配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.jetty.accesslog.enabled=true</span><br><span class="line">server.jetty.accesslog.filename=/var/log/jetty-access.log</span><br></pre></td></tr></table></figure><p>默认情况下，日志会重定向到<code>System.err</code>。有关更多详细信息，请参阅 <a href="https://www.eclipse.org/jetty/documentation/9.4.x/configuring-jetty-request-logs.html" target="_blank" rel="noopener">Jetty文档</a>。</p><h2 id="在前端代理服务器后面运行"><a href="#在前端代理服务器后面运行" class="headerlink" title="在前端代理服务器后面运行"></a>在前端代理服务器后面运行</h2><p>您的应用程序可能需要发送<code>302</code>重定向或使用绝对链接呈现内容。在代理后面运行时，调用者需要指向代理的链接，而不是托管应用程序的计算机的物理地址。通常，这种情况是通过与代理的合同来处理的，代理会添加标题以告诉后端如何构建自己的链接。</p><p>如果代理添加了常规<code>X-Forwarded-For</code>和<code>X-Forwarded-Proto</code>头文件（大多数代理服务器都这样做），则应该正确呈现绝对链接，前提<code>server.use-forward-headers</code>是<code>true</code>在您的中设置<code>application.properties</code>。</p><blockquote><p>如果您的应用程序在Cloud Foundry或Heroku中运行，则该 <code>server.use-forward-headers</code>属性默认为<code>true</code>。在所有其他情况下，默认为<code>false</code>。</p></blockquote><h3 id="自定义Tomcat的代理配置"><a href="#自定义Tomcat的代理配置" class="headerlink" title="自定义Tomcat的代理配置"></a>自定义Tomcat的代理配置</h3><p>如果使用Tomcat，还可以配置用于携带“转发”信息的标头名称，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.remote-ip-header=x-your-remote-ip-header</span><br><span class="line">server.tomcat.protocol-header=x-your-protocol-header</span><br></pre></td></tr></table></figure><p>Tomcat还配置了一个默认的正则表达式，该表达式匹配要信任的内部代理。默认情况下，IP地址中<code>10/8</code>，<code>192.168/16</code>， <code>169.254/16</code>和<code>127/8</code>是值得信赖的。您可以通过添加条目来自定义阀门的配置<code>application.properties</code>，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.tomcat.internal-proxies=192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;</span><br></pre></td></tr></table></figure><blockquote><p>仅当使用属性文件进行配置时，才需要双反斜杠。如果使用YAML，则单个反斜杠就足够了，并且值等于前面示例中显示的值<code>192\.168\.\d{1,3}\.\d{1,3}</code>。</p></blockquote><blockquote><p>您可以通过将其设置<code>internal-proxies</code>为空来信任所有代理（但在生产中不这样做）。</p></blockquote><p>您可以<code>RemoteIpValve</code>通过关闭自动关闭（为此，设置<code>server.use-forward-headers=false</code>）并在<code>TomcatServletWebServerFactory</code>bean中添加新的阀门实例来完全控制Tomcat的配置。</p><h2 id="使用Tomcat启用多个连接器"><a href="#使用Tomcat启用多个连接器" class="headerlink" title="使用Tomcat启用多个连接器"></a>使用Tomcat启用多个连接器</h2><p>可以添加<code>org.apache.catalina.connector.Connector</code>到 <code>TomcatServletWebServerFactory</code>，这可以允许多个连接器，包括HTTP和HTTPS连接器，显示在下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletWebServerFactory <span class="title">servletContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TomcatServletWebServerFactory tomcat = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">tomcat.addAdditionalTomcatConnectors(createSslConnector());</span><br><span class="line"><span class="keyword">return</span> tomcat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connector <span class="title">createSslConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Connector connector = <span class="keyword">new</span> Connector(<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">File keystore = <span class="keyword">new</span> ClassPathResource(<span class="string">"keystore"</span>).getFile();</span><br><span class="line">File truststore = <span class="keyword">new</span> ClassPathResource(<span class="string">"keystore"</span>).getFile();</span><br><span class="line">connector.setScheme(<span class="string">"https"</span>);</span><br><span class="line">connector.setSecure(<span class="keyword">true</span>);</span><br><span class="line">connector.setPort(<span class="number">8443</span>);</span><br><span class="line">protocol.setSSLEnabled(<span class="keyword">true</span>);</span><br><span class="line">protocol.setKeystoreFile(keystore.getAbsolutePath());</span><br><span class="line">protocol.setKeystorePass(<span class="string">"changeit"</span>);</span><br><span class="line">protocol.setTruststoreFile(truststore.getAbsolutePath());</span><br><span class="line">protocol.setTruststorePass(<span class="string">"changeit"</span>);</span><br><span class="line">protocol.setKeyAlias(<span class="string">"apitester"</span>);</span><br><span class="line"><span class="keyword">return</span> connector;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"can't access keystore: ["</span> + <span class="string">"keystore"</span></span><br><span class="line">+ <span class="string">"] or truststore: ["</span> + <span class="string">"keystore"</span> + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Tomcat的LegacyCookieProcessor"><a href="#使用Tomcat的LegacyCookieProcessor" class="headerlink" title="使用Tomcat的LegacyCookieProcessor"></a>使用Tomcat的LegacyCookieProcessor</h2><p>默认情况下，Spring Boot使用的嵌入式Tomcat不支持Cookie格式的“Version 0”，因此您可能会看到以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: An invalid character [32] was present in the Cookie value</span><br></pre></td></tr></table></figure><p>如果可能的话，您应该考虑将代码更新为仅存储符合以后Cookie规范的值。但是，如果您无法更改cookie的写入方式，则可以将Tomcat配置为使用<code>LegacyCookieProcessor</code>。要切换到<code>LegacyCookieProcessor</code>，请使用<code>WebServerFactoryCustomizer</code>添加a 的 bean <code>TomcatContextCustomizer</code>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt;cookieProcessorCustomizer() &#123;</span><br><span class="line"><span class="keyword">return</span> (factory) -&gt; factory.addContextCustomizers(</span><br><span class="line">(context) -&gt; context.setCookieProcessor(<span class="keyword">new</span> LegacyCookieProcessor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Undertow启用多个侦听器"><a href="#使用Undertow启用多个侦听器" class="headerlink" title="使用Undertow启用多个侦听器"></a>使用Undertow启用多个侦听器</h2><p>一个添加<code>UndertowBuilderCustomizer</code>到<code>UndertowServletWebServerFactory</code>与收听添加到<code>Builder</code>，如图所示在下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UndertowServletWebServerFactory <span class="title">servletWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UndertowServletWebServerFactory factory = <span class="keyword">new</span> UndertowServletWebServerFactory();</span><br><span class="line">factory.addBuilderCustomizers(<span class="keyword">new</span> UndertowBuilderCustomizer() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">builder.addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-ServerEndpoint创建WebSocket端点"><a href="#使用-ServerEndpoint创建WebSocket端点" class="headerlink" title="使用@ServerEndpoint创建WebSocket端点"></a>使用@ServerEndpoint创建WebSocket端点</h2><p>如果要在使用<code>@ServerEndpoint</code>嵌入式容器的Spring Boot应用程序中使用，则必须声明一个<code>ServerEndpointExporter</code> <code>@Bean</code>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面示例中显示的<code>@ServerEndpoint</code>bean使用基础WebSocket容器注册任何带注释的bean。当部署到独立的servlet容器时，此角色由servlet容器初始化程序执行，并且<code>ServerEndpointExporter</code>不需要该 bean。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> http2 </tag>
            
            <tag> web </tag>
            
            <tag> compression </tag>
            
            <tag> ssl </tag>
            
            <tag> servlet </tag>
            
            <tag> filter </tag>
            
            <tag> listener </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-属性和配置</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E5%B1%9E%E6%80%A7%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E5%B1%9E%E6%80%A7%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="属性和配置-部分"><a href="#属性和配置-部分" class="headerlink" title="属性和配置(部分)"></a>属性和配置(部分)</h1><p>本节包括有关设置和读取属性和配置设置及其与Spring Boot应用程序交互的主题。</p><h2 id="在构建时自动展开属性"><a href="#在构建时自动展开属性" class="headerlink" title="在构建时自动展开属性"></a>在构建时自动展开属性</h2><p>您可以使用现有的构建配置自动扩展它们，而不是硬编码在项目的构建配置中也指定的某些属性。这在Maven和Gradle都是可行的。</p><h3 id="使用Maven自动扩展属性"><a href="#使用Maven自动扩展属性" class="headerlink" title="使用Maven自动扩展属性"></a>使用Maven自动扩展属性</h3><p>您可以使用资源过滤从Maven项目自动扩展属性。如果您使用<code>spring-boot-starter-parent</code>，则可以使用<code>@..@</code>占位符引用Maven“项目属性” ，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.encoding=@project.build.sourceEncoding@</span><br><span class="line">app.java.version=@java.version@</span><br></pre></td></tr></table></figure><blockquote><p>只有生产配置以这种方式过滤（换句话说，不应用过滤<code>src/test/resources</code>）。</p></blockquote><blockquote><p>如果启用该<code>addResources</code>标志，则<code>spring-boot:run</code>目标可以<code>src/main/resources</code>直接添加 到类路径（用于热重新加载）。这样做可以绕过资源过滤和此功能。相反，您可以使用<code>exec:java</code> 目标或自定义插件的配置。有关详细信息，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/maven-plugin/usage.html" target="_blank" rel="noopener">插件使用情况页面</a>。</p></blockquote><p>如果不使用起动机家长，你需要包括中引入下列元素<code>&lt;build/&gt;</code>的元素<code>pom.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>您还需要在内部包含以下元素<code>&lt;plugins/&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delimiters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delimiter</span>&gt;</span>@<span class="tag">&lt;/<span class="name">delimiter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delimiters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">useDefaultDelimiters</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useDefaultDelimiters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>useDefaultDelimiters</code>如果<code>${placeholder}</code>在配置中使用标准的Spring占位符（例如），则该属性很重要。如果该属性未设置为<code>false</code>，则可以通过构建扩展这些属性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> properties </tag>
            
            <tag> configuration </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-配置HTTP/2</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E9%85%8D%E7%BD%AEHTTP-2/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E9%85%8D%E7%BD%AEHTTP-2/</url>
      
        <content type="html"><![CDATA[<h1 id="配置HTTP-2"><a href="#配置HTTP-2" class="headerlink" title="配置HTTP / 2"></a>配置HTTP / 2</h1><p>您可以使用<code>server.http2.enabled</code>配置属性在Spring Boot应用程序中启用HTTP / 2支持 。此支持取决于所选的Web服务器和应用程序环境，因为JDK8不支持该协议。</p><blockquote><p>Spring Boot不支持<code>h2c</code>HTTP / 2协议的明文版本。因此，您必须先<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-ssl" target="_blank" rel="noopener">配置SSL</a>。</p></blockquote><h2 id="Undertow的HTTP-2"><a href="#Undertow的HTTP-2" class="headerlink" title="Undertow的HTTP / 2"></a>Undertow的HTTP / 2</h2><p>从Undertow 1.4.0+开始，支持HTTP / 2，对JDK8没有任何额外要求。</p><h2 id="Jetty的HTTP-2"><a href="#Jetty的HTTP-2" class="headerlink" title="Jetty的HTTP / 2"></a>Jetty的HTTP / 2</h2><p>从Jetty 9.4.8开始，<a href="https://www.conscrypt.org/" target="_blank" rel="noopener">Conscrypt库</a>也支持HTTP / 2 。要启用该支持，您的应用程序需要有两个额外的依赖项：</p><ul><li><p><code>org.eclipse.jetty:jetty-alpn-conscrypt-server</code></p></li><li><p><code>org.eclipse.jetty.http2:http2-server</code></p></li></ul><h2 id="Tomcat的HTTP-2"><a href="#Tomcat的HTTP-2" class="headerlink" title="Tomcat的HTTP / 2"></a>Tomcat的HTTP / 2</h2><p>Spring Boot默认使用Tomcat 9.0.x，它在使用JDK 9或更高版本时支持HTTP / 2开箱即用。或者，如果<code>libtcnative</code> 库及其依赖项安装在主机操作系统上，则可以在JDK 8上使用HTTP / 2 。</p><p>必须使库文件夹（如果尚未可用）到JVM库路径。您可以使用JVM参数来完成此操作 <code>-Djava.library.path=/usr/local/opt/tomcat-native/lib</code>。有关<a href="https://tomcat.apache.org/tomcat-9.0-doc/apr.html" target="_blank" rel="noopener">Tomcat官方文档的</a>更多 <a href="https://tomcat.apache.org/tomcat-9.0-doc/apr.html" target="_blank" rel="noopener">信息</a>。</p><p>在没有该本机支持的情况下在JDK 8上启动Tomcat 9.0.x会记录以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 8787 --- [           main] o.a.coyote.http11.Http11NioProtocol      : The upgrade handler [org.apache.coyote.http2.Http2Protocol] for [h2] only supports upgrade via ALPN but has beenconfigured for the ["https-jsse-nio-8443"] connector that does not support ALPN.</span><br></pre></td></tr></table></figure><p>此错误不是致命错误，应用程序仍以HTTP / 1.1 SSL支持启动。</p><h2 id="Reactor-Netty的HTTP-2"><a href="#Reactor-Netty的HTTP-2" class="headerlink" title="Reactor Netty的HTTP / 2"></a>Reactor Netty的HTTP / 2</h2><p>在<code>spring-boot-webflux-starter</code>默认情况下，反应堆的Netty作为服务器使用。可以使用JDK 9或更高版本的JDK支持为Reactor Netty配置HTTP / 2。对于JDK 8环境或最佳运行时性能，此服务器还支持具有本机库的HTTP / 2。要启用它，您的应用程序需要具有其他依赖项。</p><p>Spring Boot管理<code>io.netty:netty-tcnative-boringssl-static</code>“超级jar” 的版本 ，包含所有平台的本机库。开发人员可以选择使用分类器仅导入所需的依赖项（请参阅<a href="http://netty.io/wiki/forked-tomcat-native.html" target="_blank" rel="noopener">Netty官方文档</a>）。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-通过HTTP进行监控和管理</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E9%80%9A%E8%BF%87HTTP%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%E5%92%8C%E7%AE%A1%E7%90%86/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E9%80%9A%E8%BF%87HTTP%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%E5%92%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="通过HTTP进行监控和管理"><a href="#通过HTTP进行监控和管理" class="headerlink" title="通过HTTP进行监控和管理"></a>通过HTTP进行监控和管理</h1><p>如果您正在开发Web应用程序，则Spring Boot Actuator会自动配置所有已启用的端点以通过HTTP公开。默认约定是使用<code>id</code>前缀<code>/actuator</code>为URL路径的端点。例如，<code>health</code>暴露为<code>/actuator/health</code>。提示：Spring MVC，Spring WebFlux和Jersey本身支持Actuator。</p><h2 id="自定义管理端点路径"><a href="#自定义管理端点路径" class="headerlink" title="自定义管理端点路径"></a>自定义管理端点路径</h2><p>有时，定制管理端点的前缀很有用。例如，您的应用程序可能已<code>/actuator</code>用于其他目的。您可以使用该<code>management.endpoints.web.base-path</code>属性更改管理端点的前缀，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.base-path=/manage</span><br></pre></td></tr></table></figure><p>上面的<code>application.properties</code>示例将端点更改 <code>/actuator/{id}</code>为<code>/manage/{id}</code>（例如<code>/manage/info</code>）。</p><blockquote><p>除非管理端口已经被配置为 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-customizing-management-server-port" target="_blank" rel="noopener">通过使用不同的HTTP端口暴露端点</a>，<code>management.endpoints.web.base-path</code>相对于<code>server.servlet.context-path</code>。如果<code>management.server.port</code>配置， <code>management.endpoints.web.base-path</code>则相对于<code>management.server.servlet.context-path</code>。</p></blockquote><p>如果要将端点映射到其他路径，可以使用该 <code>management.endpoints.web.path-mapping</code>属性。</p><p>以下示例重新映射<code>/actuator/health</code>到<code>/healthcheck</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.base-path=/</span><br><span class="line">management.endpoints.web.path-mapping.health=healthcheck</span><br></pre></td></tr></table></figure><h2 id="自定义Management-Server端口"><a href="#自定义Management-Server端口" class="headerlink" title="自定义Management Server端口"></a>自定义Management Server端口</h2><p>使用默认HTTP端口公开管理端点是基于云的部署的明智选择。但是，如果您的应用程序在您自己的数据中心内运行，您可能更喜欢使用不同的HTTP端口公开端点。</p><p>您可以设置该<code>management.server.port</code>属性以更改HTTP端口，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.server.port=8081</span><br></pre></td></tr></table></figure><h2 id="配置管理特定的SSL"><a href="#配置管理特定的SSL" class="headerlink" title="配置管理特定的SSL"></a>配置管理特定的SSL</h2><p>配置为使用自定义端口时，还可以使用各种<code>management.server.ssl.*</code>属性为管理服务器配置自己的SSL 。例如，这样做可以在主应用程序使用HTTPS时通过HTTP使管理服务器可用，如以下属性设置所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8443</span><br><span class="line">server.ssl.enabled=true</span><br><span class="line">server.ssl.key-store=classpath:store.jks</span><br><span class="line">server.ssl.key-password=secret</span><br><span class="line">management.server.port=8080</span><br><span class="line">management.server.ssl.enabled=false</span><br></pre></td></tr></table></figure><p>或者，主服务器和管理服务器都可以使用SSL但具有不同的密钥库，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.port=8443</span><br><span class="line">server.ssl.enabled=true</span><br><span class="line">server.ssl.key-store=classpath:main.jks</span><br><span class="line">server.ssl.key-password=secret</span><br><span class="line">management.server.port=8080</span><br><span class="line">management.server.ssl.enabled=true</span><br><span class="line">management.server.ssl.key-store=classpath:management.jks</span><br><span class="line">management.server.ssl.key-password=secret</span><br></pre></td></tr></table></figure><h2 id="自定义管理服务器地址"><a href="#自定义管理服务器地址" class="headerlink" title="自定义管理服务器地址"></a>自定义管理服务器地址</h2><p>您可以通过设置<code>management.server.address</code>属性来自定义管理端点可用的地址。如果您只想在内部或面向操作的网络上侦听或仅侦听来自的连接，那么这样做会非常有用 <code>localhost</code>。</p><blockquote><p>仅当端口与主服务器端口不同时，才能侦听不同的地址。</p></blockquote><p>以下示例<code>application.properties</code>不允许远程管理连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.server.port=8081</span><br><span class="line">management.server.address=127.0.0.1</span><br></pre></td></tr></table></figure><h2 id="禁用HTTP端点"><a href="#禁用HTTP端点" class="headerlink" title="禁用HTTP端点"></a>禁用HTTP端点</h2><p>如果您不想通过HTTP公开端点，可以将管理端口设置为 <code>-1</code>，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.server.port=-1</span><br></pre></td></tr></table></figure><p>这也可以使用<code>management.endpoints.web.exposure.exclude</code>属性来实现，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.exclude=*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-endpoints</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-endpoints/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-endpoints/</url>
      
        <content type="html"><![CDATA[<h1 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h1><p>通过执行器端点，您可以监控应用程序并与之交互。Spring Boot包含许多内置端点，允许您添加自己的端点。例如， <code>health</code>端点提供基本的应用程序健康信息。</p><p>可以<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-enabling-endpoints" target="_blank" rel="noopener">启用或禁用</a>每个端点。它控制是否创建端点并且其bean存在于应用程序上下文中。要进行远程访问，还必须<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints" target="_blank" rel="noopener">通过JMX或HTTP公开</a>端点 。大多数应用程序选择HTTP，其中端点的ID以及前缀<code>/actuator</code> 映射到URL。例如，默认情况下，<code>health</code>端点映射到 <code>/actuator/health</code>。</p><p>可以使用以下与技术无关的端点：</p><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">描述</th><th style="text-align:center">默认情况下启用</th></tr></thead><tbody><tr><td style="text-align:center"><code>auditevents</code></td><td style="text-align:center">公开当前应用程序的审核事件信息。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>beans</code></td><td style="text-align:center">显示应用程序中所有Spring bean的完整列表。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>caches</code></td><td style="text-align:center">暴露可用的缓存。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>conditions</code></td><td style="text-align:center">显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>configprops</code></td><td style="text-align:center">显示所有的整理列表<code>@ConfigurationProperties</code>。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>env</code></td><td style="text-align:center">露出Spring的属性<code>ConfigurableEnvironment</code>。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>flyway</code></td><td style="text-align:center">显示已应用的任何Flyway数据库迁移。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>health</code></td><td style="text-align:center">显示应用健康信息。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>httptrace</code></td><td style="text-align:center">显示HTTP跟踪信息（默认情况下，最后100个HTTP请求 - 响应交换）。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>info</code></td><td style="text-align:center">显示任意应用信息。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>integrationgraph</code></td><td style="text-align:center">显示Spring Integration图。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>loggers</code></td><td style="text-align:center">显示和修改应用程序中记录器的配置。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>liquibase</code></td><td style="text-align:center">显示已应用的任何Liquibase数据库迁移。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>metrics</code></td><td style="text-align:center">显示当前应用程序的“指标”信息。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>mappings</code></td><td style="text-align:center">显示所有<code>@RequestMapping</code>路径的整理列表。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>scheduledtasks</code></td><td style="text-align:center">显示应用程序中的计划任务。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>sessions</code></td><td style="text-align:center">允许从Spring Session支持的会话存储中检索和删除用户会话。使用Spring Session对响应式Web应用程序的支持时不可用。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>shutdown</code></td><td style="text-align:center">允许应用程序正常关闭。</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>threaddump</code></td><td style="text-align:center">执行线程转储。</td><td style="text-align:center">是</td></tr></tbody></table><p>如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">描述</th><th style="text-align:center">默认情况下启用</th></tr></thead><tbody><tr><td style="text-align:center"><code>heapdump</code></td><td style="text-align:center">返回<code>hprof</code>堆转储文件。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>jolokia</code></td><td style="text-align:center">通过HTTP公开JMX bean（当Jolokia在类路径上时，不适用于WebFlux）。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>logfile</code></td><td style="text-align:center">返回日志文件的内容（如果已设置<code>logging.file</code>或<code>logging.path</code>属性）。支持使用HTTP <code>Range</code>标头检索部分日志文件的内容。</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>prometheus</code></td><td style="text-align:center">以可以由Prometheus服务器抓取的格式公开指标。</td><td style="text-align:center">是</td></tr></tbody></table><p>要了解有关Actuator端点及其请求和响应格式的更多信息，请参阅单独的API文档（<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//html" target="_blank" rel="noopener">HTML</a>或 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf" target="_blank" rel="noopener">PDF</a>）。</p><h2 id="启用端点"><a href="#启用端点" class="headerlink" title="启用端点"></a>启用端点</h2><p>默认情况下，<code>shutdown</code>启用除除以外的所有端点。要配置端点的启用，请使用其<code>management.endpoint.&lt;id&gt;.enabled</code>属性。以下示例启用<code>shutdown</code>端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoint.shutdown.enabled=true</span><br></pre></td></tr></table></figure><p>如果您希望端点启用是选择加入而不是选择退出，请将该<code>management.endpoints.enabled-by-default</code>属性设置 为<code>false</code>并使用各个端点 <code>enabled</code>属性重新加入。以下示例启用<code>info</code>端点并禁用所有其他端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.enabled-by-default=false</span><br><span class="line">management.endpoint.info.enabled=true</span><br></pre></td></tr></table></figure><blockquote><p>已完全从应用程序上下文中删除已禁用的端点。如果只想更改端点所暴露的技术，请改用 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints" target="_blank" rel="noopener"><code>include</code>和<code>exclude</code>属性</a> 。</p></blockquote><h2 id="公开端点"><a href="#公开端点" class="headerlink" title="公开端点"></a>公开端点</h2><p>由于端点可能包含敏感信息，因此应仔细考虑何时公开它们。下表显示了内置端点的默认曝光：</p><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">JMX</th><th style="text-align:center">WEB</th></tr></thead><tbody><tr><td style="text-align:center"><code>auditevents</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>beans</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>caches</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>conditions</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>configprops</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>env</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>flyway</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>health</code></td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>heapdump</code></td><td style="text-align:center">N / A</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>httptrace</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>info</code></td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center"><code>integrationgraph</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>jolokia</code></td><td style="text-align:center">N / A</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>logfile</code></td><td style="text-align:center">N / A</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>loggers</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>liquibase</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>metrics</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>mappings</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>prometheus</code></td><td style="text-align:center">N / A</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>scheduledtasks</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>sessions</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>shutdown</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>threaddump</code></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr></tbody></table><p>要更改端点暴露，使用下面的特定技术<code>include</code>和 <code>exclude</code>特性：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">默认</th></tr></thead><tbody><tr><td style="text-align:center"><code>management.endpoints.jmx.exposure.exclude</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>management.endpoints.jmx.exposure.include</code></td><td style="text-align:center"><code>*</code></td></tr><tr><td style="text-align:center"><code>management.endpoints.web.exposure.exclude</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>management.endpoints.web.exposure.include</code></td><td style="text-align:center"><code>info, health</code></td></tr></tbody></table><p>该<code>include</code>属性列出了公开的端点的ID。该<code>exclude</code> 属性列出了不应公开的端点的ID。该<code>exclude</code> 属性优先于该<code>include</code>属性。无论<code>include</code>和<code>exclude</code> 性能可与端点ID列表进行配置。</p><p>例如，要停止通过JMX公开所有端点并仅显示端点<code>health</code>和 <code>info</code>端点，请使用以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.jmx.exposure.include=health,info</span><br></pre></td></tr></table></figure><p><code>*</code>可用于选择所有端点。例如，要通过HTTP公开除了<code>env</code>和<code>beans</code>端点之外的所有内容，请使用以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoints.web.exposure.exclude=env,beans</span><br></pre></td></tr></table></figure><blockquote><p><code>*</code> 在YAML中有特殊含义，因此如果要包含（或排除）所有端点，请务必添加引号，如以下示例所示：</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><blockquote><p>如果您的申请是公开的，我们强烈建议您也 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-security" target="_blank" rel="noopener">保护您的终端</a>。</p></blockquote><blockquote><p>如果要在公开端点时实现自己的策略，可以注册<code>EndpointFilter</code>bean。</p></blockquote><h2 id="保护HTTP端点"><a href="#保护HTTP端点" class="headerlink" title="保护HTTP端点"></a>保护HTTP端点</h2><p>您应该像使用任何其他敏感URL一样注意保护HTTP端点。如果存在Spring Security，则默认使用Spring Security的内容协商策略来保护端点。例如，如果您希望为HTTP端点配置自定义安全性，只允许具有特定角色的用户访问它们，Spring Boot提供了一些<code>RequestMatcher</code>可以与Spring Security结合使用的方便对象。</p><p>典型的Spring Security配置可能类似于以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActuatorSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class="line">.anyRequest().hasRole(<span class="string">"ENDPOINT_ADMIN"</span>)</span><br><span class="line">.and()</span><br><span class="line">.httpBasic();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例用于<code>EndpointRequest.toAnyEndpoint()</code>将请求与任何端点进行匹配，然后确保所有端点都具有该<code>ENDPOINT_ADMIN</code>角色。其他几种匹配方法也可用<code>EndpointRequest</code>。请参阅API文档（<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//html" target="_blank" rel="noopener">HTML</a>或 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf" target="_blank" rel="noopener">PDF</a>详细信息，）。</p><p>如果在防火墙后面部署应用程序，您可能希望无需身份验证即可访问所有执行器端点。您可以通过更改<code>management.endpoints.web.exposure.include</code>属性来执行此操作 ，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anagement.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure><p>此外，如果存在Spring Security，则需要添加自定义安全配置，以允许对端点进行未经身份验证的访问，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActuatorSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class="line">.anyRequest().permitAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置端点"><a href="#配置端点" class="headerlink" title="配置端点"></a>配置端点</h2><p>端点自动缓存对不带任何参数的读取操作的响应。要配置端点缓存响应的时间量，请使用其<code>cache.time-to-live</code>属性。以下示例将<code>beans</code>端点缓存的生存时间设置为10秒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoint.beans.cache.time-to-live=10s</span><br></pre></td></tr></table></figure><blockquote><p>前缀<code>management.endpoint.&lt;name&gt;</code>用于唯一标识正在配置的端点。</p></blockquote><blockquote><p>在进行经过身份验证的HTTP请求时，Principal会将其视为端点的输入，因此不会缓存响应。</p></blockquote><h2 id="用于执行器Web端点的超媒体"><a href="#用于执行器Web端点的超媒体" class="headerlink" title="用于执行器Web端点的超媒体"></a>用于执行器Web端点的超媒体</h2><p>添加了“发现页面”，其中包含指向所有端点的链接。<code>/actuator</code>默认情况下，“发现页面”可用。</p><p>配置自定义管理上下文路径后，“发现页面”会自动从<code>/actuator</code>管理上下文的根目录移动。例如，如果管理上下文路径是<code>/management</code>，则可以从中获取发现页面<code>/management</code>。当管理上下文路径设置为时<code>/</code>，将禁用发现页面以防止与其他映射冲突的可能性。</p><h2 id="CORS支持"><a href="#CORS支持" class="headerlink" title="CORS支持"></a>CORS支持</h2><p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank" rel="noopener">跨源资源共享</a> （CORS）是一种<a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener">W3C规范</a>，允许您以灵活的方式指定授权的跨域请求类型。如果您使用Spring MVC或Spring WebFlux，则可以配置Actuator的Web端点以支持此类方案。</p><p>默认情况下禁用CORS支持，并且仅<code>management.endpoints.web.cors.allowed-origins</code>在设置了属性后才启用CORS支持 。以下配置允许<code>GET</code>和<code>POST</code>来自<code>example.com</code>域的调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.cors.allowed-origins=http://example.com</span><br><span class="line">management.endpoints.web.cors.allowed-methods=GET,POST</span><br></pre></td></tr></table></figure><blockquote><p>有关 选项的完整列表，请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java" target="_blank" rel="noopener">CorsEndpointProperties</a>。</p></blockquote><h2 id="实现自定义端点"><a href="#实现自定义端点" class="headerlink" title="实现自定义端点"></a>实现自定义端点</h2><p>如果您添加带<code>@Bean</code>注释的<code>@Endpoint</code>注释<code>@ReadOperation</code>，通过JMX 注释的任何方法 <code>@WriteOperation</code>，或者<code>@DeleteOperation</code>通过JMX自动公开，以及在Web应用程序中也通过HTTP 添加注释。可以使用Jersey，Spring MVC或Spring WebFlux通过HTTP公开端点。</p><p>您还可以使用<code>@JmxEndpoint</code>或 编写特定于技术的端点<code>@WebEndpoint</code>。这些端点仅限于各自的技术。例如，<code>@WebEndpoint</code>仅通过HTTP而不是通过JMX公开。</p><p>您可以使用<code>@EndpointWebExtension</code>和 编写特定于技术的扩展<code>@EndpointJmxExtension</code>。通过这些注释，您可以提供特定于技术的操作来扩充现有端点。</p><p>最后，如果您需要访问特定于Web框架的功能，则可以实现Servlet或Spring <code>@Controller</code>和<code>@RestController</code>端点，但代价是它们不能通过JMX或使用不同的Web框架。</p><h3 id="接收输入"><a href="#接收输入" class="headerlink" title="接收输入"></a>接收输入</h3><p>端点上的操作通过其参数接收输入。通过Web公开时，这些参数的值取自URL的查询参数和JSON请求体。通过JMX公开时，参数将映射到MBean操作的参数。默认情况下需要参数。它们可以通过注释使它们成为可选的<a href="mailto:`@org.springframework.lang.Nullable" target="_blank" rel="noopener">`@org.springframework.lang.Nullable</a>`。</p><p>JSON请求正文中的每个根属性都可以映射到端点的参数。考虑以下JSON请求正文：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"test"</span>,</span><br><span class="line"><span class="attr">"counter"</span>: <span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以用于调用，需要一个写操作<code>String name</code>和<code>int counter</code> 参数。</p><blockquote><p>由于端点与技术无关，因此只能在方法签名中指定简单类型。特别是不支持使用定义<code>name</code>和<code>counter</code>属性的自定义类型声明单个参数 。</p></blockquote><blockquote><p>为了允许输入映射到操作方法的参数，应该编译实现端点的Java代码<code>-parameters</code>，并且应该编译实现端点的Kotlin代码<code>-java-parameters</code>。如果您使用的是Spring Boot的Gradle插件，或者您正在使用Maven和 <code>spring-boot-starter-parent</code>。</p></blockquote><h4 id="输入类型转换"><a href="#输入类型转换" class="headerlink" title="输入类型转换"></a>输入类型转换</h4><p>如有必要，传递给端点操作方法的参数将自动转换为所需类型。在调用操作方法之前，通过JMX或HTTP请求接收的输入将使用实例转换为所需类型<code>ApplicationConversionService</code>。</p><h3 id="自定义Web端点"><a href="#自定义Web端点" class="headerlink" title="自定义Web端点"></a>自定义Web端点</h3><p>操作<code>@Endpoint</code>，<code>@WebEndpoint</code>或者<code>@EndpointWebExtension</code>使用新泽西州，Spring MVC，或Spring WebFlux通过HTTP自动曝光。</p><h4 id="Web端点请求谓词"><a href="#Web端点请求谓词" class="headerlink" title="Web端点请求谓词"></a>Web端点请求谓词</h4><p>为Web暴露的端点上的每个操作自动生成请求谓词。</p><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>谓词的路径由端点的ID和Web暴露的端点的基本路径确定。默认基本路径是<code>/actuator</code>。例如，具有ID的端点<code>sessions</code>将<code>/actuator/sessions</code>用作谓词中的路径。</p><p>可以通过用操作方法的一个或多个参数注释来进一步定制路径<code>@Selector</code>。这样的参数作为路径变量添加到路径谓词中。调用端点操作时，变量的值将传递给操作方法。</p><h4 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h4><p>谓词的HTTP方法由操作类型决定，如下表所示：</p><table><thead><tr><th style="text-align:center">Operation</th><th style="text-align:center">HTTP Method</th></tr></thead><tbody><tr><td style="text-align:center"><code>@ReadOperation</code></td><td style="text-align:center"><code>GET</code></td></tr><tr><td style="text-align:center"><code>@WriteOperation</code></td><td style="text-align:center"><code>POST</code></td></tr><tr><td style="text-align:center"><code>@DeleteOperation</code></td><td style="text-align:center"><code>DELETE</code></td></tr></tbody></table><h4 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h4><p>对于使用请求主体的<code>@WriteOperation</code>（HTTP <code>POST</code>），谓词的consumemes子句是<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。对于所有其他操作，consumemes子句为空。</p><h4 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h4><p>的产生谓词子句可以由被确定<code>produces</code>的属性 <code>@DeleteOperation</code>，<code>@ReadOperation</code>和<code>@WriteOperation</code>注解。该属性是可选的。如果未使用，则自动确定produce子句。</p><p>如果操作方法返回<code>void</code>或者<code>Void</code>produce子句为空。如果操作方法返回a <code>org.springframework.core.io.Resource</code>，则generate子句为<code>application/octet-stream</code>。对于所有其他操作，produce子句是 <code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。</p><h4 id="Web端点响应状态"><a href="#Web端点响应状态" class="headerlink" title="Web端点响应状态"></a>Web端点响应状态</h4><p>端点操作的默认响应状态取决于操作类型（读取，写入或删除）以及操作返回的内容（如果有）。</p><p>A <code>@ReadOperation</code>返回一个值，响应状态为200（OK）。如果它未返回值，则响应状态将为404（未找到）。</p><p>如果a <code>@WriteOperation</code>或<code>@DeleteOperation</code>返回值，则响应状态将为200（OK）。如果它没有返回值，则响应状态将为204（无内容）。</p><p>如果在没有必需参数的情况下调用操作，或者使用无法转换为所需类型的参数，则不会调用操作方法，并且响应状态将为400（错误请求）。</p><h4 id="Web端点范围请求"><a href="#Web端点范围请求" class="headerlink" title="Web端点范围请求"></a>Web端点范围请求</h4><p>HTTP范围请求可用于请求部分HTTP资源。使用Spring MVC或Spring Web Flux时，返回<code>org.springframework.core.io.Resource</code> 自动支持范围请求的操作。</p><blockquote><p>使用Jersey时不支持范围请求。</p></blockquote><h4 id="Web端点安全"><a href="#Web端点安全" class="headerlink" title="Web端点安全"></a>Web端点安全</h4><p>Web端点或特定于Web的端点扩展上的操作可以接收当前<code>java.security.Principal</code>或 <code>org.springframework.boot.actuate.endpoint.SecurityContext</code>作为方法参数。前者通常与<code>@Nullable</code>经过身份验证和未经身份验证的用户一起使用以提供不同的行为。后者通常用于使用其<code>isUserInRole(String)</code>方法执行授权检查。</p><h3 id="Servlet端点"><a href="#Servlet端点" class="headerlink" title="Servlet端点"></a>Servlet端点</h3><p><code>Servlet</code>可以公开为通过实施与注释的一个类的端点 <code>@ServletEndpoint</code>也实现<code>Supplier&lt;EndpointServlet&gt;</code>。Servlet端点提供与Servlet容器更深层次的集成，但代价是可移植性。它们旨在用于将现有的公开<code>Servlet</code>作为端点。对于新端点，应尽可能优先使用<code>@Endpoint</code>和<code>@WebEndpoint</code>注释。</p><h3 id="控制器端点"><a href="#控制器端点" class="headerlink" title="控制器端点"></a>控制器端点</h3><p><code>@ControllerEndpoint</code>并且<code>@RestControllerEndpoint</code>可用于实现仅由Spring MVC或Spring WebFlux公开的端点。使用Spring MVC和Spring WebFlux的标准注释（例如<code>@RequestMapping</code> 和）映射方法<code>@GetMapping</code>，并将端点的ID用作路径的前缀。控制器端点提供与Spring的Web框架更深层次的集成，但代价是可移植性。的<code>@Endpoint</code>和<code>@WebEndpoint</code>注解应当优选只要有可能。</p><h2 id="健康信息"><a href="#健康信息" class="headerlink" title="健康信息"></a>健康信息</h2><p>您可以使用运行状况信息来检查正在运行的应用程序的状态。监视软件经常使用它在生产系统出现故障时提醒某人。<code>health</code>端点公开的信息取决于<code>management.endpoint.health.show-details</code>可以使用以下值之一配置的 属性：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>never</code></td><td style="text-align:center">细节永远不会显示。</td></tr><tr><td style="text-align:center"><code>when-authorized</code></td><td style="text-align:center">详细信息仅向授权用户显示。可以使用配置授权角色 <code>management.endpoint.health.roles</code>。</td></tr><tr><td style="text-align:center"><code>always</code></td><td style="text-align:center">向所有用户显示详细信息。</td></tr></tbody></table><p>默认值为<code>never</code>。当用户处于一个或多个端点的角色时，将被视为已获得授权。如果端点没有配置角色（默认值），则认为所有经过身份验证的用户都已获得授权。可以使用<code>management.endpoint.health.roles</code>属性配置角色。</p><blockquote><p>如果您已保护应用程序并希望使用<code>always</code>，则安全配置必须允许对经过身份验证和未经身份验证的用户访问运行状况终结点。</p></blockquote><p>健康信息是从a的内容中收集的 （默认情况下，所有 实例都在你的Spring中定义.Spring Boot包括一些自动配置 ，你也可以编写自己的。默认情况下，最终的系统状态是通过对状态进行排序得出的从每个 基于状态的有序列表上。在排序列表中的第一个状态用作总体运行状况。如果没有回报是已知的一个状态 ，一个是使用状态。</p><p><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicatorRegistry.java" target="_blank" rel="noopener"><code>HealthIndicatorRegistry</code></a><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java" target="_blank" rel="noopener"><code>HealthIndicator</code></a><code>ApplicationContext</code> <code>HealthIndicators</code> <code>HealthAggregator</code> <code>HealthIndicator</code> <code>HealthIndicator</code> <code>HealthAggregator</code> <code>UNKNOWN</code></p><blockquote><p>该<code>HealthIndicatorRegistry</code>可用于注册和在运行时注销卫生指标。</p></blockquote><h3 id="自动配置的HealthIndicators"><a href="#自动配置的HealthIndicators" class="headerlink" title="自动配置的HealthIndicators"></a>自动配置的HealthIndicators</h3><p><code>HealthIndicators</code>适当时，Spring Boot会自动配置以下内容：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraHealthIndicator.java" target="_blank" rel="noopener"><code>CassandraHealthIndicator</code></a></td><td style="text-align:center">检查Cassandra数据库是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseHealthIndicator.java" target="_blank" rel="noopener"><code>CouchbaseHealthIndicator</code></a></td><td style="text-align:center">检查Couchbase群集是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/system/DiskSpaceHealthIndicator.java" target="_blank" rel="noopener"><code>DiskSpaceHealthIndicator</code></a></td><td style="text-align:center">检查磁盘空间不足。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jdbc/DataSourceHealthIndicator.java" target="_blank" rel="noopener"><code>DataSourceHealthIndicator</code></a></td><td style="text-align:center">检查是否可以获得连接<code>DataSource</code>。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchHealthIndicator.java" target="_blank" rel="noopener"><code>ElasticsearchHealthIndicator</code></a></td><td style="text-align:center">检查Elasticsearch集群是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/influx/InfluxDbHealthIndicator.java" target="_blank" rel="noopener"><code>InfluxDbHealthIndicator</code></a></td><td style="text-align:center">检查InfluxDB服务器是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jms/JmsHealthIndicator.java" target="_blank" rel="noopener"><code>JmsHealthIndicator</code></a></td><td style="text-align:center">检查JMS代理是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mail/MailHealthIndicator.java" target="_blank" rel="noopener"><code>MailHealthIndicator</code></a></td><td style="text-align:center">检查邮件服务器是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoHealthIndicator.java" target="_blank" rel="noopener"><code>MongoHealthIndicator</code></a></td><td style="text-align:center">检查Mongo数据库是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jHealthIndicator.java" target="_blank" rel="noopener"><code>Neo4jHealthIndicator</code></a></td><td style="text-align:center">检查Neo4j服务器是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.java" target="_blank" rel="noopener"><code>RabbitHealthIndicator</code></a></td><td style="text-align:center">检查Rabbit服务器是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisHealthIndicator.java" target="_blank" rel="noopener"><code>RedisHealthIndicator</code></a></td><td style="text-align:center">检查Redis服务器是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/solr/SolrHealthIndicator.java" target="_blank" rel="noopener"><code>SolrHealthIndicator</code></a></td><td style="text-align:center">检查Solr服务器是否已启动。</td></tr></tbody></table><blockquote><p>您可以通过设置<code>management.health.defaults.enabled</code> 属性来禁用它们。</p></blockquote><h3 id="编写自定义HealthIndicators"><a href="#编写自定义HealthIndicators" class="headerlink" title="编写自定义HealthIndicators"></a>编写自定义HealthIndicators</h3><p>要提供自定义运行状况信息，可以注册实现该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java" target="_blank" rel="noopener"><code>HealthIndicator</code></a>接口的Spring bean 。您需要提供<code>health()</code>方法的实现并返回<code>Health</code> 响应。的<code>Health</code>响应应该包括一个状态，并且可以任选地包括另外的细节被显示。以下代码显示了一个示例<code>HealthIndicator</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.Health;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> errorCode = check(); <span class="comment">// perform some specific health check</span></span><br><span class="line"><span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> Health.down().withDetail(<span class="string">"Error Code"</span>, errorCode).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Health.up().build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>给定的标识符<code>HealthIndicator</code>是没有<code>HealthIndicator</code>后缀的bean的名称（ 如果存在）。在前面的示例中，健康信息在名为的条目中可用<code>my</code>。</p></blockquote><p>除了Spring Boot的预定义 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/Status.java" target="_blank" rel="noopener"><code>Status</code></a>类型之外，还可以 <code>Health</code>返回<code>Status</code>表示新系统状态的自定义。在这种情况下，<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthAggregator.java" target="_blank" rel="noopener"><code>HealthAggregator</code></a>还需要提供接口的自定义实现 ，或者必须使用<code>management.health.status.order</code>配置属性配置默认实现。</p><p>例如，假设在您的某个实现中使用了 <code>Status</code>带代码的新代码。要配置严重性顺序，请将以下属性添加到应用程序属性：<code>FATAL`</code>HealthIndicator`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.health.status.order=FATAL, DOWN, OUT_OF_SERVICE, UNKNOWN, UP</span><br></pre></td></tr></table></figure><p>在响应中的HTTP状态代码反映总体健康状况（例如， <code>UP</code>映射到200，而<code>OUT_OF_SERVICE</code>并<code>DOWN</code>映射到503）。如果通过HTTP访问运行状况端点，则可能还需要注册自定义状态映射。例如，以下属性映射<code>FATAL</code>到503（服务不可用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.health.status.http-mapping.FATAL=503</span><br></pre></td></tr></table></figure><blockquote><p>如果需要更多控制，可以定义自己的<code>HealthStatusHttpMapper</code>bean。</p></blockquote><p>下表显示了内置状态的默认状态映射：</p><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">映射</th></tr></thead><tbody><tr><td style="text-align:center">下</td><td style="text-align:center">SERVICE_UNAVAILABLE（503）</td></tr><tr><td style="text-align:center">停止服务</td><td style="text-align:center">SERVICE_UNAVAILABLE（503）</td></tr><tr><td style="text-align:center">UP</td><td style="text-align:center">默认情况下没有映射，因此http状态为200</td></tr><tr><td style="text-align:center">未知</td><td style="text-align:center">默认情况下没有映射，因此http状态为200</td></tr></tbody></table><h3 id="反应性健康指标"><a href="#反应性健康指标" class="headerlink" title="反应性健康指标"></a>反应性健康指标</h3><p>对于反应式应用程序（例如使用Spring WebFlux的应用程序），<code>ReactiveHealthIndicator</code> 提供了一个非阻塞的合同来获取应用程序运行状况。与传统类似<code>HealthIndicator</code>，健康信息是从a的内容中收集的 （默认情况下，在您的。中定义的所有 和 实例都不会在弹性调度程序上执行不检查反应API的常规 。<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicatorRegistry.java" target="_blank" rel="noopener"><code>ReactiveHealthIndicatorRegistry</code></a><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java" target="_blank" rel="noopener"><code>HealthIndicator</code></a><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java" target="_blank" rel="noopener"> <code>ReactiveHealthIndicator</code></a><code>ApplicationContext</code> <code>HealthIndicator</code></p><blockquote><p>在响应式应用程序中，<code>ReactiveHealthIndicatorRegistry</code>可用于在运行时注册和取消注册运行状况指示器。</p></blockquote><p>要从反应式API提供自定义运行状况信息，您可以注册实现该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>ReactiveHealthIndicator</code></a> 接口的Spring bean 。以下代码显示了一个示例<code>ReactiveHealthIndicator</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactiveHealthIndicator</span> <span class="keyword">implements</span> <span class="title">ReactiveHealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Health&gt; <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doHealthCheck() <span class="comment">//执行一些返回Mono &lt;Health&gt; </span></span><br><span class="line">.onErrorResume(ex -&gt; Mono.just(<span class="keyword">new</span> Health.Builder().down(ex).build())));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要自动处理错误，请考虑从中扩展 <code>AbstractReactiveHealthIndicator</code>。</p></blockquote><h3 id="自动配置的ReactiveHealthIndicators"><a href="#自动配置的ReactiveHealthIndicators" class="headerlink" title="自动配置的ReactiveHealthIndicators"></a>自动配置的ReactiveHealthIndicators</h3><p><code>ReactiveHealthIndicators</code>适当时，Spring Boot会自动配置以下内容：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>CassandraReactiveHealthIndicator</code></a></td><td style="text-align:center">检查Cassandra数据库是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>CouchbaseReactiveHealthIndicator</code></a></td><td style="text-align:center">检查Couchbase群集是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>MongoReactiveHealthIndicator</code></a></td><td style="text-align:center">检查Mongo数据库是否已启动。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>RedisReactiveHealthIndicator</code></a></td><td style="text-align:center">检查Redis服务器是否已启动。</td></tr></tbody></table><blockquote><p>必要时，反应指标取代常规指标。此外，任何 <code>HealthIndicator</code>未明确处理的内容都会自动换行。</p></blockquote><h2 id="应用信息"><a href="#应用信息" class="headerlink" title="应用信息"></a>应用信息</h2><p>应用程序信息公开从<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java" target="_blank" rel="noopener"><code>InfoContributor</code></a>您的中定义的所有bean 收集的各种信息 <code>ApplicationContext</code>。Spring Boot包含许多自动配置的<code>InfoContributor</code>bean，您可以编写自己的bean。</p><h3 id="自动配置的InfoContributors"><a href="#自动配置的InfoContributors" class="headerlink" title="自动配置的InfoContributors"></a>自动配置的InfoContributors</h3><p><code>InfoContributor</code>适当时，Spring Boot会自动配置以下bean：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java" target="_blank" rel="noopener"><code>EnvironmentInfoContributor</code></a></td><td style="text-align:center">暴露出钥匙<code>Environment</code>下面的任何<code>info</code>钥匙。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java" target="_blank" rel="noopener"><code>GitInfoContributor</code></a></td><td style="text-align:center">如果<code>git.properties</code>文件可用，则公开git信息。</td></tr><tr><td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java" target="_blank" rel="noopener"><code>BuildInfoContributor</code></a></td><td style="text-align:center">如果<code>META-INF/build-info.properties</code>文件可用，则公开构建信息。</td></tr></tbody></table><blockquote><p>可以通过设置<code>management.info.defaults.enabled</code> 属性来禁用它们。</p></blockquote><h3 id="自定义应用程序信息"><a href="#自定义应用程序信息" class="headerlink" title="自定义应用程序信息"></a>自定义应用程序信息</h3><p>您可以<code>info</code>通过设置<code>info.*</code>Spring属性来自定义端点公开的数据。密钥<code>Environment</code>下的所有属性都会<code>info</code>自动显示。例如，您可以将以下设置添加到您的<code>application.properties</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.app.encoding=UTF-8</span><br><span class="line">info.app.java.source=1.8</span><br><span class="line">info.app.java.target=1.8</span><br></pre></td></tr></table></figure><blockquote><p>您可以<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-automatic-expansion" target="_blank" rel="noopener">在构建时扩展信息属性，</a>而不是对这些值进行硬编码 。</p><p>假设您使用Maven，您可以按如下方式重写前面的示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.app.encoding=@project.build.sourceEncoding@</span><br><span class="line">info.app.java.source=@java.version@</span><br><span class="line">info.app.java.target=@java.version@</span><br></pre></td></tr></table></figure><h3 id="Git提交信息"><a href="#Git提交信息" class="headerlink" title="Git提交信息"></a>Git提交信息</h3><p><code>info</code>端点的另一个有用功能是它能够<code>git</code>在构建项目时发布有关源代码存储库状态的信息。如果 <code>GitProperties</code>豆可用，<code>git.branch</code>，<code>git.commit.id</code>，和<code>git.commit.time</code>属性暴露出来。</p><blockquote><p>一个<code>GitProperties</code>bean是自动配置，如果一个<code>git.properties</code>文件可在classpath的根目录。有关更多详细<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-git-info" target="_blank" rel="noopener">信息，</a>请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-git-info" target="_blank" rel="noopener">生成git信息</a> ”。</p></blockquote><p>如果要显示完整的git信息（即完整内容 <code>git.properties</code>），请使用该<code>management.info.git.mode</code>属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.info.git.mode=full</span><br></pre></td></tr></table></figure><h3 id="构建信息"><a href="#构建信息" class="headerlink" title="构建信息"></a>构建信息</h3><p>如果<code>BuildProperties</code>bean可用，<code>info</code>端点也可以发布有关构建的信息。如果<code>META-INF/build-info.properties</code>类路径中有文件可用，则会发生这种情况。</p><blockquote><p>Maven和Gradle插件都可以生成该文件。有关更多详细<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-build-info" target="_blank" rel="noopener">信息，</a>请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-build-info" target="_blank" rel="noopener">生成构建信息</a> ”。</p></blockquote><h3 id="编写自定义InfoContributors"><a href="#编写自定义InfoContributors" class="headerlink" title="编写自定义InfoContributors"></a>编写自定义InfoContributors</h3><p>要提供自定义应用程序信息，可以注册实现该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java" target="_blank" rel="noopener"><code>InfoContributor</code></a>接口的Spring bean 。</p><p>以下示例<code>example</code>使用单个值提供条目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInfoContributor</span> <span class="keyword">implements</span> <span class="title">InfoContributor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contribute</span><span class="params">(Info.Builder builder)</span> </span>&#123;</span><br><span class="line">builder.withDetail(<span class="string">"example"</span>,</span><br><span class="line">Collections.singletonMap(<span class="string">"key"</span>, <span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果到达<code>info</code>端点，您应该看到包含以下附加条目的响应：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"example"</span>: &#123;</span><br><span class="line"><span class="attr">"key"</span> : <span class="string">"value"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> endpoint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-actuator</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-actuator/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-actuator/</url>
      
        <content type="html"><![CDATA[<h1 id="启用生产就绪功能"><a href="#启用生产就绪功能" class="headerlink" title="启用生产就绪功能"></a>启用生产就绪功能</h1><p>该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator" target="_blank" rel="noopener"><code>spring-boot-actuator</code></a>模块提供了Spring Boot的所有生产就绪功能。启用这些功能的最简单方法是为<code>spring-boot-starter-actuator</code>“Starter” 添加依赖项。</p><p><strong>执行器的定义</strong></p><p>致动器是制造术语，指的是用于移动或控制某物的机械装置。执行器可以通过一个小的变化产生大量的运动。</p><p>要将执行器添加到基于Maven的项目，请添加以下“Starter”依赖项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于Gradle，请使用以下声明：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"><span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-actuator"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> actuator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-创建自己的自动配置</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="创建自己的自动配置"><a href="#创建自己的自动配置" class="headerlink" title="创建自己的自动配置"></a>创建自己的自动配置</h1><p>如果您在开发共享库的公司工作，或者您在开源或商业库中工作，则可能需要开发自己的自动配置。自动配置类可以捆绑在外部jar中，仍然可以通过Spring Boot获取。</p><p>自动配置可以与“启动器”相关联，该“启动器”提供自动配置代码以及您将使用它的典型库。我们首先介绍了构建自己的自动配置需要了解的内容，然后我们将继续介绍<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-custom-starter" target="_blank" rel="noopener">创建自定义启动器所需</a>的 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-custom-starter" target="_blank" rel="noopener">典型步骤</a>。</p><blockquote><p>可以使用<a href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration" target="_blank" rel="noopener">演示项目</a>来展示如何逐步创建启动器。</p></blockquote><h2 id="了解自动配置的Bean"><a href="#了解自动配置的Bean" class="headerlink" title="了解自动配置的Bean"></a>了解自动配置的Bean</h2><p>在引擎盖下，自动配置使用标准<code>@Configuration</code>类实现。其他<code>@Conditional</code>注释用于约束何时应用自动配置。通常，自动配置类使用<code>@ConditionalOnClass</code>和 <code>@ConditionalOnMissingBean</code>注释。这可确保仅在找到相关类时以及未声明自己的类时才应用自动配置 <code>@Configuration</code>。</p><p>您可以浏览源代码<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure" target="_blank" rel="noopener"><code>spring-boot-autoconfigure</code></a> 以查看<code>@Configuration</code>Spring提供的类（请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories" target="_blank" rel="noopener"><code>META-INF/spring.factories</code></a> 文件）。</p><h2 id="找到自动配置候选者"><a href="#找到自动配置候选者" class="headerlink" title="找到自动配置候选者"></a>找到自动配置候选者</h2><p>Spring Boot会检查<code>META-INF/spring.factories</code>已发布jar中是否存在文件。该文件应列出<code>EnableAutoConfiguration</code>密钥下的配置类 ，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span><br></pre></td></tr></table></figure><blockquote><p>自动配置，必须加载这种方式<em>只</em>。确保它们在特定的包空间中定义，并且它们永远不是组件扫描的目标。此外，自动配置类不应启用组件扫描以查找其他组件。应该使用特定的<code>@ Import</code>s代替。</p></blockquote><p>如果需要按特定顺序应用配置，则可以使用 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java" target="_blank" rel="noopener"><code>@AutoConfigureAfter</code></a>或 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java" target="_blank" rel="noopener"><code>@AutoConfigureBefore</code></a>注释。例如，如果您提供特定于Web的配置，则可能需要在之后应用您的类 <code>WebMvcAutoConfiguration</code>。</p><p>如果您想订购某些不应该彼此直接了解的自动配置，您也可以使用<code>@AutoConfigureOrder</code>。该注释与常规注释具有相同的语义，<code>@Order</code>但为自动配置类提供了专用顺序。</p><h2 id="条件注释"><a href="#条件注释" class="headerlink" title="条件注释"></a>条件注释</h2><p>您几乎总是希望<code>@Conditional</code>在自动配置类中包含一个或多个注释。该<code>@ConditionalOnMissingBean</code>注释是用来让开发者重写自动配置，如果他们不满意自己的缺省值一个常见的例子。</p><p>Spring Boot包含许多<code>@Conditional</code>注释，您可以通过注释<code>@Configuration</code>类或单个<code>@Bean</code>方法在自己的代码中重用这些注释。这些注释包括：</p><ul><li>Class条件</li><li>Bean条件</li><li>Property条件</li><li>Resource条件</li><li>Web Application条件</li><li>spEL表达式条件</li></ul><h3 id="Class-Conditions"><a href="#Class-Conditions" class="headerlink" title="Class Conditions"></a>Class Conditions</h3><p><code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingClass</code>注解让 <code>@Configuration</code>类基于特定类的存在或不存在被包括在内。由于使用<a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a>解析注释元数据这一事实，您可以使用该<code>value</code>属性来引用真实类，即使该类实际上可能不会出现在正在运行的应用程序类路径中。<code>name</code> 如果您希望使用<code>String</code>值指定类名，也可以使用该属性。</p><p>此机制不适用于<code>@Bean</code>通常返回类型是条件的目标的方法：在方法的条件适用之前，JVM将加载类和可能处理的方法引用，如果类不是当下。</p><p>要处理此方案，<code>@Configuration</code>可以使用单独的类来隔离条件，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//一些条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动配置的bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(EmbeddedAcmeService.class)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedAcmeService <span class="title">embeddedAcmeService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果您使用<code>@ConditionalOnClass</code>或<code>@ConditionalOnMissingClass</code>作为元注释的一部分来组成您自己的组合注释，则必须使用<code>name</code>在这种情况下引用该类而不处理。</p></blockquote><h3 id="Bean-Conditions"><a href="#Bean-Conditions" class="headerlink" title="Bean Conditions"></a>Bean Conditions</h3><p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>注解让豆基于特定豆的存在或不存在被包括在内。您可以使用该<code>value</code> 属性按类型<code>name</code>指定bean 或按名称指定bean。该<code>search</code> 属性允许您限制<code>ApplicationContext</code>搜索Bean时应考虑的层次结构。</p><p>放置在<code>@Bean</code>方法上时，目标类型默认为方法的返回类型，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的示例中，<code>myService</code>如果没有<code>MyService</code>包含类型的bean，则将创建bean <code>ApplicationContext</code>。</p><blockquote><p>您需要非常小心添加bean定义的顺序，因为这些条件是根据到目前为止已处理的内容进行评估的。出于这个原因，我们建议仅对自动配置类使用<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>注释（因为在添加任何用户定义的bean定义之后，这些类保证加载）。</p></blockquote><blockquote><p><code>@ConditionalOnBean</code>并且<code>@ConditionalOnMissingBean</code>不会阻止<code>@Configuration</code> 创建类。在类级别使用这些条件和<code>@Bean</code>使用注释标记每个包含的方法之间的唯一区别是，<code>@Configuration</code>如果条件不匹配，前者会阻止将类注册为bean。</p></blockquote><h3 id="Property-Conditions"><a href="#Property-Conditions" class="headerlink" title="Property Conditions"></a>Property Conditions</h3><p>该<code>@ConditionalOnProperty</code>注解让配置基于Spring的环境属性被包括在内。使用<code>prefix</code>和<code>name</code>属性指定应检查的属性。默认情况下，<code>false</code>匹配存在且不相等的任何属性。您还可以使用<code>havingValue</code>和 <code>matchIfMissing</code>属性创建更高级的检查。</p><h3 id="Resource-Conditions"><a href="#Resource-Conditions" class="headerlink" title="Resource Conditions"></a>Resource Conditions</h3><p>该<code>@ConditionalOnResource</code>注解让配置被包括仅当特定资源是否存在。可以使用常用的Spring约定来指定资源，如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:/home/user/test.dat</span><br></pre></td></tr></table></figure><h3 id="Web-Application-Conditions"><a href="#Web-Application-Conditions" class="headerlink" title="Web Application Conditions"></a>Web Application Conditions</h3><p>在<code>@ConditionalOnWebApplication</code>和<code>@ConditionalOnNotWebApplication</code>注释，让配置取决于应用程序是否是一个“Web应用程序”被包括在内。Web应用程序是使用Spring <code>WebApplicationContext</code>，定义<code>session</code>范围或具有的任何应用程序<code>StandardServletEnvironment</code>。</p><h3 id="spEL-Conditions"><a href="#spEL-Conditions" class="headerlink" title="spEL Conditions"></a>spEL Conditions</h3><p>该<code>@ConditionalOnExpression</code>注解让配置基于一个的结果被包括<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/core.html#expressions" target="_blank" rel="noopener">使用SpEL表达</a>。</p><h2 id="测试自动配置"><a href="#测试自动配置" class="headerlink" title="测试自动配置"></a>测试自动配置</h2><p>自动配置可能受许多因素的影响：用户配置（<code>@Bean</code> 定义和<code>Environment</code>自定义），条件评估（存在特定库）等。具体而言，每个测试都应创建一个定义良好的<code>ApplicationContext</code>代表，以表示这些自定义的组合。 <code>ApplicationContextRunner</code>提供了实现这一目标的好方法。</p><p><code>ApplicationContextRunner</code>通常被定义为测试类的一个字段来收集基本的通用配置。以下示例确保 <code>UserServiceAutoConfiguration</code>始终调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">.withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</span><br></pre></td></tr></table></figure><blockquote><p>如果必须定义多个自动配置，则无需按照与运行应用程序时完全相同的顺序调用它们的声明。</p></blockquote><p>每个测试都可以使用运行器来表示特定的用例。例如，下面的示例调用用户配置（<code>UserConfiguration</code>）并检查自动配置是否正确退回。调用<code>run</code>提供了可以使用的回调上下文<code>Assert4J</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultServiceBacksOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.contextRunner.withUserConfiguration(UserConfiguration.class)</span><br><span class="line">.run((context) -&gt; &#123;</span><br><span class="line">assertThat(context).hasSingleBean(UserService.class);</span><br><span class="line">assertThat(context.getBean(UserService.class)).isSameAs(</span><br><span class="line">context.getBean(UserConfiguration.class).myUserService());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserService <span class="title">myUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UserService(<span class="string">"mine"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以轻松自定义<code>Environment</code>，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceNameCanBeConfigured</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.contextRunner.withPropertyValues(<span class="string">"user.name=test123"</span>).run((context) -&gt; &#123;</span><br><span class="line">assertThat(context).hasSingleBean(UserService.class);</span><br><span class="line">assertThat(context.getBean(UserService.class).getName()).isEqualTo(<span class="string">"test123"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runner也可以用来显示<code>ConditionEvaluationReport</code>。报告可以打印<code>INFO</code>或<code>DEBUG</code>级别打印。以下示例显示如何使用<code>ConditionEvaluationReportLoggingListener</code> 在自动配置测试中打印报表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> autoConfigTest &#123;</span><br><span class="line">ConditionEvaluationReportLoggingListener initializer = </span><br><span class="line">        <span class="keyword">new</span> ConditionEvaluationReportLoggingListener(LogLevel.INFO);</span><br><span class="line">ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">.withInitializer(initializer).run((context) -&gt; &#123;</span><br><span class="line"><span class="comment">// Do something...</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟Web上下文"><a href="#模拟Web上下文" class="headerlink" title="模拟Web上下文"></a>模拟Web上下文</h3><p>如果您需要测试仅在Servlet或Reactive Web应用程序上下文中运行的自动配置，请分别使用<code>WebApplicationContextRunner</code>或<code>ReactiveWebApplicationContextRunner</code>。</p><h3 id="覆盖Classpath"><a href="#覆盖Classpath" class="headerlink" title="覆盖Classpath"></a>覆盖Classpath</h3><p>还可以测试在运行时不存在特定类和/或包时发生的情况。Spring Boot附带一个<code>FilteredClassLoader</code>可以由跑步者轻松使用的。在以下示例中，我们声明如果<code>UserService</code>不存在，则会正确禁用自动配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceIsIgnoredIfLibraryIsNotPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.contextRunner.withClassLoader(<span class="keyword">new</span> FilteredClassLoader(UserService.class))</span><br><span class="line">.run((context) -&gt; assertThat(context).doesNotHaveBean(<span class="string">"userService"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建自己的启动器"><a href="#创建自己的启动器" class="headerlink" title="创建自己的启动器"></a>创建自己的启动器</h2><p>的完整Spring Boot启动程序可能包含以下组件：</p><ul><li><code>autoconfigure</code>包含自动配置代码的模块。</li><li>该<code>starter</code>模块提供对<code>autoconfigure</code>模块以及库的依赖关系以及通常有用的任何其他依赖关系。简而言之，添加启动器应该提供开始使用该库所需的一切。</li></ul><blockquote><p>如果您不需要将这两个问题分开，则可以将自动配置代码和依赖关系管理组合在一个模块中。</p></blockquote><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>您应该确保为您的启动器提供适当的命名空间。<code>spring-boot</code>即使您使用其他Maven，也不要使用它来启动模块名称<code>groupId</code>。我们可能会为您将来自动配置的内容提供官方支持。</p><p>根据经验，您应该在启动器后命名组合模块。例如，假设您正在为“acme”创建启动器，并且您将自动配置模块<code>acme-spring-boot-autoconfigure</code>和启动器命名为<code>acme-spring-boot-starter</code>。如果您只有一个组合两者的模块，请将其命名<code>acme-spring-boot-starter</code>。</p><p>此外，如果您的启动器提供配置密钥，请为它们使用唯一的命名空间。特别是，不包括你在春天开机使用的命名空间键（如 <code>server</code>，<code>management</code>，<code>spring</code>，等）。如果您使用相同的命名空间，我们将来可能会以破坏您的模块的方式修改这些命名空间。</p><p>确保 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#configuration-metadata-annotation-processor" target="_blank" rel="noopener">触发元数据生成，</a>以便为您的密钥提供IDE帮助。您可能希望查看生成的元数据（<code>META-INF/spring-configuration-metadata.json</code>）以确保正确记录您的密钥。</p><h3 id="autoconfigure模块"><a href="#autoconfigure模块" class="headerlink" title="autoconfigure模块"></a>autoconfigure模块</h3><p>该<code>autoconfigure</code>模块包含开始使用库所需的所有内容。它还可以包含配置键定义（例如 <code>@ConfigurationProperties</code>）和任何可用于进一步自定义组件初始化方式的回调接口。</p><blockquote><p>您应该将库的依赖项标记为可选，以便您可以<code>autoconfigure</code>更轻松地将模块包含在项目中。如果以这种方式执行，则不提供库，默认情况下，Spring Boot会退出。</p></blockquote><p>Spring Boot使用注释处理器来收集元数据文件（<code>META-INF/spring-autoconfigure-metadata.properties</code>）中自动配置的条件。如果该文件存在，则用于热切过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于Gradle 4.5及更早版本，应在<code>compileOnly</code> 配置中声明依赖项，如以下示例所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">compileOnly <span class="string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Gradle 4.6及更高版本时，应在<code>annotationProcessor</code> 配置中声明依赖项，如以下示例所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">annotationProcessor <span class="string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动器模块"><a href="#启动器模块" class="headerlink" title="启动器模块"></a>启动器模块</h3><p>启动器是一个空罐子。它的唯一目的是提供必要的依赖项来使用库。您可以将其视为对入门所需内容的一种看法。</p><p>不要对添加启动器的项目做出假设。如果您自动配置的库通常需要其他启动器，请同时提及它们。如果可选依赖项的数量很高，则提供一组适当的<em>默认</em>依赖项可能很难，因为您应该避免包含对典型库的使用不必要的依赖项。换句话说，您不应该包含可选的依赖项。</p><blockquote><p>无论哪种方式，您的启动器必须<code>spring-boot-starter</code>直接或间接引用核心Spring Boot启动器（）（如果您的启动器依赖于另一个启动器，则无需添加它）。如果只使用自定义启动器创建项目，则Spring Boot的核心功能将通过核心启动器的存在来实现。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> configuration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-WebService</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-WebService/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-WebService/</url>
      
        <content type="html"><![CDATA[<h1 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h1><p>Spring Boot提供Web服务自动配置，因此您必须做的就是定义您的<code>Endpoints</code>。</p><p>在<a href="https://docs.spring.io/spring-ws/docs/3.0.6.RELEASE/reference/" target="_blank" rel="noopener">春天的Web服务功能</a>可以与轻松访问<code>spring-boot-starter-webservices</code>模块。</p><p><code>SimpleWsdl11Definition</code>和<code>SimpleXsdSchema</code>bean可以分别为您的WSDL和XSD自动创建。为此，请配置其位置，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.webservices.wsdl-locations=classpath:/wsdl</span><br></pre></td></tr></table></figure><h2 id="使用Web调用Web服务-WebServiceTemplate"><a href="#使用Web调用Web服务-WebServiceTemplate" class="headerlink" title="使用Web调用Web服务 WebServiceTemplate"></a>使用Web调用Web服务 WebServiceTemplate</h2><p>如果需要从应用程序调用远程Web服务，则可以使用 <a href="https://docs.spring.io/spring-ws/docs/3.0.6.RELEASE/reference/#client-web-service-template" target="_blank" rel="noopener"><code>WebServiceTemplate</code></a>该类。由于<code>WebServiceTemplate</code>实例在使用之前通常需要自定义，因此Spring Boot不提供任何单个自动配置的<code>WebServiceTemplate</code>bean。但是，它会自动配置a <code>WebServiceTemplateBuilder</code>，可用于<code>WebServiceTemplate</code>在需要时创建 实例。</p><p>以下代码显示了一个典型示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WebServiceTemplate webServiceTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebServiceTemplateBuilder webServiceTemplateBuilder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.webServiceTemplate = webServiceTemplateBuilder.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DetailsResp <span class="title">someWsCall</span><span class="params">(DetailsReq detailsReq)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> (DetailsResp) <span class="keyword">this</span>.webServiceTemplate</span><br><span class="line">             .marshalSendAndReceive(detailsReq, <span class="keyword">new</span> SoapActionCallback(ACTION));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，使用类路径上的可用HTTP客户端库<code>WebServiceTemplateBuilder</code>检测合适的基于 <code>WebServiceMessageSender</code>HTTP的。您还可以按如下方式自定义读取和连接超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebServiceTemplate <span class="title">webServiceTemplate</span><span class="params">(WebServiceTemplateBuilder builder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> builder.messageSenders(<span class="keyword">new</span> HttpWebServiceMessageSenderBuilder()</span><br><span class="line">.setConnectTimeout(<span class="number">5000</span>).setReadTimeout(<span class="number">2000</span>).build()).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-WebSockets</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-WebSockets/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-WebSockets/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h1><p>Spring Boot为嵌入式Tomcat，Jetty和Undertow提供WebSockets自动配置。如果将war文件部署到独立容器，则Spring Boot假定容器负责其WebSocket支持的配置。</p><p>Spring Framework 为MVC Web应用程序提供了<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#websocket" target="_blank" rel="noopener">丰富的WebSocket支持</a>，可以通过该<code>spring-boot-starter-websocket</code>模块轻松访问 。</p><p>WebSocket支持也可用于 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-websocket" target="_blank" rel="noopener">响应式Web应用程序，</a>并且需要包括WebSocket API以及<code>spring-boot-starter-webflux</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBott-test</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBott-test/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBott-test/</url>
      
        <content type="html"><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>Spring Boot提供了许多实用程序和注释来帮助您测试应用程序。测试支持由两个模块提供：<code>spring-boot-test</code>包含核心项，并<code>spring-boot-test-autoconfigure</code>支持测试的自动配置。</p><p>大多数开发人员使用<code>spring-boot-starter-test</code>启动器，它导入Spring Boot测试模块以及JUnit，AssertJ，Hamcrest和许多其他有用的库。</p><h2 id="测试范围依赖性"><a href="#测试范围依赖性" class="headerlink" title="测试范围依赖性"></a>测试范围依赖性</h2><p>在<code>spring-boot-starter-test</code>启动器中（<code>test</code> <code>scope</code>）包含以下提供的库：</p><ul><li><a href="http://junit.org/" target="_blank" rel="noopener">JUnit</a>：单元测试Java应用程序的事实上的标准。</li><li><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#integration-testing" target="_blank" rel="noopener">Spring Test</a>和Spring Boot测试：Spring Boot应用程序的实用程序和集成测试支持。</li><li><a href="https://joel-costigliola.github.io/assertj/" target="_blank" rel="noopener">AssertJ</a>：一个流畅的断言库。</li><li><a href="http://hamcrest.org/JavaHamcrest/" target="_blank" rel="noopener">Hamcrest</a>：匹配器对象库（也称为约束或谓词）。</li><li><a href="http://mockito.org/" target="_blank" rel="noopener">Mockito</a>：一个Java <a href="http://mockito.org/" target="_blank" rel="noopener">模拟</a>框架。</li><li><a href="https://github.com/skyscreamer/JSONassert" target="_blank" rel="noopener">JSONassert</a>：JSON的断言库。</li><li><a href="https://github.com/jayway/JsonPath" target="_blank" rel="noopener">JsonPath</a>：JSON的XPath。</li></ul><p>我们通常发现这些常用库在编写测试时很有用。如果这些库不符合您的需求，您可以添加自己的其他测试依赖项。</p><h2 id="测试Spring应用程序"><a href="#测试Spring应用程序" class="headerlink" title="测试Spring应用程序"></a>测试Spring应用程序</h2><p>依赖注入的一个主要优点是它应该使您的代码更容易进行单元测试。您可以使用<code>new</code>运算符实例化对象，甚至不涉及Spring。您还可以使用<em>模拟对象</em>而不是真正的依赖项。</p><p>通常，您需要超越单元测试并开始集成测试（使用Spring <code>ApplicationContext</code>）。能够在不需要部署应用程序或需要连接到其他基础架构的情况下执行集成测试非常有用。</p><p>Spring Framework包含一个用于此类集成测试的专用测试模块。您可以直接声明依赖关系<code>org.springframework:spring-test</code>或使用<code>spring-boot-starter-test</code>“Starter”来传递它。</p><p>如果您之前没有使用过该<code>spring-test</code>模块，那么首先应阅读Spring Framework参考文档的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testing" target="_blank" rel="noopener">相关部分</a>。</p><h2 id="测试Spring-Boot应用程序"><a href="#测试Spring-Boot应用程序" class="headerlink" title="测试Spring Boot应用程序"></a>测试Spring Boot应用程序</h2><p>Spring Boot应用程序是一个Spring <code>ApplicationContext</code>，所以没有什么特别的东西可以用来测试它超出你通常使用的Spring语境。</p><blockquote><p>只有在您<code>SpringApplication</code>创建Spring Boot的外部属性，日志记录和其他功能时，默认情况下才会在上下文中安装它们。</p></blockquote><p>Spring Boot提供了一个<code>@SpringBootTest</code>注释，<code>spring-test</code> <code>@ContextConfiguration</code>当您需要Spring Boot功能时，它可以用作标准注释的替代方法。注释的工作原理是通过 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-detecting-config" target="_blank" rel="noopener">创建 <code>ApplicationContext</code>测试中使用的<code>SpringApplication</code></a>。除了 <code>@SpringBootTest</code>提供许多其他注释之外，还提供了用于 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">测试</a>应用程序的<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">更具体的切片</a>。</p><blockquote><p>如果您使用的是JUnit 4，请不要忘记添加<code>@RunWith(SpringRunner.class)</code>到测试中，否则注释将被忽略。如果您使用的是JUnit 5，则无需添加等效项<code>@ExtendWith(SpringExtension)</code>，<code>@SpringBootTest</code>并且其他<code>@…Test</code>注释已经使用它进行注释。</p></blockquote><p>默认情况下，<code>@SpringBootTest</code>不会启动服务器。您可以使用该<code>webEnvironment</code> 属性<code>@SpringBootTest</code>进一步优化测试的运行方式：</p><ul><li><code>MOCK</code>（默认）：加载Web <code>ApplicationContext</code>并提供模拟Web环境。使用此批注时，不会启动嵌入式服务器。如果类路径上没有Web环境，则此模式将透明地回退到创建常规非Web <code>ApplicationContext</code>。它可以与Web应用程序一起使用 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-mock-environment" target="_blank" rel="noopener"><code>@AutoConfigureMockMvc</code>或<code>@AutoConfigureWebTestClient</code></a>用于基于模拟的Web应用程序测试。</li><li><code>RANDOM_PORT</code>：加载a <code>WebServerApplicationContext</code>并提供真实的Web环境。嵌入式服务器启动并在随机端口上侦听。</li><li><code>DEFINED_PORT</code>：加载a <code>WebServerApplicationContext</code>并提供真实的Web环境。嵌入式服务器启动并侦听定义的端口（来自您的<code>application.properties</code>）或默认端口<code>8080</code>。</li><li><code>NONE</code>：<code>ApplicationContext</code>通过使用<code>SpringApplication</code>但不提供 <em>任何</em> Web环境（模拟或其他）来加载。</li></ul><blockquote><p>如果您的测试是<code>@Transactional</code>，则默认情况下会在每个测试方法结束时回滚事务。但是，当使用这种安排<code>RANDOM_PORT</code>或者 <code>DEFINED_PORT</code>隐式地提供真实的servlet环境时，HTTP客户端和服务器在不同的线程中运行，因此在单独的事务中运行。在这种情况下，在服务器上启动的任何事务都不会回滚。</p></blockquote><blockquote><p><code>@SpringBootTest`</code>webEnvironment = WebEnvironment.RANDOM_PORT`如果您的应用程序使用管理服务器的不同端口，则还将在单独的随机端口上启动管理服务器。</p></blockquote><h3 id="检测Web应用程序类型"><a href="#检测Web应用程序类型" class="headerlink" title="检测Web应用程序类型"></a>检测Web应用程序类型</h3><p>如果Spring MVC可用，则配置基于MVC的常规应用程序上下文。如果您只有Spring WebFlux，我们会检测到并配置基于WebFlux的应用程序上下文。</p><p>如果两者都存在，则Spring MVC优先。如果要在此方案中测试响应式Web应用程序，则必须设置该<code>spring.main.web-application-type</code> 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(properties = <span class="string">"spring.main.web-application-type=reactive"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebFluxTests</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="检测测试配置"><a href="#检测测试配置" class="headerlink" title="检测测试配置"></a>检测测试配置</h3><p>如果您熟悉Spring Test Framework，则可能习惯使用 <code>@ContextConfiguration(classes=…)</code>以指定<code>@Configuration</code>要加载的Spring 。或者，您可能经常<code>@Configuration</code>在测试中使用嵌套类。</p><p>在测试Spring Boot应用程序时，通常不需要这样做。<code>@*Test</code> 只要您没有明确定义，Spring Boot的注释就会自动搜索您的主要配置。</p><p>搜索算法从包含测试的包开始工作，直到找到用<code>@SpringBootApplication</code>or 注释的类<code>@SpringBootConfiguration</code>。只要您以合理的方式<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#using-boot-structuring-your-code" target="_blank" rel="noopener">构建代码</a>，通常就会找到主要配置。</p><blockquote><p>如果使用 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">测试批注来测试应用程序的更具体的片段</a>，则应避免在<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-user-configuration" target="_blank" rel="noopener">main方法的应用程序类中</a>添加特定于特定区域的配置设置 。</p><p><code>@SpringBootApplication</code>定义的基础组件扫描配置排除了用于确保切片按预期工作的过滤器。如果您<code>@ComponentScan</code>在已<code>@SpringBootApplication</code>注释的类上使用显式 指令，请注意将禁用这些过滤器。如果您正在使用切片，则应再次定义它们。</p></blockquote><p>如果要自定义主要配置，可以使用嵌套 <code>@TestConfiguration</code>类。与嵌套<code>@Configuration</code>类不同，嵌套类将用于代替应用程序的主要配置，<code>@TestConfiguration</code>除了应用程序的主要配置之外，还使用嵌套类。</p><blockquote><p>Spring的测试框架在测试之间缓存应用程序上下文。因此，只要您的测试共享相同的配置（无论如何发现），加载上下文的潜在耗时过程只发生一次。</p></blockquote><h3 id="排除测试配置"><a href="#排除测试配置" class="headerlink" title="排除测试配置"></a>排除测试配置</h3><p>如果您的应用程序使用组件扫描（例如，如果您使用 <code>@SpringBootApplication</code>或<code>@ComponentScan</code>），您可能会发现仅为特定测试创建的顶级配置类会意外地在任何地方被捕获。</p><p>正如我们<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-detecting-config" target="_blank" rel="noopener">之前所见</a>，<code>@TestConfiguration</code>可以在测试的内部类上使用来自定义主要配置。放置在顶级类时，<code>@TestConfiguration</code>表示<code>src/test/java</code>不应通过扫描拾取类。然后，您可以在需要的位置显式导入该类，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Import</span>(MyTestsConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果您直接使用<code>@ComponentScan</code>（即不通过 <code>@SpringBootApplication</code>），则需要注册<code>TypeExcludeFilter</code>。有关详细信息，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/context/TypeExcludeFilter.html" target="_blank" rel="noopener">Javadoc</a>。</p></blockquote><h3 id="使用模拟环境进行测试"><a href="#使用模拟环境进行测试" class="headerlink" title="使用模拟环境进行测试"></a>使用模拟环境进行测试</h3><p>默认情况下，<code>@SpringBootTest</code>不启动服务器。如果您要针对此模拟环境测试Web端点，则可以另外进行配置 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference//testing.html#spring-mvc-test-framework" target="_blank" rel="noopener"><code>MockMvc</code></a>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBoot</span><br><span class="line">Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockMvcExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mvc.perform(get(<span class="string">"/"</span>)).andExpect(status().isOk())</span><br><span class="line">.andExpect(content().string(<span class="string">"Hello World"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你想只专注于网络层，而不是开始一个完整的 <code>ApplicationContext</code>，可以考虑 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests" target="_blank" rel="noopener">使用 <code>@WebMvcTest</code>替代</a>。</p></blockquote><p>或者，您可以配置一个 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#webtestclient-tests" target="_blank" rel="noopener"><code>WebTestClient</code></a>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureWebTestClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockWebTestClientExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebTestClient webClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.webClient.get().uri(<span class="string">"/"</span>).exchange().expectStatus().isOk()</span><br><span class="line">            .expectBody(String.class).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用正在运行的服务器进行测试"><a href="#使用正在运行的服务器进行测试" class="headerlink" title="使用正在运行的服务器进行测试"></a>使用正在运行的服务器进行测试</h3><p>如果您需要启动一个完整运行的服务器，我们建议您使用随机端口。如果使用<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>，每次测试运行时都会随机选取一个可用端口。</p><p>该<code>@LocalServerPort</code>注释可用于 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-discover-the-http-port-at-runtime" target="_blank" rel="noopener">注射使用的实际端口</a>到您的测试。为了方便起见，测试，需要做出REST调用启动的服务器可另外<code>@Autowire</code>一个<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#webtestclient-tests" target="_blank" rel="noopener"><code>WebTestClient</code></a>，它解析为正在运行的服务器相对链接，并附带了用于验证响应的专用API，如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPortWebTestClientExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebTestClient webClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.webClient.get().uri(<span class="string">"/"</span>).exchange().expectStatus().isOk()</span><br><span class="line">.expectBody(String.class).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类设置需要<code>spring-webflux</code>在类路径上。如果您不能或不会添加webflux，Spring Boot还提供了一个<code>TestRestTemplate</code>工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPortTestRestTemplateExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String body = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"/"</span>, String.class);</span><br><span class="line">assertThat(body).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用JMX"><a href="#使用JMX" class="headerlink" title="使用JMX"></a>使用JMX</h3><p>当测试上下文框架缓存上下文时，默认情况下禁用JMX以防止相同的组件在同一域上注册。如果此类测试需要访问 <code>MBeanServer</code>，请考虑将其标记为脏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(properties = <span class="string">"spring.jmx.enabled=true"</span>)</span><br><span class="line"><span class="meta">@DirtiesContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleJmxTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MBeanServer mBeanServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mocking-and-Spying-Beans"><a href="#Mocking-and-Spying-Beans" class="headerlink" title="Mocking and Spying Beans"></a>Mocking and Spying Beans</h3><p>运行测试时，有时需要在应用程序上下文中模拟某些组件。例如，您可能拥有在开发期间不可用的某些远程服务的外观。当您想要模拟在真实环境中难以触发的故障时，模拟也很有用。</p><p>Spring Boot包含一个<code>@MockBean</code>注释，可用于为您内部的bean定义Mockito模拟<code>ApplicationContext</code>。您可以使用批注添加新bean或替换单个现有bean定义。注释可以直接用于测试类，测试中的字段，或<code>@Configuration</code>类和字段。在字段上使用时，也会注入创建的模拟的实例。每种测试方法后，模拟豆都会自动重置。</p><blockquote><p>如果您的测试使用Spring Boot的测试注释之一（例如<code>@SpringBootTest</code>），则会自动启用此功能。要以不同的排列方式使用此功能，必须显式添加侦听器，如以下示例所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestExecutionListeners</span>（MockitoTestExecutionListener.class）</span><br></pre></td></tr></table></figure><p>以下示例使用<code>RemoteService</code>模拟实现替换现有bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line"><span class="keyword">private</span> RemoteService remoteService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Reverser reverser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// RemoteService has been injected into the reverser bean</span></span><br><span class="line">given(<span class="keyword">this</span>.remoteService.someCall()).willReturn(<span class="string">"mock"</span>);</span><br><span class="line">String reverse = reverser.reverseSomeCall();</span><br><span class="line">assertThat(reverse).isEqualTo(<span class="string">"kcom"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，您可以使用<code>@SpyBean</code>Mockito来包装任何现有的bean <code>spy</code>。有关详细信息，请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/test/mock/mockito/SpyBean.html" target="_blank" rel="noopener">Javadoc</a>。</p><blockquote><p>虽然Spring的测试框架在测试之间缓存应用程序上下文并重用共享相同配置的测试的上下文，但是使用<code>@MockBean</code>或<code>@SpyBean</code> 影响缓存键，这很可能会增加上下文的数量。</p></blockquote><blockquote><p>如果您使用通过名称引用参数的方法<code>@SpyBean</code>来监视bean，则<code>@Cacheable</code>必须使用编译应用程序<code>-parameters</code>。这确保了一旦bean被监视，参数名称可用于缓存基础结构。</p></blockquote><h3 id="自动配置的测试"><a href="#自动配置的测试" class="headerlink" title="自动配置的测试"></a>自动配置的测试</h3><p>Spring Boot的自动配置系统适用于应用程序，但有时对于测试来说有点太多了。通常有助于仅加载测试应用程序“切片”所需的配置部分。例如，您可能希望测试Spring MVC控制器是否正确映射URL，并且您不希望在这些测试中涉及数据库调用，或者您可能想要测试JPA实体，并且您对Web层不感兴趣测试运行。</p><p>该<code>spring-boot-test-autoconfigure</code>模块包括许多可用于自动配置这种“切片”的注释。它们中的每一个都以类似的方式工作，提供一个<code>@…Test</code>注释，用于加载可用于自定义自动配置设置的<code>ApplicationContext</code>一个或多个<code>@AutoConfigure…</code>注释。</p><blockquote><p>每个切片将组件扫描限制为适当的组件，并加载一组非常有限的自动配置类。如果您需要排除其中一个，大多数<code>@…Test</code>注释都会提供一个<code>excludeAutoConfiguration</code>属性。或者，您可以使用<code>@ImportAutoConfiguration#exclude</code>。</p></blockquote><blockquote><p><code>@Test</code>不支持在一次测试中使用多个注释包括多个“切片” 。如果您需要多个“切片”，请选择其中一个<code>@…Test</code>注释并<code>@AutoConfigure…</code>手动包含其他“切片” 的注释。</p></blockquote><blockquote><p>也可以使用<code>@AutoConfigure…</code>带有标准 <code>@SpringBootTest</code>注释的注释。如果您对“切片”应用程序不感兴趣但想要一些自动配置的测试bean，则可以使用此组合。</p></blockquote><h3 id="自动配置的JSON测试"><a href="#自动配置的JSON测试" class="headerlink" title="自动配置的JSON测试"></a>自动配置的JSON测试</h3><p>要测试该对象JSON序列化和反序列化是否按预期工作，您可以使用<code>@JsonTest</code>注释。<code>@JsonTest</code>自动配置可用的受支持JSON映射器，它可以是以下库之一：</p><ul><li>Jackson<code>ObjectMapper</code>，任何<code>@JsonComponent</code>beans和Jackson<code>Module</code>S</li><li><code>Gson</code></li><li><code>Jsonb</code></li></ul><blockquote><p><code>@JsonTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p></blockquote><p>如果需要配置自动配置的元素，可以使用 <code>@AutoConfigureJsonTesters</code>注释。</p><p>Spring Boot包括基于AssertJ的助手，它们与JSONAssert和JsonPath库一起使用，以检查JSON是否按预期显示。的<code>JacksonTester</code>，<code>GsonTester</code>，<code>JsonbTester</code>，和<code>BasicJsonTester</code>类可以分别用于杰克逊，GSON，Jsonb，和字符串。测试类上的任何辅助字段都可以<code>@Autowired</code>在使用时使用<code>@JsonTest</code>。以下示例显示了Jackson的测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@JsonTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJsonTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JacksonTester&lt;VehicleDetails&gt; json;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">VehicleDetails details = <span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>);</span><br><span class="line"><span class="comment">//在与测试断言相同的包中断言.json文件</span></span><br><span class="line">assertThat(<span class="keyword">this</span>.json.write(details)).isEqualToJson(<span class="string">"expected.json"</span>);</span><br><span class="line"><span class="comment">//或者使用基于JSON路径的断言</span></span><br><span class="line">assertThat(<span class="keyword">this</span>.json.write(details)).hasJsonPathStringValue(<span class="string">"@.make"</span>);</span><br><span class="line">assertThat(<span class="keyword">this</span>.json.write(details)).extractingJsonPathStringValue(<span class="string">"@.make"</span>)</span><br><span class="line">.isEqualTo(<span class="string">"Honda"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeserialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String content = <span class="string">"&#123;\"make\":\"Ford\",\"model\":\"Focus\"&#125;"</span>;</span><br><span class="line">assertThat(<span class="keyword">this</span>.json.parse(content))</span><br><span class="line">.isEqualTo(<span class="keyword">new</span> VehicleDetails(<span class="string">"Ford"</span>, <span class="string">"Focus"</span>));</span><br><span class="line">assertThat(<span class="keyword">this</span>.json.parseObject(content).getMake()).isEqualTo(<span class="string">"Ford"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JSON帮助程序类也可以直接在标准单元测试中使用。为此，如果不使用，请在<code>initFields</code>方法中调用帮助程序的<code>@Before</code>方法 <code>@JsonTest</code>。</p></blockquote><h3 id="自动配置的Spring-MVC测试"><a href="#自动配置的Spring-MVC测试" class="headerlink" title="自动配置的Spring MVC测试"></a>自动配置的Spring MVC测试</h3><p>要测试Spring MVC控制器是否按预期工作，请使用<code>@WebMvcTest</code> 注释。<code>@WebMvcTest</code>自动配置Spring MVC的基础设施和限制扫描豆<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>， <code>GenericConverter</code>，<code>Filter</code>，<code>WebMvcConfigurer</code>，和<code>HandlerMethodArgumentResolver</code>。<code>@Component</code>使用此批注时不会扫描常规bean。</p><blockquote><p><code>@WebMvcTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p></blockquote><blockquote><p>如果需要注册额外的组件，例如Jackson <code>Module</code>，则可以<code>@Import</code>在测试中使用其他配置类。</p></blockquote><p>通常，<code>@WebMvcTest</code>仅限于单个控制器，并与其结合使用 <code>@MockBean</code>，为所需的协作者提供模拟实现。</p><p><code>@WebMvcTest</code>还自动配置<code>MockMvc</code>。Mock MVC提供了一种快速测试MVC控制器的强大方法，无需启动完整的HTTP服务器。</p><blockquote><p>您还可以通过使用注释来<code>MockMvc</code>非自动配置<code>@WebMvcTest</code>（例如 <code>@SpringBootTest</code>）<code>@AutoConfigureMockMvc</code>。以下示例使用<code>MockMvc</code>：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebMvcTest</span>(UserVehicleController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line"><span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))</span><br><span class="line">.willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));</span><br><span class="line"><span class="keyword">this</span>.mvc.perform(get(<span class="string">"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">            .andExpect(status().isOk()).andExpect(content().string(<span class="string">"Honda Civic"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果需要配置自动配置的元素（例如，应该应用servlet过滤器时），则可以使用<code>@AutoConfigureMockMvc</code> 注释中的属性。</p></blockquote><p>如果您使用HtmlUnit或Selenium，则自动配置还提供HTMLUnit <code>WebClient</code> bean和/或<code>WebDriver</code>bean。以下示例使用HtmlUnit：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.gargoylesoftware.htmlunit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebMvcTest</span>(UserVehicleController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHtmlUnitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line"><span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))</span><br><span class="line">.willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));</span><br><span class="line">HtmlPage page = <span class="keyword">this</span>.webClient.getPage(<span class="string">"/sboot/vehicle.html"</span>);</span><br><span class="line">assertThat(page.getBody().getTextContent()).isEqualTo(<span class="string">"Honda Civic"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，Spring Boot将<code>WebDriver</code>bean放在一个特殊的“范围”中，以确保驱动程序在每次测试后退出并注入新实例。如果您不想要此行为，可以添加<code>@Scope(&quot;singleton&quot;)</code>到您的<code>WebDriver</code> <code>@Bean</code> 定义中。</p></blockquote><blockquote><p><code>webDriver</code>Spring Boot创建的范围将替换任何用户定义的同名范围。如果您定义自己的<code>webDriver</code>范围，您可能会发现它在您使用时停止工作<code>@WebMvcTest</code>。</p></blockquote><p>如果在类路径上有Spring Security，<code>@WebMvcTest</code>则还会扫描<code>WebSecurityConfigurer</code> bean。您可以使用Spring Security的测试支持，而不是完全禁用此类测试的安全性。有关如何使用Spring Security <code>MockMvc</code>支持的更多详细信息，请参见<em>第80章“ 使用Spring Security测试</em>方法”部分。</p><blockquote><p>有时编写Spring MVC测试是不够的; Spring Boot可以帮助您<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">使用实际服务器</a>运行 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">完整的端到端测试</a>。</p></blockquote><h3 id="自动配置的Spring-WebFlux测试"><a href="#自动配置的Spring-WebFlux测试" class="headerlink" title="自动配置的Spring WebFlux测试"></a>自动配置的Spring WebFlux测试</h3><p>要测试<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference//web-reactive.html" target="_blank" rel="noopener">Spring WebFlux</a>控制器是否按预期工作，您可以使用<code>@WebFluxTest</code>注释。<code>@WebFluxTest</code> 自动配置春季WebFlux基础设施和限制扫描豆<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>，<code>GenericConverter</code>，和 <code>WebFluxConfigurer</code>。 使用注释<code>@Component</code>时不会扫描常规bean <code>@WebFluxTest</code>。</p><blockquote><p><code>@WebFluxTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p></blockquote><blockquote><p>如果需要注册额外的组件，例如Jackson <code>Module</code>，则可以<code>@Import</code>在测试中导入其他配置类。</p></blockquote><p>通常，<code>@WebFluxTest</code>仅限于单个控制器并与<code>@MockBean</code>注释结合使用， 以便为所需的协作者提供模拟实现。</p><p><code>@WebFluxTest</code>还有自动配置 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#webtestclient" target="_blank" rel="noopener"><code>WebTestClient</code></a>，这提供了一种快速测试WebFlux控制器的强大方法，无需启动完整的HTTP服务器。</p><blockquote><p>您还可以通过使用注释来<code>WebTestClient</code>非自动配置<code>@WebFluxTest</code>（例如 <code>@SpringBootTest</code>）<code>@AutoConfigureWebTestClient</code>。以下示例显示了使用both <code>@WebFluxTest</code>和a的类<code>WebTestClient</code>：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebFluxTest</span>(UserVehicleController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebTestClient webClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MockBean</span></span><br><span class="line"><span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))</span><br><span class="line">.willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));</span><br><span class="line"><span class="keyword">this</span>.webClient.get().uri(<span class="string">"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN)</span><br><span class="line">.exchange()</span><br><span class="line">.expectStatus().isOk()</span><br><span class="line">.expectBody(String.class).isEqualTo(<span class="string">"Honda Civic"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此设置仅由WebFlux应用程序支持，因为<code>WebTestClient</code>在模拟的Web应用程序中使用仅适用于WebFlux。</p></blockquote><blockquote><p><code>@WebFluxTest</code>无法检测通过功能Web框架注册的路由。要<code>RouterFunction</code>在上下文中测试bean，请考虑<code>RouterFunction</code> 通过<code>@Import</code>或使用自己导入<code>@SpringBootTest</code>。</p></blockquote><blockquote><p>有时编写Spring WebFlux测试是不够的; Spring Boot可以帮助您<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">使用实际服务器</a>运行 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">完整的端到端测试</a>。</p></blockquote><h3 id="自动配置的数据JPA测试"><a href="#自动配置的数据JPA测试" class="headerlink" title="自动配置的数据JPA测试"></a>自动配置的数据JPA测试</h3><p>您可以使用<code>@DataJpaTest</code>注释来测试JPA应用程序。默认情况下，它配置内存中的嵌入式数据库，扫描<code>@Entity</code>类并配置Spring Data JPA存储库。常规<code>@Component</code>bean没有加载到 <code>ApplicationContext</code>。</p><blockquote><p><code>@DataJpaTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p></blockquote><p>默认情况下，数据JPA测试是事务性的，并在每次测试结束时回滚。有关 更多详细信息，请参阅Spring Framework Reference Documentation中的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions" target="_blank" rel="noopener">相关部分</a>。如果这不是您想要的，您可以为测试或整个类禁用事务管理，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据JPA测试也可以注入一个 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.java" target="_blank" rel="noopener"><code>TestEntityManager</code></a> bean，它提供了<code>EntityManager</code>专门为测试设计的标准JPA的替代方法。如果要<code>TestEntityManager</code>在<code>@DataJpaTest</code>实例外部 使用，也可以使用<code>@AutoConfigureTestEntityManager</code> 注释。<code>JdbcTemplate</code>如果您需要，也可以使用A. 以下示例显示<code>@DataJpaTest</code>正在使用的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TestEntityManager entityManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.entityManager.persist(<span class="keyword">new</span> User(<span class="string">"sboot"</span>, <span class="string">"1234"</span>));</span><br><span class="line">User user = <span class="keyword">this</span>.repository.findByUsername(<span class="string">"sboot"</span>);</span><br><span class="line">assertThat(user.getUsername()).isEqualTo(<span class="string">"sboot"</span>);</span><br><span class="line">assertThat(user.getVin()).isEqualTo(<span class="string">"1234"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存中的嵌入式数据库通常可以很好地用于测试，因为它们很快并且不需要任何安装。但是，如果您更喜欢对真实数据库运行测试，则可以使用<code>@AutoConfigureTestDatabase</code>注释，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@AutoConfigureTestDatabase</span>(replace=Replace.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置的JDBC测试"><a href="#自动配置的JDBC测试" class="headerlink" title="自动配置的JDBC测试"></a>自动配置的JDBC测试</h3><p><code>@JdbcTest</code>类似于<code>@DataJpaTest</code>但仅适用于仅需要 <code>DataSource</code>并且不使用Spring Data JDBC的测试。默认情况下，它配置内存中的嵌入式数据库和<code>JdbcTemplate</code>。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。</p><blockquote><p><code>@JdbcTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p></blockquote><p>默认情况下，JDBC测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参阅Spring Framework Reference Documentation中的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions" target="_blank" rel="noopener">相关部分</a>。如果这不是您想要的，您可以禁用测试或整个类的事务管理，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@JdbcTest</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您希望测试针对真实数据库运行，则可以使用与<code>@AutoConfigureTestDatabase</code>注释相同的方式使用 注释<code>DataJpaTest</code>。（参见“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test" target="_blank" rel="noopener">第46.3.12节</a> ” ,”<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test" target="_blank" rel="noopener">自动配置的数据JPA测试</a> “）</p><h3 id="自动配置的数据JDBC测试"><a href="#自动配置的数据JDBC测试" class="headerlink" title="自动配置的数据JDBC测试"></a>自动配置的数据JDBC测试</h3><p><code>@DataJdbcTest</code>类似于<code>@JdbcTest</code>但是适用于使用Spring Data JDBC存储库的测试。默认情况下，它配置内存中的嵌入式数据库，a <code>JdbcTemplate</code>和Spring Data JDBC存储库。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。</p><blockquote><p><code>@DataJdbcTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p></blockquote><p>默认情况下，数据JDBC测试是事务性的，并在每次测试结束时回滚。有关 更多详细信息，请参阅Spring Framework Reference Documentation中的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions" target="_blank" rel="noopener">相关部分</a>。如果这不是您想要的，您可以禁用测试或整个测试类的事务管理，如 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test" target="_blank" rel="noopener">JDBC示例中所示</a>。</p><p>如果您希望测试针对真实数据库运行，则可以使用与<code>@AutoConfigureTestDatabase</code>注释相同的方式使用 注释<code>DataJpaTest</code>。（参见“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test" target="_blank" rel="noopener">第46.3.12节</a> ” ,”<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test" target="_blank" rel="noopener">自动配置的数据JPA测试</a> “）</p><h3 id="自动配置的jOOQ测试"><a href="#自动配置的jOOQ测试" class="headerlink" title="自动配置的jOOQ测试"></a>自动配置的jOOQ测试</h3><p>您可以使用<code>@JooqTest</code>与<code>@JdbcTest</code>jOOQ相关的测试类似的方式。由于jOOQ严重依赖于与数据库模式对应的基于Java的模式，因此使用现有模式<code>DataSource</code>。如果要将其替换为内存数据库，可以使用<code>@AutoConfigureTestDatabase</code>覆盖这些设置。（有关在Spring Boot中使用jOOQ的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-jooq" target="_blank" rel="noopener">第31.6节</a> ” <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-jooq" target="_blank" rel="noopener">，“使用jOOQ”</a>。）常规 <code>@Component</code>bean不会加载到<code>ApplicationContext</code>。</p><blockquote><p><code>@JooqTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p></blockquote><p><code>@JooqTest</code>配置一个<code>DSLContext</code>。常规<code>@Component</code>bean没有加载到 <code>ApplicationContext</code>。以下示例显示<code>@JooqTest</code>正在使用的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jooq.DSLContext;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.jooq.JooqTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@JooqTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJooqTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DSLContext dslContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JOOQ测试是事务性的，默认情况下在每次测试结束时回滚。如果这不是您想要的，您可以禁用测试或整个测试类的事务管理，如 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test" target="_blank" rel="noopener">JDBC示例中所示</a>。</p><h3 id="自动配置的数据MongoDB测试"><a href="#自动配置的数据MongoDB测试" class="headerlink" title="自动配置的数据MongoDB测试"></a>自动配置的数据MongoDB测试</h3><p>您可以使用它<code>@DataMongoTest</code>来测试MongoDB应用程序。默认情况下，它配置内存中嵌入的MongoDB（如果可用），配置<code>MongoTemplate</code>，扫描 <code>@Document</code>类以及配置Spring Data MongoDB存储库。常规 <code>@Component</code>bean没有加载到<code>ApplicationContext</code>。（有关将MongoDB与Spring Boot一起使用的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-mongodb" target="_blank" rel="noopener">第32.2节”，“MongoDB”</a>。）</p><blockquote><p><code>@DataMongoTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p></blockquote><p>以下类显示<code>@DataMongoTest</code>正在使用的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataMongoTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataMongoTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存中嵌入式MongoDB通常适用于测试，因为它速度快，不需要任何开发人员安装。但是，如果您更喜欢对真正的MongoDB服务器运行测试，则应排除嵌入式MongoDB自动配置，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"> <span class="keyword">import</span> org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataMongoTest</span>(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataMongoNonEmbeddedTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置的数据Neo4j测试"><a href="#自动配置的数据Neo4j测试" class="headerlink" title="自动配置的数据Neo4j测试"></a>自动配置的数据Neo4j测试</h3><p>您可以使用它<code>@DataNeo4jTest</code>来测试Neo4j应用程序。默认情况下，它使用内存中嵌入式Neo4j（如果嵌入式驱动程序可用），扫描<code>@NodeEntity</code>类并配置Spring Data Neo4j存储库。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。（有关使用带有Spring Boot的Neo4J的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-neo4j" target="_blank" rel="noopener">第32.3节”，“Neo4j”</a>。）</p><blockquote><p><code>@DataNeo4jTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p></blockquote><p>以下示例显示了在Spring Boot中使用Neo4J测试的典型设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataNeo</span>4jTest</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataNeo4jTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> YourRepository repository;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，Data Neo4j测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参阅Spring Framework Reference Documentation中的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions" target="_blank" rel="noopener">相关部分</a>。如果这不是您想要的，您可以禁用测试或整个类的事务管理，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataNeo</span>4jTest</span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置的数据Redis测试"><a href="#自动配置的数据Redis测试" class="headerlink" title="自动配置的数据Redis测试"></a>自动配置的数据Redis测试</h3><p>您可以使用它<code>@DataRedisTest</code>来测试Redis应用程序。默认情况下，它会扫描 <code>@RedisHash</code>类并配置Spring Data Redis存储库。常规<code>@Component</code> bean没有加载到<code>ApplicationContext</code>。（有关使用带有Spring Boot的Redis的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-redis" target="_blank" rel="noopener">第32.1节”，“Redis”</a>。）</p><blockquote><p><code>@DataRedisTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p></blockquote><p>以下示例显示<code>@DataRedisTest</code>正在使用的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataRedisTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataRedisTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> YourRepository repository;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置的数据LDAP测试"><a href="#自动配置的数据LDAP测试" class="headerlink" title="自动配置的数据LDAP测试"></a>自动配置的数据LDAP测试</h3><p>您可以使用它<code>@DataLdapTest</code>来测试LDAP应用程序。默认情况下，它配置内存中嵌入式LDAP（如果可用），配置<code>LdapTemplate</code>，扫描<code>@Entry</code> 类以及配置Spring Data LDAP存储库。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。（有关在Spring Boot中使用LDAP的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-ldap" target="_blank" rel="noopener">第32.9节”，“LDAP”</a>。）</p><blockquote><p><code>@DataLdapTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p></blockquote><p>以下示例显示<code>@DataLdapTest</code>正在使用的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ldap.core.LdapTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataLdapTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataLdapTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LdapTemplate ldapTemplate;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存中嵌入式LDAP通常适用于测试，因为它速度快，不需要任何开发人员安装。但是，如果您更喜欢针对真实LDAP服务器运行测试，则应排除嵌入式LDAP自动配置，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataLdapTest</span>(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataLdapNonEmbeddedTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置的REST客户端"><a href="#自动配置的REST客户端" class="headerlink" title="自动配置的REST客户端"></a>自动配置的REST客户端</h3><p>您可以使用<code>@RestClientTest</code>注释来测试REST客户端。默认情况下，它会自动配置Jackson，GSON和Jsonb支持，配置<code>RestTemplateBuilder</code>并添加支持<code>MockRestServiceServer</code>。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。</p><blockquote><p><code>@RestClientTest</code>可以<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p></blockquote><p>应使用<code>value</code>or <code>components</code>属性指定要测试的特定bean <code>@RestClientTest</code>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@RestClientTest</span>(RemoteVehicleDetailsService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRestClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RemoteVehicleDetailsService service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockRestServiceServer server;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.server.expect(requestTo(<span class="string">"/greet/details"</span>))</span><br><span class="line">.andRespond(withSuccess(<span class="string">"hello"</span>, MediaType.TEXT_PLAIN));</span><br><span class="line">String greeting = <span class="keyword">this</span>.service.callRestService();</span><br><span class="line">assertThat(greeting).isEqualTo(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动配置的Spring-REST-Docs测试"><a href="#自动配置的Spring-REST-Docs测试" class="headerlink" title="自动配置的Spring REST Docs测试"></a>自动配置的Spring REST Docs测试</h3><p>您可以使用<code>@AutoConfigureRestDocs</code>注释在Mock MVC，REST Assured或WebTestClient的测试中使用<a href="https://projects.spring.io/spring-restdocs/" target="_blank" rel="noopener">Spring REST Docs</a>。它消除了对Spring REST Docs中JUnit规则的需求。</p><p><code>@AutoConfigureRestDocs</code>可用于覆盖默认输出目录（<code>target/generated-snippets</code>如果您使用的是Maven，或者<code>build/generated-snippets</code>如果您使用的是Gradle）。它还可用于配置出现在任何已记录的URI中的主机，方案和端口。</p><h4 id="使用Mock-MVC自动配置Spring-REST-Docs测试"><a href="#使用Mock-MVC自动配置Spring-REST-Docs测试" class="headerlink" title="使用Mock MVC自动配置Spring REST Docs测试"></a>使用Mock MVC自动配置Spring REST Docs测试</h4><p><code>@AutoConfigureRestDocs</code>自定义<code>MockMvc</code>bean以使用Spring REST Docs。您可以<code>@Autowired</code>像在通常使用Mock MVC和Spring REST Docs时那样在测试中使用它来注入它，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebMvcTest</span>(UserController.class)</span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDocumentationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mvc.perform(get(<span class="string">"/users"</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">.andExpect(status().isOk())</span><br><span class="line">.andDo(document(<span class="string">"list-users"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您需要对Spring REST Docs配置的更多控制而不是属性提供，则<code>@AutoConfigureRestDocs</code>可以使用 <code>RestDocsMockMvcConfigurationCustomizer</code>bean，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationConfiguration</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">RestDocsMockMvcConfigurationCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(MockMvcRestDocumentationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要对参数化输出目录使用Spring REST Docs支持，可以创建<code>RestDocumentationResultHandler</code>bean。自动配置<code>alwaysDo</code>使用此结果处理程序调用 ，从而使每个<code>MockMvc</code>调用自动生成默认代码段。以下示例显示了 <code>RestDocumentationResultHandler</code>正在定义的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultHandlerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestDocumentationResultHandler <span class="title">restDocumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> MockMvcRestDocumentation.document(<span class="string">"&#123;method-name&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用REST-Assured自动配置Spring-REST-Docs测试"><a href="#使用REST-Assured自动配置Spring-REST-Docs测试" class="headerlink" title="使用REST Assured自动配置Spring REST Docs测试"></a>使用REST Assured自动配置Spring REST Docs测试</h4><p><code>@AutoConfigureRestDocs</code>制作一个<code>RequestSpecification</code>预先配置为使用Spring REST Docs 的bean，可用于您的测试。您可以<code>@Autowired</code>像在通常使用REST Assured和Spring REST Doc时那样在测试中使用它来注入它，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.restassured.specification.RequestSpecification;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.LocalServerPort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.restassured.RestAssured.given;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.is;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.restdocs.restassured3.RestAssuredRestDocumentation.document;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDocumentationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LocalServerPort</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RequestSpecification documentationSpec;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">given(<span class="keyword">this</span>.documentationSpec).filter(document(<span class="string">"list-users"</span>)).when()</span><br><span class="line">.port(<span class="keyword">this</span>.port).get(<span class="string">"/"</span>).then().assertThat().statusCode(is(<span class="number">200</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您需要对Spring REST Docs配置的更多控制而不是属性提供<code>@AutoConfigureRestDocs</code>，<code>RestDocsRestAssuredConfigurationCustomizer</code> 则可以使用bean，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationConfiguration</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">RestDocsRestAssuredConfigurationCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestAssuredRestDocumentationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附加自动配置和切片"><a href="#附加自动配置和切片" class="headerlink" title="附加自动配置和切片"></a>附加自动配置和切片</h3><p>每个切片提供一个或多个<code>@AutoConfigure…</code>注释，即定义应作为切片的一部分包括的自动配置。可以通过创建自定义<code>@AutoConfigure…</code>注释或仅通过添加<code>@ImportAutoConfiguration</code>到测试来添加其他自动配置，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@JdbcTest</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration</span>(IntegrationAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJdbcTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>确保不使用常规<code>@Import</code>注释来导入自动配置，因为Spring Boot会以特定方式处理它们。</p></blockquote><h3 id="用户配置和切片"><a href="#用户配置和切片" class="headerlink" title="用户配置和切片"></a>用户配置和切片</h3><p>如果以合理的方式<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#using-boot-structuring-your-code" target="_blank" rel="noopener">构造代码</a>，<code>@SpringBootApplication</code>则<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-detecting-config" target="_blank" rel="noopener">默认情况下</a>会将您的 类 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-detecting-config" target="_blank" rel="noopener">用作</a>测试的配置。</p><p>然后，重要的是不要使用特定于其功能的特定区域的配置设置来丢弃应用程序的主类。</p><p>假设您正在使用Spring Batch并依赖于它的自动配置。您可以<code>@SpringBootApplication</code>按如下方式定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>因为此类是测试的源配置，所以任何切片测试实际上都会尝试启动Spring Batch，这绝对不是您想要做的。建议的方法是将特定于区域的配置移动到与<code>@Configuration</code>应用程序相同级别的单独类中，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchConfiguration</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据应用程序的复杂程度，您可能只有一个 <code>@Configuration</code>类用于自定义，或者每个域区域有一个类。后一种方法允许您在必要时使用<code>@Import</code>注释在其中一个测试中启用它。</p></blockquote><p>混淆的另一个原因是类路径扫描。假设您以合理的方式构建代码，则需要扫描其他包。您的应用程序可能类似于以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(&#123; <span class="string">"com.example.app"</span>, <span class="string">"org.acme.another"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这样做会有效地覆盖默认组件扫描指令，并且无论您选择哪个切片，都会扫描这两个包。例如， <code>@DataJpaTest</code>似乎突然扫描了应用程序的组件和用户配置。同样，将自定义指令移动到单独的类是解决此问题的好方法。</p><blockquote><p>如果这不是您的选项，您可以<code>@SpringBootConfiguration</code> 在测试的层次结构中创建一个位置，以便使用它。或者，您可以为测试指定源，这会禁用查找默认源的行为。</p></blockquote><h3 id="使用Spock测试Spring-Boot应用程序"><a href="#使用Spock测试Spring-Boot应用程序" class="headerlink" title="使用Spock测试Spring Boot应用程序"></a>使用Spock测试Spring Boot应用程序</h3><p>如果您希望使用Spock来测试Spring Boot应用程序，您应该将Spock <code>spock-spring</code>模块的依赖项添加到应用程序的构建中。<code>spock-spring</code>将Spring的测试框架集成到Spock中。建议您使用Spock 1.2或更高版本从Spock的Spring Framework和Spring Boot集成的许多改进中受益。有关更多详细信息，请参阅<a href="http://spockframework.org/spock/docs/1.2/modules.html#_spring_module" target="_blank" rel="noopener">Spock Spring模块的文档</a>。</p><h2 id="测试应用程序"><a href="#测试应用程序" class="headerlink" title="测试应用程序"></a>测试应用程序</h2><p>在测试应用程序时通常有用的一些测试实用程序类是作为其一部分打包的<code>spring-boot</code>。</p><h3 id="ConfigFileApplicationContextInitializer"><a href="#ConfigFileApplicationContextInitializer" class="headerlink" title="ConfigFileApplicationContextInitializer"></a>ConfigFileApplicationContextInitializer</h3><p><code>ConfigFileApplicationContextInitializer</code>是一个<code>ApplicationContextInitializer</code>可以应用于测试以加载Spring Boot <code>application.properties</code>文件的。当您不需要提供的全部功能时，可以使用它<code>@SpringBootTest</code>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(classes = Config.class,</span><br><span class="line">initializers = ConfigFileApplicationContextInitializer.class)</span><br></pre></td></tr></table></figure><blockquote><p><code>ConfigFileApplicationContextInitializer</code>单独使用不提供<code>@Value(&quot;${…}&quot;)</code>注射支持 。它唯一的工作是确保将<code>application.properties</code>文件加载到Spring中<code>Environment</code>。要获得<code>@Value</code>支持，您需要另外配置<code>PropertySourcesPlaceholderConfigurer</code>或使用<code>@SpringBootTest</code>，为您自动配置一个。</p></blockquote><h3 id="TestPropertyValues"><a href="#TestPropertyValues" class="headerlink" title="TestPropertyValues"></a>TestPropertyValues</h3><p><code>TestPropertyValues</code>让您快速添加属性 <code>ConfigurableEnvironment</code>或<code>ConfigurableApplicationContext</code>。您可以使用<code>key=value</code>字符串调用它 ，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestPropertyValues.of(<span class="string">"org=Spring"</span>, <span class="string">"name=Boot"</span>).applyTo(env);</span><br></pre></td></tr></table></figure><h3 id="OutputCapture"><a href="#OutputCapture" class="headerlink" title="OutputCapture"></a>OutputCapture</h3><p><code>OutputCapture</code>是一个<code>Rule</code>可以用来捕获<code>System.out</code>和 <code>System.err</code>输出的JUnit 。您可以将捕获声明为a <code>@Rule</code>然后<code>toString()</code> 用于断言，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.rule.OutputCapture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> OutputCapture capture = <span class="keyword">new</span> OutputCapture();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">assertThat(capture.toString(), containsString(<span class="string">"World"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TestRestTemplate"><a href="#TestRestTemplate" class="headerlink" title="TestRestTemplate"></a>TestRestTemplate</h3><blockquote><p>Spring Framework 5.0提供了一个<code>WebTestClient</code>适用于 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests" target="_blank" rel="noopener">WebFlux集成测试</a>以及 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">WebFlux和MVC端到端测试的新功能</a>。它提供了一个流畅的断言API，不像<code>TestRestTemplate</code>。</p></blockquote><p><code>TestRestTemplate</code>是Spring的便捷替代品，<code>RestTemplate</code>在集成测试中很有用。您可以获得一个vanilla模板或一个发送基本HTTP身份验证（使用用户名和密码）的模板。在任何一种情况下，模板都以一种测试友好的方式运行，不会在服务器端错误上抛出异常。建议（但不是强制性的）使用Apache HTTP Client（版本4.3.2或更高版本）。如果您在类路径中有这个，则<code>TestRestTemplate</code>通过适当地配置客户端来响应。如果您确实使用Apache的HTTP客户端，则启用一些其他测试友好功能：</p><ul><li>不遵循重定向（因此您可以断言响应位置）。</li><li>Cookie被忽略（因此模板是无状态的）。</li></ul><p><code>TestRestTemplate</code> 可以直接在集成测试中实例化，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TestRestTemplate template = <span class="keyword">new</span> TestRestTemplate();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpHeaders headers = <span class="keyword">this</span>.template</span><br><span class="line">            .getForEntity(<span class="string">"http://myhost.example.com/example"</span>, String.class)</span><br><span class="line">            .getHeaders();</span><br><span class="line">assertThat(headers.getLocation()).hasHost(<span class="string">"other.example.com"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，如果您使用或使用<code>@SpringBootTest</code>注释 ，则可以注入完全配置并开始使用它。如有必要，可以通过bean 应用其他自定义。任何未指定主机和端口的URL都会自动连接到嵌入式服务器，<code>WebEnvironment.RANDOM_PORT</code> <code>WebEnvironment.DEFINED_PORT</code> <code>TestRestTemplate</code> <code>RestTemplateBuilder</code>如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleWebClientTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TestRestTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HttpHeaders headers = <span class="keyword">this</span>.template.getForEntity(<span class="string">"/example"</span>, String.class)</span><br><span class="line">.getHeaders();</span><br><span class="line">assertThat(headers.getLocation()).hasHost(<span class="string">"other.example.com"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">.setReadTimeout(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-JMX的监测和管理</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-JMX%E7%9A%84%E7%9B%91%E6%B5%8B%E5%92%8C%E7%AE%A1%E7%90%86/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-JMX%E7%9A%84%E7%9B%91%E6%B5%8B%E5%92%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="对JMX的监测和管理"><a href="#对JMX的监测和管理" class="headerlink" title="对JMX的监测和管理"></a>对JMX的监测和管理</h1><p>Java Management Extensions（JMX）提供了一种监视和管理应用程序的标准机制。Spring Boot公开了最适合<code>MBeanServer</code>作为ID为的bean <code>mbeanServer</code>。您的任何豆被标注有春天JMX注释（ <code>@ManagedResource</code>，<code>@ManagedAttribute</code>，或<code>@ManagedOperation</code>）接触到它。</p><p>如果您的平台提供标准<code>MBeanServer</code>，Spring Boot将使用它，并<code>MBeanServer</code>在必要时默认使用VM 。如果全部失败，<code>MBeanServer</code>将创建一个新的。</p><p>有关详细信息，请参阅 课程<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java" target="_blank" rel="noopener"><code>JmxAutoConfiguration</code></a>。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Integration和Session</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Integration%E5%92%8CSession/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Integration%E5%92%8CSession/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Integration-整合"><a href="#Spring-Integration-整合" class="headerlink" title="Spring Integration(整合)"></a>Spring Integration(整合)</h1><p>Spring Boot为使用<a href="https://projects.spring.io/spring-integration/" target="_blank" rel="noopener">Spring Integration</a>提供了一些便利，包括<code>spring-boot-starter-integration</code>“Starter”。Spring Integration提供了有关消息传递以及其他传输（如HTTP，TCP等）的抽象。如果类路径上有Spring Integration，则通过<code>@EnableIntegration</code>注释初始化它。</p><p>Spring Boot还配置了一些由于存在其他Spring Integration模块而触发的功能。如果<code>spring-integration-jmx</code>也在类路径上，则通过JMX发布消息处理统计信息。如果<code>spring-integration-jdbc</code>可用，则可以在启动时创建默认数据库模式，如以下行所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.integration.jdbc.initialize-schema = always</span><br></pre></td></tr></table></figure><p>有关 详细信息，请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java" target="_blank" rel="noopener"><code>IntegrationAutoConfiguration</code></a> 和<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java" target="_blank" rel="noopener"><code>IntegrationProperties</code></a>类。</p><p>默认情况下，如果存在千分尺<code>meterRegistry</code>bean，则由Micrometer管理Spring Integration指标。如果您希望使用旧版Spring Integration度量标准，请将<code>DefaultMetricsFactory</code>bean 添加到应用程序上下文中。</p><h1 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h1><p>Spring Boot为各种数据存储提供<a href="https://projects.spring.io/spring-session/" target="_blank" rel="noopener">Spring Session</a>自动配置。构建Servlet Web应用程序时，可以自动配置以下存储：</p><ul><li>JDBC</li><li>Redis</li><li>Hazelcast</li><li>MongoDB</li></ul><p>构建响应式Web应用程序时，可以自动配置以下存储：</p><ul><li>Redis</li><li>MongoDB</li></ul><p>如果类路径上存在单个Spring Session模块，则Spring Boot会自动使用该存储实现。如果您有多个实现，则必须选择<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/session/StoreType.java" target="_blank" rel="noopener"><code>StoreType</code></a>要用于存储会话的实现。例如，要使用JDBC作为后端存储，您可以按如下方式配置应用程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.store-type=jdbc</span><br></pre></td></tr></table></figure><blockquote><p>您可以通过设置禁用春季会议<code>store-type</code>到<code>none</code>。</p></blockquote><p>每个商店都有特定的附加设置。例如，可以为JDBC存储定制表的名称，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.jdbc.table-name=SESSIONS</span><br></pre></td></tr></table></figure><p>要设置会话超时，可以使用该<code>spring.session.timeout</code>属性。如果未设置该属性，则自动配置将回退到值 <code>server.servlet.session.timeout</code>。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> integration </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Quartz</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Quartz/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Quartz/</url>
      
        <content type="html"><![CDATA[<h1 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h1><p>Spring Boot为使用<a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">Quartz调度程序</a>提供了一些便利 ，包括 <code>spring-boot-starter-quartz</code>“Starter”。如果Quartz可用，<code>Scheduler</code>则自动配置a（通过<code>SchedulerFactoryBean</code>抽象）。</p><p>自动拾取以下类型的豆并与以下相关联 <code>Scheduler</code>：</p><ul><li><code>JobDetail</code>：定义一个特定的Job。<code>JobDetail</code>可以使用<code>JobBuilder</code>API 构建实例 。</li><li><code>Calendar</code>。</li><li><code>Trigger</code>：定义何时触发特定作业。</li></ul><p>默认情况下，使用内存<code>JobStore</code>。但是，如果<code>DataSource</code>应用程序中有bean可用，并且相应地<code>spring.quartz.job-store-type</code>配置了 属性，则可以配置基于JDBC的存储，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.job-store-type=jdbc</span><br></pre></td></tr></table></figure><p>使用JDBC存储时，可以在启动时初始化模式，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.jdbc.initialize-schema=always</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，使用Quartz库提供的标准脚本检测并初始化数据库。这些脚本删除现有表，在每次重启时删除所有触发器。也可以通过设置<code>spring.quartz.jdbc.schema</code>属性来提供自定义脚本 。</p></blockquote><p>要让Quartz使用<code>DataSource</code>除应用程序main之外的其他东西<code>DataSource</code>，请声明一个<code>DataSource</code>bean，用它来注释其<code>@Bean</code>方法<code>@QuartzDataSource</code>。这样做可确保 架构初始化和架构初始化<code>DataSource</code>都使用Quartz特定的<code>SchedulerFactoryBean</code>。</p><p>默认情况下，配置创建的作业不会覆盖已从永久性作业存储读取的已注册作业。要启用覆盖现有作业定义，请设置该<code>spring.quartz.overwrite-existing-jobs</code>属性。</p><p>可以使用<code>spring.quartz</code>属性和 <code>SchedulerFactoryBeanCustomizer</code>bean 自定义Quartz Scheduler配置，这允许进行编程<code>SchedulerFactoryBean</code> 自定义。可以使用高级Quartz配置属性进行自定义 <code>spring.quartz.properties.*</code>。</p><blockquote><p>特别是，<code>Executor</code>bean不与调度程序相关联，因为Quartz提供了一种通过配置调度程序的方法<code>spring.quartz.properties</code>。如果需要自定义任务执行程序，请考虑实现<code>SchedulerFactoryBeanCustomizer</code>。</p></blockquote><p>作业可以定义setter以注入数据映射属性。也可以以类似的方式注入常规bean，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inject "MyService" bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inject the "name" job data property</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="任务执行和调度"><a href="#任务执行和调度" class="headerlink" title="任务执行和调度"></a>任务执行和调度</h1><p>在<code>Executor</code>上下文中没有bean的情况下，Spring Boot会自动配置一个 <code>ThreadPoolTaskExecutor</code>合理的默认值，这些默认值可以自动关联到异步任务执行（<code>@EnableAsync</code>）和Spring MVC异步请求处理。</p><blockquote><p>如果您<code>Executor</code>在上下文中定义了自定义，则常规任务执行（即 <code>@EnableAsync</code>）将透明地使用它，但不会配置Spring MVC支持，因为它需要<code>AsyncTaskExecutor</code>实现（命名 <code>applicationTaskExecutor</code>）。根据您的目标安排，您可以将您更改 <code>Executor</code>为a <code>ThreadPoolTaskExecutor</code>或定义a <code>ThreadPoolTaskExecutor</code>和<code>AsyncConfigurer</code>包装自定义<code>Executor</code>。</p><p>自动配置<code>TaskExecutorBuilder</code>允许您轻松创建实例，以重现默认情况下自动配置的功能。</p></blockquote><p>线程池使用8个核心线程，可根据负载增长和缩小。可以使用<code>spring.task.execution</code>命名空间对这些默认设置进行微调，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.task.execution.pool.max-threads=16</span><br><span class="line">spring.task.execution.pool.queue-capacity=100</span><br><span class="line">spring.task.execution.pool.keep-alive=10s</span><br></pre></td></tr></table></figure><p>这会将线程池更改为使用有界队列，以便在队列满（100个任务）时，线程池增加到最多16个线程。当线程在闲置10秒（而不是默认为60秒）时回收线程时，池的收缩会更加激进。</p><p><code>ThreadPoolTaskScheduler</code>如果需要与计划任务执行（<code>@EnableScheduling</code>）相关联，也可以自动配置A. 默认情况下，线程池使用一个线程，并且可以使用<code>spring.task.scheduling</code>命名空间对这些设置进行微调。</p><p>既是<code>TaskExecutorBuilder</code>豆和<code>TaskSchedulerBuilder</code>绿豆可在上下文提供如果自定义遗嘱执行人或调度需要创建。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quartz </tag>
            
            <tag> schedul </tag>
            
            <tag> task </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Hazelcast</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Hazelcast/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Hazelcast/</url>
      
        <content type="html"><![CDATA[<h1 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h1><p>如果<a href="https://hazelcast.com/" target="_blank" rel="noopener">Hazelcast</a>位于类路径上并找到合适的配置，则Spring Boot会自动配置<code>HazelcastInstance</code>您可以在应用程序中注入的内容。</p><p>如果你定义一个<code>com.hazelcast.config.Config</code>bean，Spring Boot会使用它。如果您的配置定义了实例名称，Spring Boot会尝试查找现有实例，而不是创建新实例。</p><p>您还可以指定<code>hazelcast.xml</code>要通过配置使用的配置文件，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.hazelcast.config = classpath：config / my-hazelcast.xml</span><br></pre></td></tr></table></figure><p>否则，Spring Boot会尝试从默认位置查找Hazelcast配置：<code>hazelcast.xml</code>在工作目录中或类路径的根目录。我们还检查是否<code>hazelcast.config</code>设置了系统属性。有关更多详细信息，请参阅 <a href="http://docs.hazelcast.org/docs/latest/manual/html-single/" target="_blank" rel="noopener">Hazelcast文档</a>。</p><p>如果<code>hazelcast-client</code>类路径中存在，则Spring Boot首先尝试通过检查以下配置选项来创建客户端：</p><ul><li><code>com.hazelcast.client.config.ClientConfig</code>豆的存在。</li><li>由<code>spring.hazelcast.config</code>属性定义的配置文件。</li><li><code>hazelcast.client.config</code>系统属性的存在。</li><li><code>hazelcast-client.xml</code>在工作目录中或类路径的根目录。</li></ul><blockquote><p>Spring Boot还为<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-hazelcast" target="_blank" rel="noopener">Hazelcast</a>提供了 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-hazelcast" target="_blank" rel="noopener">明确的缓存支持</a>。如果启用了缓存，<code>HazelcastInstance</code>则会自动将其包装在<code>CacheManager</code> 实现中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hazelcast </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-JTA的分布式事务</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-JTA%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-JTA%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="JTA的分布式事务"><a href="#JTA的分布式事务" class="headerlink" title="JTA的分布式事务"></a>JTA的分布式事务</h1><p>Spring Boot通过使用<a href="http://www.atomikos.com/" target="_blank" rel="noopener">Atomikos</a>或<a href="https://github.com/bitronix/btm" target="_blank" rel="noopener">Bitronix</a> 嵌入式事务管理器支持跨多个XA资源的分布式JTA事务。部署到合适的Java EE Application Server时，也支持JTA事务。</p><p>检测到JTA环境时，Spring <code>JtaTransactionManager</code>用于管理事务。自动配置的JMS，DataSource和JPA bean已升级为支持XA事务。您可以使用标准的Spring惯用语，例如<code>@Transactional</code>，参与分布式事务。如果您在JTA环境中并仍希望使用本地事务，则可以将该<code>spring.jta.enabled</code>属性设置<code>false</code>为禁用JTA自动配置。</p><h2 id="使用Atomikos事务管理器"><a href="#使用Atomikos事务管理器" class="headerlink" title="使用Atomikos事务管理器"></a>使用Atomikos事务管理器</h2><p><a href="https://www.atomikos.com/" target="_blank" rel="noopener">Atomikos</a>是一个流行的开源事务管理器，可以嵌入到Spring Boot应用程序中。您可以使用 <code>spring-boot-starter-jta-atomikos</code>Starter引入相应的Atomikos库。Spring Boot自动配置Atomikos并确保将适当的<code>depends-on</code>设置应用于Spring bean以正确启动和关闭顺序。</p><p>默认情况下，Atomikos事务日志将写入<code>transaction-logs</code>应用程序主目录（应用程序jar文件所在的目录）中的目录。您可以通过<code>spring.jta.log-dir</code>在<code>application.properties</code>文件中设置属性来自定义此目录的位置 。以…开头的属性<code>spring.jta.atomikos.properties</code>也可用于自定义Atomikos<code>UserTransactionServiceImp</code>。有关 完整的详细信息，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html" target="_blank" rel="noopener"><code>AtomikosProperties</code>Javadoc</a>。</p><blockquote><p>为确保多个事务管理器可以安全地协调相同的资源管理器，必须使用唯一ID配置每个Atomikos实例。默认情况下，此ID是运行Atomikos的计算机的IP地址。要确保生产中的唯一性，应<code>spring.jta.transaction-manager-id</code> 为应用程序的每个实例配置具有不同值的属性。</p></blockquote><h2 id="使用Bitronix事务管理器"><a href="#使用Bitronix事务管理器" class="headerlink" title="使用Bitronix事务管理器"></a>使用Bitronix事务管理器</h2><p><a href="https://github.com/bitronix/btm" target="_blank" rel="noopener">Bitronix</a>是一种流行的开源JTA事务管理器实现。您可以使用<code>spring-boot-starter-jta-bitronix</code>starter将适当的Bitronix依赖项添加到项目中。与Atomikos一样，Spring Boot会自动配置Bitronix并对bean进行后处理，以确保启动和关闭顺序正确。</p><p>默认情况下，Bitronix事务日志文件（<code>part1.btm</code>和<code>part2.btm</code>）将写入<code>transaction-logs</code>应用程序主目录中的目录。您可以通过设置<code>spring.jta.log-dir</code>属性来自定义此目录的位置。以…开头的属性<code>spring.jta.bitronix.properties</code>也绑定到 <code>bitronix.tm.Configuration</code>bean，允许完全自定义。有关详细信息，请参阅 <a href="https://github.com/bitronix/btm/wiki/Transaction-manager-configuration" target="_blank" rel="noopener">Bitronix文档</a>。</p><blockquote><p>为确保多个事务管理器可以安全地协调相同的资源管理器，必须为每个Bitronix实例配置唯一ID。默认情况下，此ID是运行Bitronix的计算机的IP地址。要确保生产中的唯一性，应<code>spring.jta.transaction-manager-id</code> 为应用程序的每个实例配置具有不同值的属性。</p></blockquote><h2 id="使用Java-EE托管事务管理器"><a href="#使用Java-EE托管事务管理器" class="headerlink" title="使用Java EE托管事务管理器"></a>使用Java EE托管事务管理器</h2><p>如果将Spring Boot应用程序打包为一个<code>war</code>或一个<code>ear</code>文件并将其部署到Java EE应用程序服务器，则可以使用应用程序服务器的内置事务管理器。Spring Boot尝试通过查看常见的JNDI位置（<code>java:comp/UserTransaction</code>，<code>java:comp/TransactionManager</code>等等）来自动配置事务管理器。如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器管理并通过JNDI公开。Spring Boot尝试通过查找<code>ConnectionFactory</code>JNDI路径（<code>java:/JmsXA</code>或<code>java:/XAConnectionFactory</code>）来自动配置JMS ，您可以使用该 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-connecting-to-a-jndi-datasource" target="_blank" rel="noopener"><code>spring.datasource.jndi-name</code>属性</a> 来配置您的<code>DataSource</code>。</p><h2 id="混合XA和非XA-JMS连接"><a href="#混合XA和非XA-JMS连接" class="headerlink" title="混合XA和非XA JMS连接"></a>混合XA和非XA JMS连接</h2><p>使用JTA时，主JMS <code>ConnectionFactory</code>bean可识别XA并参与分布式事务。在某些情况下，您可能希望使用非XA处理某些JMS消息<code>ConnectionFactory</code>。例如，您的JMS处理逻辑可能需要比XA超时更长的时间。</p><p>如果要使用非XA <code>ConnectionFactory</code>，可以注入 <code>nonXaJmsConnectionFactory</code>bean而不是<code>@Primary</code> <code>jmsConnectionFactory</code>bean。为了保持一致性，<code>jmsConnectionFactory</code>还使用bean别名提供bean <code>xaJmsConnectionFactory</code>。</p><p>以下示例显示了如何注入<code>ConnectionFactory</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注入主（XA感知）ConnectionFactory</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConnectionFactory defaultConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注入XA感知ConnectionFactory（使用别名并注入与上面相同的内容）</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"xaJmsConnectionFactory"</span>)</span><br><span class="line"><span class="keyword">private</span> ConnectionFactory xaConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注入非XA感知的ConnectionFactory</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"nonXaJmsConnectionFactory"</span>)</span><br><span class="line"><span class="keyword">private</span> ConnectionFactory nonXaConnectionFactory;</span><br></pre></td></tr></table></figure><h2 id="支持替代嵌入式事务管理器"><a href="#支持替代嵌入式事务管理器" class="headerlink" title="支持替代嵌入式事务管理器"></a>支持替代嵌入式事务管理器</h2><p>该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.java" target="_blank" rel="noopener"><code>XAConnectionFactoryWrapper</code></a> 和<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java" target="_blank" rel="noopener"><code>XADataSourceWrapper</code></a>接口可用于支持替代嵌入式事务经理。接口负责包装<code>XAConnectionFactory</code>和<code>XADataSource</code>bean，并将它们作为常规<code>ConnectionFactory</code>和<code>DataSource</code>bean 公开，它们透明地注册到分布式事务中。DataSource和JMS自动配置使用JTA变体，前提是您有一个<code>JtaTransactionManager</code>bean和在您的域中注册的相应XA包装bean <code>ApplicationContext</code>。</p><p>该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXAConnectionFactoryWrapper.java" target="_blank" rel="noopener">BitronixXAConnectionFactoryWrapper</a> 和<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXADataSourceWrapper.java" target="_blank" rel="noopener">BitronixXADataSourceWrapper</a> 提供了如何编写XA包装很好的例子。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jta </tag>
            
            <tag> atomikos </tag>
            
            <tag> bitronix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Mail</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Mail/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Mail/</url>
      
        <content type="html"><![CDATA[<h1 id="Sending-Email"><a href="#Sending-Email" class="headerlink" title="Sending Email"></a>Sending Email</h1><p>Spring Framework提供了一个使用<code>JavaMailSender</code>界面发送电子邮件的简单抽象 ，Spring Boot为它提供了自动配置以及启动器模块。</p><blockquote><p>有关如何使用<code>JavaMailSender</code>的详细说明，请参阅<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#mail" target="_blank" rel="noopener">参考文档</a>。</p></blockquote><p>如果<code>spring.mail.host</code>和相关库（由定义的 <code>spring-boot-starter-mail</code>）可用，<code>JavaMailSender</code>则创建默认值（如果不存在）。可以通过<code>spring.mail</code>命名空间中的配置项进一步自定义发送方 。有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java" target="_blank" rel="noopener"><code>MailProperties</code></a>详细信息，请参阅</p><p>特别是，某些默认超时值是无限的，您可能希望更改它以避免线程被无响应的邮件服务器阻塞，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.properties.mail.smtp.connectiontimeout=5000</span><br><span class="line">spring.mail.properties.mail.smtp.timeout=3000</span><br><span class="line">spring.mail.properties.mail.smtp.writetimeout=5000</span><br></pre></td></tr></table></figure><p>也可以<code>JavaMailSender</code>使用<code>Session</code>JNDI中的现有配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.jndi-name=mail/Session</span><br></pre></td></tr></table></figure><p>当<code>jndi-name</code>设置，它优先于所有其他会话相关的设置。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Validation</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Validation/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-Validation/</url>
      
        <content type="html"><![CDATA[<h1 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h1><p>只要JSR-303实现（例如Hibernate验证器）在类路径上，就会自动启用Bean Validation 1.1支持的方法验证功能。这使得bean方法可以使用<code>javax.validation</code>对其参数和/或返回值的约束进行注释。具有此类带注释方法的目标类需要使用<code>@Validated</code>类型级别的注释进行注释，以便搜索其内联约束注释的方法。</p><p>例如，以下服务触发第一个参数的验证，确保其大小在8到10之间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Archive <span class="title">findByCodeAndAuthor</span><span class="params">(@Size(min = <span class="number">8</span>, max = <span class="number">10</span>)</span> String code,</span></span><br><span class="line"><span class="function">Author author) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> validation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-WebClient</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-WebClient/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-WebClient/</url>
      
        <content type="html"><![CDATA[<h1 id="WebClient"><a href="#WebClient" class="headerlink" title="WebClient"></a>WebClient</h1><p>如果在类路径上有Spring WebFlux，则还可以选择<code>WebClient</code>用于调用远程REST服务。相比之下<code>RestTemplate</code>，这个客户端具有更多的功能感并且完全被动。您可以<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client" target="_blank" rel="noopener">在Spring Framework文档</a><code>WebClient</code>的专用 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client" target="_blank" rel="noopener">部分中</a>了解有关该内容的更多信息。</p><p>Spring Boot <code>WebClient.Builder</code>为您创建并预配置一个; 强烈建议将其注入组件并使用它来创建<code>WebClient</code>实例。Spring Boot正在配置该构建器以共享HTTP资源，以与服务器相同的方式反映编解码器设置（请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webflux-httpcodecs" target="_blank" rel="noopener">WebFlux HTTP编解码器自动配置</a>）等。</p><p>以下代码显示了一个典型示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebClient.Builder webClientBuilder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.webClient = webClientBuilder.baseUrl(<span class="string">"http://example.org"</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Details&gt; <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.webClient.get().uri(<span class="string">"/&#123;name&#125;/details"</span>, name)</span><br><span class="line">.retrieve().bodyToMono(Details.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebClient运行时"><a href="#WebClient运行时" class="headerlink" title="WebClient运行时"></a>WebClient运行时</h2><p>Spring Boot将自动检测<code>ClientHttpConnector</code>用于驱动的驱动程序<code>WebClient</code>，具体取决于应用程序类路径上可用的库。目前，支持Reactor Netty和Jetty RS客户端。</p><p>在<code>spring-boot-starter-webflux</code>启动依赖于<code>io.projectreactor.netty:reactor-netty</code> 默认情况下，这使服务器和客户端的实现。如果您选择将Jetty用作反应式服务器，则应该在Jetty Reactive HTTP客户端库上添加依赖项<code>org.eclipse.jetty:jetty-reactive-httpclient</code>。对服务器和客户端使用相同的技术具有优势，因为它将自动在客户端和服务器之间共享HTTP资源。</p><p>开发人员可以通过提供自定义<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>bean 来覆盖Jetty和Reactor Netty的资源配置- 这将应用于客户端和服务器。</p><p>如果您希望覆盖客户端的该选项，则可以定义自己的 <code>ClientHttpConnector</code>bean并完全控制客户端配置。</p><p>您可以<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder" target="_blank" rel="noopener"><code>WebClient</code>在Spring Framework参考文档中</a>了解有关<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder" target="_blank" rel="noopener">配置选项的</a>更多信息 。</p><h2 id="WebClient自定义"><a href="#WebClient自定义" class="headerlink" title="WebClient自定义"></a>WebClient自定义</h2><p><code>WebClient</code>自定义有三种主要方法，具体取决于您希望自定义应用的广泛程度。</p><p>要使任何自定义的范围尽可能窄，请注入自动配置 <code>WebClient.Builder</code>，然后根据需要调用其方法。<code>WebClient.Builder</code>实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有客户端中。如果要使用相同的构建器创建多个客户端，还可以考虑使用克隆构建器<code>WebClient.Builder other = builder.clone();</code>。</p><p>要对所有<code>WebClient.Builder</code>实例进行应用程序范围的附加自定义，您可以声明<code>WebClientCustomizer</code>bean并<code>WebClient.Builder</code>在注入点更改本地。</p><p>最后，您可以回退到原始API并使用<code>WebClient.create()</code>。在这种情况下，不会自动配置或<code>WebClientCustomizer</code>应用。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rest </tag>
            
            <tag> webflux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-RestTemplate</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-RestTemplate/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-RestTemplate/</url>
      
        <content type="html"><![CDATA[<h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p>如果需要从应用程序调用远程REST服务，可以使用Spring Framework的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener"><code>RestTemplate</code></a>类。由于 <code>RestTemplate</code>实例在使用之前通常需要自定义，因此Spring Boot不提供任何单个自动配置的<code>RestTemplate</code>bean。但是，它会自动配置a <code>RestTemplateBuilder</code>，可用于<code>RestTemplate</code> 在需要时创建实例。自动配置<code>RestTemplateBuilder</code>可确保将敏感 <code>HttpMessageConverters</code>应用于<code>RestTemplate</code>实例。</p><p>以下代码显示了一个典型示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Details <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"/&#123;name&#125;/details"</span>, Details.class, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>RestTemplateBuilder</code>包括许多可用于快速配置a的有用方法<code>RestTemplate</code>。例如，要添加BASIC auth支持，您可以使用<code>builder.basicAuthentication(&quot;user&quot;, &quot;password&quot;).build()</code>。</p></blockquote><h2 id="RestTemplate自定义"><a href="#RestTemplate自定义" class="headerlink" title="RestTemplate自定义"></a>RestTemplate自定义</h2><p><code>RestTemplate</code>自定义有三种主要方法，具体取决于您希望自定义应用的广泛程度。</p><p>要使任何自定义的范围尽可能窄，请注入自动配置 <code>RestTemplateBuilder</code>，然后根据需要调用其方法。每个方法调用都返回一个新<code>RestTemplateBuilder</code>实例，因此自定义只会影响构建器的这种使用。</p><p>要进行应用程序范围的附加定制，请使用<code>RestTemplateCustomizer</code>bean。所有这些bean都自动注册自动配置<code>RestTemplateBuilder</code> ，并应用于使用它构建的任何模板。</p><p>以下示例显示了一个自定义程序，它为所有主机配置代理的使用，但<code>192.168.0.5</code>以下情况除外：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">"proxy.example.com"</span>);</span><br><span class="line">HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">.setRoutePlanner(<span class="keyword">new</span> DefaultProxyRoutePlanner(proxy) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpRequest request, HttpContext context)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target.getHostName().equals(<span class="string">"192.168.0.5"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;).build();</span><br><span class="line">restTemplate.setRequestFactory(</span><br><span class="line"><span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，最极端（很少使用）的选项是创建自己的 <code>RestTemplateBuilder</code>bean。这样做会关闭自动配置 的<code>RestTemplateBuilder</code>并阻止使用任何<code>RestTemplateCustomizer</code>bean。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-消息中间件</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h1><p>Spring Framework为与消息传递系统的集成提供了广泛的支持，从简化使用JMS API <code>JmsTemplate</code>到完整的基础架构，以异步接收消息。Spring AMQP为高级消息队列协议提供了类似的功能集。Spring Boot还为<code>RabbitTemplate</code>RabbitMQ 提供了自动配置选项。Spring WebSocket本身包含对STOMP消息传递的支持，Spring Boot通过启动器和少量自动配置支持它。Spring Boot也支持Apache Kafka。</p><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>该<code>javax.jms.ConnectionFactory</code>接口提供了一种创建<code>javax.jms.Connection</code>与JMS代理交互的标准方法 。尽管Spring需要 <code>ConnectionFactory</code>使用JMS，但您通常不需要直接使用它，而是可以依赖于更高级别的消息传递抽象。（有关详细信息，请参阅Spring Framework参考文档的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#jms" target="_blank" rel="noopener">相关部分</a>。）Spring Boot还会自动配置发送和接收消息所需的基础结构。</p><h3 id="ActiveMQ支持"><a href="#ActiveMQ支持" class="headerlink" title="ActiveMQ支持"></a>ActiveMQ支持</h3><p>当<a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ</a>在类路径上可用时，Spring Boot也可以配置a <code>ConnectionFactory</code>。如果代理存在，则会自动启动并配置嵌入式代理（前提是未通过配置指定代理URL）。</p><blockquote><p>如果使用<code>spring-boot-starter-activemq</code>，则提供连接或嵌入ActiveMQ实例的必要依赖项，以及与JMS集成的Spring基础结构。</p></blockquote><p>ActiveMQ配置由外部配置属性控制 <code>spring.activemq.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.broker-url=tcp://192.168.1.210:9876</span><br><span class="line">spring.activemq.user=admin</span><br><span class="line">spring.activemq.password=secret</span><br></pre></td></tr></table></figure><p>默认情况下，使用合理设置<code>CachingConnectionFactory</code>包装本机<code>ConnectionFactory</code>，您可以通过以下方式控制外部配置属性 <code>spring.jms.*</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.cache.session-cache-size=5</span><br></pre></td></tr></table></figure><p>如果您更愿意使用本机池，则可以通过向相应位置添加依赖关系 <code>org.messaginghub:pooled-jms</code>并进行相应配置来实现<code>JmsPoolConnectionFactory</code>，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.pool.enabled=true</span><br><span class="line">spring.activemq.pool.max-connections=50</span><br></pre></td></tr></table></figure><blockquote><p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java" target="_blank" rel="noopener"><code>ActiveMQProperties</code></a> 更多支持的选项，请参阅 。您还可以注册任意数量的bean，以实现<code>ActiveMQConnectionFactoryCustomizer</code>更高级的自定义。</p></blockquote><p>默认情况下，ActiveMQ会创建一个目标（如果它尚不存在），以便根据提供的名称解析目标。</p><h3 id="Artemis-Support"><a href="#Artemis-Support" class="headerlink" title="Artemis Support"></a>Artemis Support</h3><p>Spring Boot可以<code>ConnectionFactory</code>在检测到<a href="http://activemq.apache.org/artemis/" target="_blank" rel="noopener">Artemis</a>在类路径上可用时 自动配置。如果代理存在，则会自动启动并配置嵌入式代理（除非已明确设置mode属性）。支持的模式是<code>embedded</code>（明确表示需要嵌入式代理，如果代理在类路径上不可用则发生错误）和<code>native</code>（使用<code>netty</code> 传输协议连接到代理）。配置后者后，Spring Boot会<code>ConnectionFactory</code>使用默认设置配置 连接到本地计算机上运行的代理的连接。</p><blockquote><p>如果使用<code>spring-boot-starter-artemis</code>，则提供连接到现有Artemis实例的必要依赖项，以及与JMS集成的Spring基础结构。添加<code>org.apache.activemq:artemis-jms-server</code>到您的应用程序可让您使用嵌入模式。</p></blockquote><p>Artemis配置由外部配置属性控制 <code>spring.artemis.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.artemis.mode=native</span><br><span class="line">spring.artemis.host=192.168.1.210</span><br><span class="line">spring.artemis.port=9876</span><br><span class="line">spring.artemis.user=admin</span><br><span class="line">spring.artemis.password=secret</span><br></pre></td></tr></table></figure><p>嵌入代理时，您可以选择是否要启用持久性并列出应该可用的目标。这些可以指定为以逗号分隔的列表，使用默认选项创建它们，或者您可以分别为高级队列和主题配置定义类型的bean <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code>或<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>。</p><p>默认情况下，使用合理设置<code>CachingConnectionFactory</code>包装本机<code>ConnectionFactory</code>，您可以通过以下方式控制外部配置属性 <code>spring.jms.*</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.cache.session-cache-size=5</span><br></pre></td></tr></table></figure><p>如果您更愿意使用本机池，则可以通过向相应位置添加依赖关系 <code>org.messaginghub:pooled-jms</code>并进行相应配置来实现<code>JmsPoolConnectionFactory</code>，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.artemis.pool.enabled=true</span><br><span class="line">spring.artemis.pool.max-connections=50</span><br></pre></td></tr></table></figure><p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java" target="_blank" rel="noopener"><code>ArtemisProperties</code></a> 更多支持选项，请参阅</p><p>不涉及JNDI查找，并使用<code>name</code>Artemis配置中的属性或通过配置提供的名称来解析目标名称。</p><h3 id="使用JNDI-ConnectionFactory"><a href="#使用JNDI-ConnectionFactory" class="headerlink" title="使用JNDI ConnectionFactory"></a>使用JNDI ConnectionFactory</h3><p>如果您在应用程序服务器中运行应用程序，Spring Boot会尝试<code>ConnectionFactory</code>使用JNDI 查找JMS 。默认情况下，将检查<code>java:/JmsXA</code>和<code>java:/XAConnectionFactory</code>位置。<code>spring.jms.jndi-name</code> 如果需要指定备用位置，可以使用该属性，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.jndi-name=java:/MyConnectionFactory</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring <code>JmsTemplate</code>是自动配置的，你可以直接将它自动装入自己的bean中，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JmsTemplate jmsTemplate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.jmsTemplate = jmsTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html" target="_blank" rel="noopener"><code>JmsMessagingTemplate</code></a>可以以类似的方式注射。如果定义了一个<code>DestinationResolver</code>或一个<code>MessageConverter</code>bean，它将自动关联到自动配置<code>JmsTemplate</code>。</p></blockquote><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>当存在JMS基础结构时，可以使用任何bean来注释<code>@JmsListener</code>以创建侦听器端点。如果<code>JmsListenerContainerFactory</code>未定义，则自动配置默认值。如果定义了一个<code>DestinationResolver</code>或一个 <code>MessageConverter</code>bean，它将自动关联到默认工厂。</p><p>默认情况下，默认工厂是事务性的。如果您在<code>JtaTransactionManager</code>存在a的基础结构中运行 ，则默认情况下它与侦听器容器相关联。如果不是，<code>sessionTransacted</code>则启用该标志。在后一种情况下，您可以通过添加<code>@Transactional</code>侦听器方法（或其委托）将本地数据存储事务与传入消息的处理相关联。这确保了在本地事务完成后确认传入消息。这还包括发送已在同一JMS会话上执行的响应消息。</p><p>以下组件在<code>someQueue</code>目标上创建侦听器端点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JmsListener</span>(destination = <span class="string">"someQueue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有关 更多详细信息，请参阅<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/jms/annotation/EnableJms.html" target="_blank" rel="noopener">Javadoc<code>@EnableJms</code></a>。</p></blockquote><p>如果您需要创建更多<code>JmsListenerContainerFactory</code>实例，或者如果要覆盖默认实例，则Spring Boot提供了一个<code>DefaultJmsListenerContainerFactoryConfigurer</code>可用于初始化a <code>DefaultJmsListenerContainerFactory</code>的设置，其设置与自动配置的设置相同。</p><p>例如，以下示例公开了另一个使用特定工厂的工厂 <code>MessageConverter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">DefaultJmsListenerContainerFactory factory =</span><br><span class="line"><span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">configurer.configure(factory, connectionFactory());</span><br><span class="line">factory.setMessageConverter(myMessageConverter());</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后您可以在任何<code>@JmsListener</code>注释方法中使用工厂，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JmsListener</span>(destination = <span class="string">"someQueue"</span>, containerFactory=<span class="string">"myFactory"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>高级消息队列协议（AMQP）是面向消息的中间件的平台中立的线级协议。Spring AMQP项目将核心Spring概念应用于基于AMQP的消息传递解决方案的开发。Spring Boot提供了几种通过RabbitMQ使用AMQP的便利，包括<code>spring-boot-starter-amqp</code> “Starter”。</p><h3 id="RabbitMQ支持"><a href="#RabbitMQ支持" class="headerlink" title="RabbitMQ支持"></a>RabbitMQ支持</h3><p><a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>是一个基于AMQP协议的轻量级，可靠，可扩展且可移植的消息代理。Spring用于<code>RabbitMQ</code>通过AMQP协议进行通信。</p><p>RabbitMQ配置由外部配置属性控制 <code>spring.rabbitmq.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=secret</span><br></pre></td></tr></table></figure><p>如果<code>ConnectionNameStrategy</code>上下文中存在bean，则它将自动用于命名由自动配置创建的连接<code>ConnectionFactory</code>。有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java" target="_blank" rel="noopener"><code>RabbitProperties</code></a>更多支持的选项，请参阅 。</p><blockquote><p>有关详细信息<a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/" target="_blank" rel="noopener">，</a>请参阅 <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/" target="_blank" rel="noopener">了解RabbitQQ使用的协议AMQP</a>。</p></blockquote><h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring的<code>AmqpTemplate</code>和<code>AmqpAdmin</code>被自动配置，您可以直接自动装配它们变成自己的豆类，如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AmqpAdmin amqpAdmin;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.amqpAdmin = amqpAdmin;</span><br><span class="line"><span class="keyword">this</span>.amqpTemplate = amqpTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html" target="_blank" rel="noopener"><code>RabbitMessagingTemplate</code></a> 可以以类似的方式注射。如果<code>MessageConverter</code>定义了bean，它将自动关联到自动配置<code>AmqpTemplate</code>。</p></blockquote><p>如有必要，任何<code>org.springframework.amqp.core.Queue</code>定义为bean的都会自动用于在RabbitMQ实例上声明相应的队列。</p><p>要重试操作，可以启用重试<code>AmqpTemplate</code>（例如，在代理连接丢失的情况下）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.template.retry.enabled=true</span><br><span class="line">spring.rabbitmq.template.retry.initial-interval=2s</span><br></pre></td></tr></table></figure><p>默认情况下禁用重试。您还可以<code>RetryTemplate</code> 通过声明<code>RabbitRetryTemplateCustomizer</code>bean来以编程方式自定义。</p><h3 id="接收消息-1"><a href="#接收消息-1" class="headerlink" title="接收消息"></a>接收消息</h3><p>当Rabbit基础结构存在时，可以使用任何bean来注释 <code>@RabbitListener</code>以创建侦听器端点。如果<code>RabbitListenerContainerFactory</code> 未定义，<code>SimpleRabbitListenerContainerFactory</code>则会自动配置默认值，您可以使用该<code>spring.rabbitmq.listener.type</code>属性切换到直接容器 。如果 定义了a <code>MessageConverter</code>或<code>MessageRecoverer</code>bean，它将自动与默认工厂关联。</p><p>以下示例组件在<code>someQueue</code>队列上创建侦听器端点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"someQueue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html" target="_blank" rel="noopener">Javadoc <code>@EnableRabbit</code></a>。</p></blockquote><p>如果您需要创建更多<code>RabbitListenerContainerFactory</code>实例，或者如果要覆盖默认实例，Spring Boot提供了一个<code>SimpleRabbitListenerContainerFactoryConfigurer</code>和一个 <code>DirectRabbitListenerContainerFactoryConfigurer</code>可用于初始化a<code>SimpleRabbitListenerContainerFactory</code>和a <code>DirectRabbitListenerContainerFactory</code>的设置，其设置与自动配置使用的工厂相同。</p><blockquote><p>您选择的容器类型无关紧要。这两个bean通过自动配置公开。</p></blockquote><p>例如，以下配置类公开了另一个使用特定的工厂<code>MessageConverter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">SimpleRabbitListenerContainerFactory factory =</span><br><span class="line"><span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">configurer.configure(factory, connectionFactory);</span><br><span class="line">factory.setMessageConverter(myMessageConverter());</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后您可以在任何<code>@RabbitListener</code>注释方法中使用工厂，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"someQueue"</span>, containerFactory=<span class="string">"myFactory"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以启用重试来处理侦听器抛出异常的情况。默认<code>RejectAndDontRequeueRecoverer</code>使用，但您可以定义<code>MessageRecoverer</code> 自己的。当重试耗尽时，如果代理配置了这样做，则拒绝该消息并将其丢弃或路由到死信交换。默认情况下，禁用重试。您还可以<code>RetryTemplate</code>通过声明<code>RabbitRetryTemplateCustomizer</code>bean来以编程方式自定义。</p><blockquote><p><strong>重要:</strong></p><p>默认情况下，如果禁用重试并且侦听器抛出异常，则会无限期地重试传递。您可以通过两种方式修改此行为：将<code>defaultRequeueRejected</code>属性设置为<code>false</code>以便尝试零重新传递，或者抛出一个<code>AmqpRejectAndDontRequeueException</code>信号来表示应该拒绝该消息。后者是启用重试并且达到最大传递尝试次数时使用的机制。</p></blockquote><h2 id="Apache-Kafka支持"><a href="#Apache-Kafka支持" class="headerlink" title="Apache Kafka支持"></a>Apache Kafka支持</h2><p>通过提供<code>spring-kafka</code>项目的自动配置来支持<a href="https://kafka.apache.org/" target="_blank" rel="noopener">Apache Kafka</a>。</p><p>Kafka配置由外部配置属性控制 <code>spring.kafka.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.bootstrap-servers=localhost:9092</span><br><span class="line">spring.kafka.consumer.group-id=myGroup</span><br></pre></td></tr></table></figure><blockquote><p>要在启动时创建主题，请添加类型的bean <code>NewTopic</code>。如果主题已存在，则忽略该bean。</p></blockquote><p>有关更多支持选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java" target="_blank" rel="noopener"><code>KafkaProperties</code></a> </p><h3 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring <code>KafkaTemplate</code>是自动配置的，您可以直接在自己的bean中自动装配它，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(KafkaTemplate kafkaTemplate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果<code>spring.kafka.producer.transaction-id-prefix</code>定义了属性， <code>KafkaTransactionManager</code>则会自动配置a。此外，如果<code>RecordMessageConverter</code> 定义了bean，它将自动与自动配置相关联<code>KafkaTemplate</code>。</p></blockquote><h3 id="接收消息-2"><a href="#接收消息-2" class="headerlink" title="接收消息"></a>接收消息</h3><p>当存在Apache Kafka基础结构时，可以使用任何bean来注释 <code>@KafkaListener</code>以创建侦听器端点。如果<code>KafkaListenerContainerFactory</code>未定义，则使用定义的键自动配置默认值 <code>spring.kafka.listener.*</code>。</p><p>以下组件在<code>someTopic</code>主题上创建侦听器端点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@KafkaListener</span>(topics = <span class="string">"someTopic"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>KafkaTransactionManager</code>定义了bean，它将自动关联到容器工厂。类似地，如果一个<code>RecordMessageConverter</code>，<code>ErrorHandler</code>或<code>AfterRollbackProcessor</code>豆被定义，它被自动关联为出厂默认。</p><blockquote><p><code>ChainedKafkaTransactionManager</code>必须标记自定义，<code>@Primary</code>因为它通常引用自动配置的<code>KafkaTransactionManager</code>bean。</p></blockquote><h3 id="Kafka-Streams"><a href="#Kafka-Streams" class="headerlink" title="Kafka Streams"></a>Kafka Streams</h3><p>Spring for Apache Kafka提供了一个工厂bean来创建一个<code>StreamsBuilder</code>对象并管理其流的生命周期。Spring Boot会自动配置所需的<code>KafkaStreamsConfiguration</code>bean，只要<code>kafka-streams</code>在类路径上，并通过<code>@EnableKafkaStreams</code>注释启用Kafka Streams 。</p><p>启用Kafka Streams意味着必须设置应用程序ID和引导服务器。前者可以使用配置<code>spring.kafka.streams.application-id</code>，<code>spring.application.name</code>如果没有设置则默认为默认 值。后者可以全局设置或专门为流而重写。</p><p>使用专用属性可以使用其他几个属性; 可以使用<code>spring.kafka.streams.properties</code>命名空间设置其他任意Kafka属性。有关更多信息<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-kafka-extra-props" target="_blank" rel="noopener">，</a>另请参见<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-kafka-extra-props" target="_blank" rel="noopener">第34.3.4节“其他Kafka属性”</a>。</p><p>要使用工厂bean，只需连接<code>StreamsBuilder</code>到您的bean，<code>@Bean</code>如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableKafkaStreams</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaStreamsExampleConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> KStream&lt;Integer, String&gt; <span class="title">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span> </span>&#123;</span><br><span class="line">KStream&lt;Integer, String&gt; stream = streamsBuilder.stream(<span class="string">"ks1In"</span>);</span><br><span class="line">stream.map((k, v) -&gt; <span class="keyword">new</span> KeyValue&lt;&gt;(k, v.toUpperCase())).to(<span class="string">"ks1Out"</span>,</span><br><span class="line">Produced.with(Serdes.Integer(), <span class="keyword">new</span> JsonSerde&lt;&gt;()));</span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，由其<code>StreamBuilder</code>创建的对象管理的流将自动启动。您可以使用该<code>spring.kafka.streams.auto-startup</code>属性自定义此行为 。</p><h3 id="附加Kafka属性"><a href="#附加Kafka属性" class="headerlink" title="附加Kafka属性"></a>附加Kafka属性</h3><p>自动配置支持的属性显示在 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">附录A，<em>常见应用程序属性中</em></a>。请注意，在大多数情况下，这些属性（连字符或camelCase）直接映射到Apache Kafka点状属性。有关详细信息，请参阅Apache Kafka文档。</p><p>这些属性中的前几个适用于所有组件（生产者，使用者，管理员和流），但如果您希望使用不同的值，则可以在组件级别指定。Apache Kafka指定重要性为HIGH，MEDIUM或LOW的属性。Spring Boot自动配置支持所有HIGH重要性属性，一些选定的MEDIUM和LOW属性，以及任何没有默认值的属性。</p><p>只有Kafka支持的属性的一部分可以直接通过 <code>KafkaProperties</code>该类获得。如果您希望使用不直接支持的其他属性配置生产者或使用者，请使用以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.properties.prop.one=first</span><br><span class="line">spring.kafka.admin.properties.prop.two=second</span><br><span class="line">spring.kafka.consumer.properties.prop.three=third</span><br><span class="line">spring.kafka.producer.properties.prop.four=fourth</span><br><span class="line">spring.kafka.streams.properties.prop.five=fifth</span><br></pre></td></tr></table></figure><p>这将常见的<code>prop.one</code>Kafka属性设置为<code>first</code>（适用于生产者，使用者和管理员），<code>prop.two</code>admin属性<code>second</code>，<code>prop.three</code> 使用者属性<code>third</code>，<code>prop.four</code>生产者属性<code>fourth</code>和 <code>prop.five</code>streams属性<code>fifth</code>。</p><p>您还可以<code>JsonDeserializer</code>按如下方式配置Spring Kafka ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer</span><br><span class="line">spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice</span><br><span class="line">spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme</span><br></pre></td></tr></table></figure><p>同样，您可以禁用<code>JsonSerializer</code>在标头中发送类型信息的默认行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer</span><br><span class="line">spring.kafka.producer.properties.spring.json.add.type.headers=false</span><br></pre></td></tr></table></figure><blockquote><p><strong>重要</strong>：</p><p>以这种方式设置的属性将覆盖Spring Boot明确支持的任何配置项。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jms </tag>
            
            <tag> amqp </tag>
            
            <tag> rabbitmq </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-cache</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-cache/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>Spring Framework支持透明地向应用程序添加缓存。从本质上讲，抽象将缓存应用于方法，从而根据缓存中可用的信息减少执行次数。缓存逻辑是透明应用的，不会对调用者造成任何干扰。只要通过<code>@EnableCaching</code> 注释启用了缓存支持，Spring Boot就会自动配置缓存基础结构。</p><blockquote><p><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache" target="_blank" rel="noopener">有关</a>更多详细信息，请查看Spring Framework参考的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache" target="_blank" rel="noopener">相关部分</a>。</p></blockquote><p>简而言之，将缓存添加到服务操作就像在其方法中添加相关注释一样简单，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Cacheable</span>(<span class="string">"piDecimals"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computePiDecimal</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例演示了如何在可能代价高昂的操作上使用缓存。在调用之前<code>computePiDecimal</code>，抽象会在<code>piDecimals</code>缓存中查找与<code>i</code>参数匹配的条目。如果找到条目，则缓存中的内容会立即返回给调用者，并且不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。</p><blockquote><p>您还可以<code>@CacheResult</code>透明地使用标准JSR-107（JCache）注释（例如 ）。但是，我们强烈建议您不要混淆和匹配Spring Cache和JCache注释。</p></blockquote><p>如果您不添加任何特定的缓存库，Spring Boot会自动配置一个在内存中使用并发映射的 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-simple" target="_blank" rel="noopener">简单提供程序</a>。当需要缓存时（例如<code>piDecimals</code>在前面的示例中），此提供程序会为您创建缓存。简单的提供程序并不是真正推荐用于生产用途，但它非常适合入门并确保您了解这些功能。当您决定使用缓存提供程序时，请务必阅读其文档以了解如何配置应用程序使用的缓存。几乎所有提供程序都要求您显式配置在应用程序中使用的每个缓存。有些提供了一种自定义<code>spring.cache.cache-names</code>属性定义的默认缓存的方法。</p><blockquote><p>还可以透明地 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache-annotations-put" target="_blank" rel="noopener">更新</a>或 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache-annotations-evict" target="_blank" rel="noopener">逐出</a>缓存中的数据。</p></blockquote><h2 id="支持的缓存提供程序"><a href="#支持的缓存提供程序" class="headerlink" title="支持的缓存提供程序"></a>支持的缓存提供程序</h2><p>缓存抽象不提供实际存储，而是依赖于<code>org.springframework.cache.Cache</code>和 <code>org.springframework.cache.CacheManager</code>接口实现的抽象。</p><p>如果尚未定义类型的bean <code>CacheManager</code>或<code>CacheResolver</code>命名 的bean <code>cacheResolver</code>（请参阅参考资料 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html" target="_blank" rel="noopener"><code>CachingConfigurer</code></a>），Spring Boot会尝试检测以下提供程序（按指示的顺序）：</p><ol><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-generic" target="_blank" rel="noopener">Generic</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-jcache" target="_blank" rel="noopener">JCache（JSR-107）</a>（EhCache 3，Hazelcast，Infinispan等）</li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-ehcache2" target="_blank" rel="noopener">EhCache 2.x</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-hazelcast" target="_blank" rel="noopener">Hazelcast</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-infinispan" target="_blank" rel="noopener">Infinispan</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-couchbase" target="_blank" rel="noopener">Couchbase</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-redis" target="_blank" rel="noopener">Redis</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-caffeine" target="_blank" rel="noopener">Caffeine</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-simple" target="_blank" rel="noopener">Simple</a></li></ol><blockquote><p>也可以通过设置属性来<em>强制</em>特定的缓存提供程序 <code>spring.cache.type</code>。如果您需要在某些环境（例如测试）中<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-none" target="_blank" rel="noopener">完全禁用缓存，</a>请使用此属性 。</p></blockquote><blockquote><p>使用<code>spring-boot-starter-cache</code>“Starter”快速添加基本缓存依赖项。首发引入<code>spring-context-support</code>。如果手动添加依赖项，则必须包括<code>spring-context-support</code>才能使用JCache，EhCache 2.x或Guava支持。</p></blockquote><p>如果<code>CacheManager</code>由Spring Boot自动配置，则可以通过公开实现该<code>CacheManagerCustomizer</code>接口的bean完全初始化之前进一步调整其配置 。以下示例设置一个标志，表示应将null值传递给底层映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConcurrentMapCacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">cacheManager.setAllowNullValues(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在前面的示例中，<code>ConcurrentMapCacheManager</code>预期会自动配置。如果不是这种情况（您提供了自己的配置或自动配置了不同的缓存提供程序），则根本不会调用自定义程序。您可以拥有任意数量的自定义程序，也可以使用<code>@Order</code>或订购它们<code>Ordered</code>。</p></blockquote><h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><p>如果上下文定义<em>至少</em>一个 <code>org.springframework.cache.Cache</code>bean，则使用通用高速缓存。将<code>CacheManager</code>创建包装该类型的所有bean。</p><h3 id="JCache（JSR-107）"><a href="#JCache（JSR-107）" class="headerlink" title="JCache（JSR-107）"></a>JCache（JSR-107）</h3><p><a href="https://jcp.org/en/jsr/detail?id=107" target="_blank" rel="noopener">JCache</a>通过<code>javax.cache.spi.CachingProvider</code>类路径上的存在（即类路径上存在符合JSR-107的缓存库）进行引导 ，<code>JCacheCacheManager</code>并由<code>spring-boot-starter-cache</code>“Starter”提供。可以使用各种兼容库，Spring Boot为Ehcache 3，Hazelcast和Infinispan提供依赖管理。还可以添加任何其他兼容库。</p><p>可能会出现多个提供程序，在这种情况下，必须明确指定提供程序。即使JSR-107标准没有强制执行定义配置文件位置的标准化方法，Spring Boot也会尽力满足设置缓存的实现细节，如下例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   #仅在存在多个提供程序时才需要</span><br><span class="line">spring.cache.jcache.provider=com.acme.MyCachingProvider</span><br><span class="line">spring.cache.jcache.config=classpath:acme.xml</span><br></pre></td></tr></table></figure><blockquote><p>当缓存库同时提供本机实现和JSR-107支持时，Spring Boot更喜欢JSR-107支持，因此如果切换到不同的JSR-107实现，则可以使用相同的功能。</p></blockquote><blockquote><p>Spring Boot <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">对Hazelcast</a>有<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">一般支持</a>。如果单个<code>HazelcastInstance</code>可用，则<code>CacheManager</code>除非<code>spring.cache.jcache.config</code>指定了属性，否则它也会自动重复使用 。</p></blockquote><p>有两种方法可以自定义底层<code>javax.cache.cacheManager</code>：</p><ul><li>可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存。如果定义了自定义<code>javax.cache.configuration.Configuration</code>bean，则会使用它来自定义它们。</li><li><code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code>使用<code>CacheManager</code>for完全自定义的引用调用bean 。</li></ul><blockquote><p>如果<code>javax.cache.CacheManager</code>定义了标准bean，它将自动包装在<code>org.springframework.cache.CacheManager</code>抽象所期望的实现中。没有进一步的自定义。</p></blockquote><h3 id="EhCache-2-x"><a href="#EhCache-2-x" class="headerlink" title="EhCache 2.x"></a>EhCache 2.x</h3><p>如果<code>ehcache.xml</code>可以在类路径的根目录中找到名为的文件，则使用<a href="http://www.ehcache.org/" target="_blank" rel="noopener">EhCache 2.x. </a>如果找到EhCache 2.x，则使用“Starter” <code>EhCacheCacheManager</code>提供的<code>spring-boot-starter-cache</code>引导缓存管理器。还可以提供备用配置文件，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.ehcache.config=classpath:config/another-config.xml</span><br></pre></td></tr></table></figure><h3 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h3><p>Spring Boot <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">对Hazelcast</a>有<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">一般支持</a>。如果a <code>HazelcastInstance</code>已自动配置，则会自动包装在a中 <code>CacheManager</code>。</p><h3 id="Infinispan"><a href="#Infinispan" class="headerlink" title="Infinispan"></a>Infinispan</h3><p><a href="http://infinispan.org/" target="_blank" rel="noopener">Infinispan</a>没有默认配置文件位置，因此必须明确指定。否则，使用默认引导程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.infinispan.config=infinispan.xml</span><br></pre></td></tr></table></figure><p>可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存。如果定义了自定义<code>ConfigurationBuilder</code>bean，则它用于自定义缓存。</p><blockquote><p>Infinispan在Spring Boot中的支持仅限于嵌入式模式，非常基础。如果你想要更多选项，你应该使用官方的Infinispan Spring Boot启动器。有关更多详细信息，请参阅 <a href="https://github.com/infinispan/infinispan-spring-boot" target="_blank" rel="noopener">Infinispan的文档</a>。</p></blockquote><h3 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h3><p>如果<a href="https://www.couchbase.com/" target="_blank" rel="noopener">Couchbase</a> Java客户端和<code>couchbase-spring-cache</code> 实现可用且<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-couchbase" target="_blank" rel="noopener">配置</a>了Couchbase ， <code>CouchbaseCacheManager</code>则会自动配置a。也可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存。这些缓存在<code>Bucket</code>自动配置的情况下运行。您可以<em>还</em>创建另一个附加缓存中<code>Bucket</code>，通过使用定制。假设在“main” 和one（）缓存上需要两个缓存（<code>cache1</code>和 <code>cache2</code>），<code>Bucket</code>并且<code>cache3</code>“另一个”上的自定义时间为2秒<code>Bucket</code>。您可以通过配置创建前两个缓存，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br></pre></td></tr></table></figure><p>然后，您可以定义一个<code>@Configuration</code>类来配置额外<code>Bucket</code>和 <code>cache3</code>缓存，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouchbaseCacheConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cluster cluster;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CouchbaseCacheConfiguration</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bucket <span class="title">anotherBucket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.cluster.openBucket(<span class="string">"another"</span>, <span class="string">"secret"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;CouchbaseCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> c -&gt; &#123;</span><br><span class="line">c.prepareCache(<span class="string">"cache3"</span>, CacheBuilder.newInstance(anotherBucket())</span><br><span class="line">.withExpiration(<span class="number">2</span>));</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例配置重用<code>Cluster</code>通过自动配置创建的配置。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>如果<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>可用且已配置，<code>RedisCacheManager</code>则会自动配置。可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存， 并可以使用<code>spring.cache.redis.*</code>属性配置缓存默认值 。例如，以下配置创建 <code>cache1</code>并<code>cache2</code>缓存10分钟的<em>生存</em>时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br><span class="line">spring.cache.redis.time-to-live=600000</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，会添加一个键前缀，这样，如果两个单独的缓存使用相同的键，则Redis没有重叠键，也不能返回无效值。如果您创建自己的设置，我们强烈建议您启用此设置<code>RedisCacheManager</code>。</p></blockquote><blockquote><p>您可以通过添加<code>RedisCacheConfiguration</code> <code>@Bean</code>自己的配置来完全控制配置。如果您正在寻找自定义序列化策略，这可能很有用。</p></blockquote><h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><p><a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">Caffeine</a>是Java 8重写的Guava缓存，取代了对Guava的支持。如果存在Caffeine，则自动配置一个 <code>CaffeineCacheManager</code>（由<code>spring-boot-starter-cache</code>启动器提供）。可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存，并且可以通过以下之一（按指示的顺序）自定义缓存：</p><ol><li>由…定义的缓存规范 <code>spring.cache.caffeine.spec</code></li><li><code>com.github.benmanes.caffeine.cache.CaffeineSpec</code>定义了一个bean</li><li><code>com.github.benmanes.caffeine.cache.Caffeine</code>定义了一个bean</li></ol><p>例如，以下配置创建<code>cache1</code>和<code>cache2</code>缓存，最大大小为500，<em>生存时间为</em> 10分钟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br><span class="line">spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s</span><br></pre></td></tr></table></figure><p>如果<code>com.github.benmanes.caffeine.cache.CacheLoader</code>定义了bean，它将自动关联到<code>CaffeineCacheManager</code>。由于<code>CacheLoader</code>它将与缓存管理器管理的<em>所有</em>缓存相关联，因此必须将其定义为 <code>CacheLoader&lt;Object, Object&gt;</code>。自动配置忽略任何其他泛型类型。</p><h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>如果找不到其他提供程序，<code>ConcurrentHashMap</code>则配置使用一个作为缓存存储的简单实现 。如果应用程序中不存在缓存库，则这是默认值。默认情况下，会根据需要创建缓存，但您可以通过设置<code>cache-names</code>属性来限制可用缓存列表。例如，如果只需要<code>cache1</code>和<code>cache2</code>缓存，请<code>cache-names</code>按如下方式设置属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br></pre></td></tr></table></figure><p>如果这样做并且您的应用程序使用未列出的缓存，则在需要缓存时它会在运行时失败，但在启动时则不会。这类似于“真实”缓存提供程序在使用未声明的缓存时的行为方式。</p><h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>如果<code>@EnableCaching</code>配置中存在，则还需要合适的缓存配置。如果需要在某些环境中完全禁用缓存，请强制缓存类型<code>none</code>使用no-op实现，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.type=none</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-NoSQL数据库</title>
      <link href="/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/03/21/%E4%BD%BF%E7%94%A8SpringBoot-NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="NoSQL-Technologies"><a href="#NoSQL-Technologies" class="headerlink" title="NoSQL Technologies"></a>NoSQL Technologies</h1><p>Spring Data提供了其他项目，可帮助您访问各种NoSQL技术，包括： <a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">MongoDB</a>， <a href="https://projects.spring.io/spring-data-neo4j/" target="_blank" rel="noopener">Neo4J</a>， <a href="https://github.com/spring-projects/spring-data-elasticsearch/" target="_blank" rel="noopener">Elasticsearch</a>， <a href="https://projects.spring.io/spring-data-solr/" target="_blank" rel="noopener">Solr</a>， <a href="https://projects.spring.io/spring-data-redis/" target="_blank" rel="noopener">Redis</a>， <a href="https://projects.spring.io/spring-data-gemfire/" target="_blank" rel="noopener">Gemfire</a>， <a href="https://projects.spring.io/spring-data-cassandra/" target="_blank" rel="noopener">Cassandra</a>， <a href="https://projects.spring.io/spring-data-couchbase/" target="_blank" rel="noopener">Couchbase</a>和<a href="https://projects.spring.io/spring-data-ldap/" target="_blank" rel="noopener">LDAP</a>。Spring Boot为Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase和LDAP提供自动配置。您可以使用其他项目，但必须自己配置它们。请参阅<a href="https://projects.spring.io/spring-data" target="_blank" rel="noopener">projects.spring.io/spring-data</a>上的相应参考文档 。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>是一个缓存，消息代理和功能丰富的键值存储。Spring Boot为<a href="https://github.com/lettuce-io/lettuce-core/" target="_blank" rel="noopener">Lettuce</a>和 <a href="https://github.com/xetorthio/jedis/" target="_blank" rel="noopener">Jedis</a>客户端库提供了基本的自动配置， 并为<a href="https://github.com/spring-projects/spring-data-redis" target="_blank" rel="noopener">Spring Data Redis</a>提供了它们之外的抽象。</p><p>有一个<code>spring-boot-starter-data-redis</code>“Starter”用于以方便的方式收集依赖项。默认情况下，它使用 <a href="https://github.com/lettuce-io/lettuce-core/" target="_blank" rel="noopener">Lettuce</a>。该启动器处理传统和反应应用程序。</p><blockquote><p>我们还提供一个<code>spring-boot-starter-data-redis-reactive</code>启动器，以便与其他具有反应支持的商店保持一致。</p></blockquote><h3 id="连接到Redis"><a href="#连接到Redis" class="headerlink" title="连接到Redis"></a>连接到Redis</h3><p>你可以注入的自动配置<code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code>或香草<code>RedisTemplate</code>，就像任何其他的Spring Bean实例。默认情况下，实例尝试连接到Redis服务器<code>localhost:6379</code>。以下清单显示了这样一个bean的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.template = template;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>您还可以注册任意数量的bean，以实现 <code>LettuceClientConfigurationBuilderCustomizer</code>更高级的自定义。如果您使用Jedis，<code>JedisClientConfigurationBuilderCustomizer</code>也可以使用。</p></blockquote><p>如果您添加自己<code>@Bean</code>的任何自动配置类型，它将替换默认值（除非在<code>RedisTemplate</code>排除基于bean名称时 <code>redisTemplate</code>，而不是其类型）。默认情况下，如果<code>commons-pool2</code>在类路径上，则会获得池化连接工厂。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p><a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB</a>是一个开源的NoSQL文档数据库，它使用类似JSON的模式而不是传统的基于表的关系数据。Spring Boot提供了一些使用MongoDB的便利，包括<code>spring-boot-starter-data-mongodb</code>和<code>spring-boot-starter-data-mongodb-reactive</code> 启动器。</p><h3 id="连接到MongoDB数据库"><a href="#连接到MongoDB数据库" class="headerlink" title="连接到MongoDB数据库"></a>连接到MongoDB数据库</h3><p>要访问Mongo数据库，可以注入自动配置 <code>org.springframework.data.mongodb.MongoDbFactory</code>。默认情况下，实例尝试连接到MongoDB服务器<code>mongodb://localhost/test</code>。以下示例显示如何连接到MongoDB数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.MongoDbFactory;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.DB;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MongoDbFactory mongo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoDbFactory mongo)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mongo = mongo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DB db = mongo.getDb();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以设置该<code>spring.data.mongodb.uri</code>属性以更改URL并配置其他设置，例如<em>副本集</em>，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</span><br></pre></td></tr></table></figure><p>或者，只要您使用Mongo 2.x，就可以指定<code>host</code>/ <code>port</code>。例如，您可以在以下内容中声明以下设置<code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.host=mongoserver</span><br><span class="line">spring.data.mongodb.port=27017</span><br></pre></td></tr></table></figure><p>如果您已经定义了自己的<code>MongoClient</code>，它将用于自动配置合适的 <code>MongoDbFactory</code>。这两个<code>com.mongodb.MongoClient</code>和<code>com.mongodb.client.MongoClient</code> 支持。</p><blockquote><p>如果使用蒙戈3.0 Java驱动程序，<code>spring.data.mongodb.host</code>并且 <code>spring.data.mongodb.port</code>不支持。在这种情况下，<code>spring.data.mongodb.uri</code> 应该用于提供所有配置。</p></blockquote><blockquote><p>如果<code>spring.data.mongodb.port</code>未指定，<code>27017</code>则使用默认值。您可以从前面显示的示例中删除此行。</p></blockquote><blockquote><p>如果您不使用Spring Data Mongo，则可以注入<code>com.mongodb.MongoClient</code>bean而不是使用<code>MongoDbFactory</code>。如果要完全控制建立MongoDB连接，还可以声明自己的 bean <code>MongoDbFactory</code>或<code>MongoClient</code>bean。</p></blockquote><blockquote><p>如果您使用的是反应式驱动程序，则SSL需要Netty。如果Netty可用并且尚未自定义要使用的工厂，则自动配置会自动配置此工厂。</p></blockquote><h3 id="MongoTemplate"><a href="#MongoTemplate" class="headerlink" title="MongoTemplate"></a>MongoTemplate</h3><p><a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">Spring Data MongoDB</a>提供了一个<a href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoTemplate.html" target="_blank" rel="noopener"><code>MongoTemplate</code></a>与Spring的设计非常相似的 类<code>JdbcTemplate</code>。与此同时<code>JdbcTemplate</code>，Spring Boot会自动为您配置一个bean来注入模板，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoTemplate mongoTemplate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mongoTemplate = mongoTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关完整的详细信息，请参阅 <a href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoOperations.html" target="_blank" rel="noopener"><code>MongoOperations</code> Javadoc</a>。</p><h3 id="Spring-Data-MongoDB存储库"><a href="#Spring-Data-MongoDB存储库" class="headerlink" title="Spring Data MongoDB存储库"></a>Spring Data MongoDB存储库</h3><p>Spring Data包括MongoDB的存储库支持。与前面讨论的JPA存储库一样，基本原则是基于方法名称自动构造查询。</p><p>事实上，Spring Data JPA和Spring Data MongoDB共享相同的通用基础架构。您可以从之前获取JPA示例，并假设它<code>City</code>现在是Mongo数据类而不是JPA <code>@Entity</code>，它的工作方式相同，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>您可以使用<code>@EntityScan</code>注释自定义文档扫描位置。</p></blockquote><blockquote><p>有关Spring Data MongoDB的完整详细信息，包括其丰富的对象映射技术，请参阅其<a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">参考文档</a>。</p></blockquote><h3 id="嵌入式Mongo"><a href="#嵌入式Mongo" class="headerlink" title="嵌入式Mongo"></a>嵌入式Mongo</h3><p>Spring Boot为<a href="https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo" target="_blank" rel="noopener">Embedded Mongo</a>提供自动配置 。要在Spring Boot应用程序中使用它，请添加依赖项 <code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code>。</p><p>可以通过设置<code>spring.data.mongodb.port</code> 属性来配置Mongo侦听的端口。要使用随机分配的空闲端口，请使用值0. <code>MongoClient</code> 创建者<code>MongoAutoConfiguration</code>自动配置为使用随机分配的端口。</p><blockquote><p>如果未配置自定义端口，则默认情况下，嵌入式支持使用随机端口（而不是27017）。</p></blockquote><p>如果类路径上有SLF4J，则Mongo生成的输出会自动路由到名为的记录器<code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code>。</p><p>您可以声明自己的bean <code>IMongodConfig</code>和<code>IRuntimeConfig</code>bean来控制Mongo实例的配置和日志记录路由。</p><h2 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h2><p><a href="http://neo4j.com/" target="_blank" rel="noopener">Neo4j</a>是一个开源的NoSQL图形数据库，它使用由一级关系连接的节点的丰富数据模型，与传统的RDBMS方法相比，它更适合于连接的大数据。Spring Boot为使用Neo4j提供了一些便利，包括<code>spring-boot-starter-data-neo4j</code> 启动器。</p><h3 id="连接到Neo4j数据库"><a href="#连接到Neo4j数据库" class="headerlink" title="连接到Neo4j数据库"></a>连接到Neo4j数据库</h3><p>要访问Neo4j服务器，您可以注入自动配置 <code>org.neo4j.ogm.session.Session</code>。默认情况下，实例尝试<code>localhost:7687</code>使用Bolt协议连接到Neo4j服务器。以下示例显示了如何注入Neo4j <code>Session</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Session session;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.session = session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以通过设置<code>spring.data.neo4j.*</code> 属性来配置要使用的URI和凭据，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.data.neo4j.uri=bolt://my-server:7687</span><br><span class="line">spring.data.neo4j.username=neo4j</span><br><span class="line">spring.data.neo4j.password=secret</span><br></pre></td></tr></table></figure><p>您可以通过添加a来完全控制会话创建 <code>org.neo4j.ogm.config.Configuration</code> <code>@Bean</code>。此外，添加一个<code>@Bean</code>类型 <code>SessionFactory</code>会禁用自动配置并为您提供完全控制。</p><h3 id="使用嵌入模式"><a href="#使用嵌入模式" class="headerlink" title="使用嵌入模式"></a>使用嵌入模式</h3><p>如果添加<code>org.neo4j:neo4j-ogm-embedded-driver</code>到应用程序的依赖项，Spring Boot会自动配置Neo4j的进程内嵌入式实例，该应用程序在应用程序关闭时不会保留任何数据。</p><blockquote><p>由于嵌入式Neo4j OGM驱动程序本身不提供Neo4j内核，因此您必须自己声明<code>org.neo4j:neo4j</code>为依赖项。有关兼容版本的列表，请参阅 <a href="https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started" target="_blank" rel="noopener">Neo4j OGM文档</a>。</p></blockquote><p>当类路径上有多个驱动程序时，嵌入式驱动程序优先于其他驱动程序。您可以通过设置明确禁用嵌入模式 <code>spring.data.neo4j.embedded.enabled=false</code>。</p><p>如果嵌入式驱动程序和Neo4j内核如上所述位于类路径上，则<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test" target="_blank" rel="noopener">数据Neo4j测试会</a>自动使用嵌入式Neo4j实例。</p><blockquote><p>您可以通过在配置中提供数据库文件的路径来为嵌入模式启用持久性，例如<code>spring.data.neo4j.uri=file://var/tmp/graph.db</code>。</p></blockquote><h3 id="Neo4jSession"><a href="#Neo4jSession" class="headerlink" title="Neo4jSession"></a>Neo4jSession</h3><p>默认情况下，如果您正在运行Web应用程序，则会话将绑定到线程以进行整个请求处理（即，它使用“在视图中打开会话”模式）。如果您不想要此行为，请将以下行添加到您的 <code>application.properties</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.neo4j.embedded.enabled=false</span><br></pre></td></tr></table></figure><h3 id="Spring-Data-Neo4j存储库"><a href="#Spring-Data-Neo4j存储库" class="headerlink" title="Spring Data Neo4j存储库"></a>Spring Data Neo4j存储库</h3><p>Spring Data包含对Neo4j的存储库支持。</p><p>Spring Data Neo4j与Spring Data JPA共享通用基础架构，就像许多其他Spring Data模块一样。您可以从之前的JPA示例中获取并定义 <code>City</code>为Neo4j OGM <code>@NodeEntity</code>而不是JPA <code>@Entity</code>，并且存储库抽象以相同的方式工作，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Neo4jRepository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">Optional&lt;City&gt; <span class="title">findOneByNameAndState</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>spring-boot-starter-data-neo4j</code>“入门”使仓库的支持以及事务管理。您可以自定义的位置通过查找资料库和实体<code>@EnableNeo4jRepositories</code>，并<code>@EntityScan</code>分别在 <code>@Configuration</code>-bean。</p><blockquote><p>有关Spring Data Neo4j的完整详细信息，包括其对象映射技术，请参阅<a href="https://projects.spring.io/spring-data-neo4j/" target="_blank" rel="noopener">参考文档</a>。</p></blockquote><h2 id="Gemfire"><a href="#Gemfire" class="headerlink" title="Gemfire"></a>Gemfire</h2><p><a href="https://github.com/spring-projects/spring-data-gemfire" target="_blank" rel="noopener">Spring Data Gemfire</a>为访问<a href="https://pivotal.io/big-data/pivotal-gemfire#details" target="_blank" rel="noopener">Pivotal Gemfire</a>数据管理平台提供了方便的Spring友好工具 。有一个<code>spring-boot-starter-data-gemfire</code>启动器用于以方便的方式收集依赖项。目前没有对Gemfire的自动配置支持，但您可以使用单个注释<a href="https://github.com/spring-projects/spring-data-gemfire/blob/master/src/main/java/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.java" target="_blank" rel="noopener"><code>@EnableGemfireRepositories</code></a>启用Spring Data Repositories <a href="https://github.com/spring-projects/spring-data-gemfire/blob/master/src/main/java/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.java" target="_blank" rel="noopener">:</a> .</p><h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p><a href="https://lucene.apache.org/solr/" target="_blank" rel="noopener">Apache Solr</a>是一个搜索引擎。Spring Boot为Solr 5客户端库提供了基本的自动配置，并为<a href="https://github.com/spring-projects/spring-data-solr" target="_blank" rel="noopener">Spring Data Solr</a>提供了它的抽象。有一个<code>spring-boot-starter-data-solr</code>启动器用于以方便的方式收集依赖项。</p><h3 id="连接到Solr"><a href="#连接到Solr" class="headerlink" title="连接到Solr"></a>连接到Solr</h3><p>您可以<code>SolrClient</code>像任何其他Spring bean一样注入自动配置的实例。默认情况下，实例尝试连接到服务器 <code>localhost:8983/solr</code>。以下示例显示如何注入Solr bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SolrClient solr;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(SolrClient solr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.solr = solr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果添加自己<code>@Bean</code>的类型<code>SolrClient</code>，则会替换默认值。</p><h3 id="Spring-Data-Solr存储库"><a href="#Spring-Data-Solr存储库" class="headerlink" title="Spring Data Solr存储库"></a>Spring Data Solr存储库</h3><p>Spring Data包括Apache Solr的存储库支持。与前面讨论的JPA存储库一样，基本原则是根据方法名称自动构造查询。</p><p>事实上，Spring Data JPA和Spring Data Solr共享相同的通用基础架构。您可以从之前获取JPA示例，并假设它<code>City</code>现在是一个 <code>@SolrDocument</code>类而不是JPA <code>@Entity</code>，它以相同的方式工作。</p><blockquote><p>有关Spring Data Solr的完整详细信息，请参阅 <a href="https://projects.spring.io/spring-data-solr/" target="_blank" rel="noopener">参考文档</a>。</p></blockquote><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p><a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a>是一个开源，分布式，RESTful搜索和分析引擎。Spring Boot为Elasticsearch提供基本的自动配置。</p><p>Spring Boot支持多个HTTP客户端：</p><ul><li>官方Java“低级”和“高级”REST客户端</li><li><a href="https://github.com/searchbox-io/Jest" target="_blank" rel="noopener">笑话</a></li></ul><p><a href="https://github.com/spring-projects/spring-data-elasticsearch" target="_blank" rel="noopener">Spring Data Elasticsearch</a>仍在使用传输客户端 ，您可以使用<code>spring-boot-starter-data-elasticsearch</code>启动器开始使用它。</p><h3 id="REST客户端连接到Elasticsearch"><a href="#REST客户端连接到Elasticsearch" class="headerlink" title="REST客户端连接到Elasticsearch"></a>REST客户端连接到Elasticsearch</h3><p>Elasticsearch提供了 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html" target="_blank" rel="noopener">两个</a> 可用于查询集群的<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html" target="_blank" rel="noopener">REST客户端</a>：“低级”客户端和“高级”客户端。</p><p>如果您<code>org.elasticsearch.client:elasticsearch-rest-client</code>依赖于类路径，Spring Boot将自动配置并注册<code>RestClient</code>默认目标的bean <code>localhost:9200</code>。您可以进一步调整<code>RestClient</code>配置方式，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.elasticsearch.rest.uris=http://search.example.com:9200</span><br><span class="line">spring.elasticsearch.rest.username=user</span><br><span class="line">spring.elasticsearch.rest.password=secret</span><br></pre></td></tr></table></figure><p>您还可以注册任意数量的bean，以实现 <code>RestClientBuilderCustomizer</code>更高级的自定义。要完全控制注册，请定义<code>RestClient</code>bean。</p><p>如果您<code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code>对类路径有依赖性，Spring Boot将自动配置a <code>RestHighLevelClient</code>，它包装任何现有的<code>RestClient</code>bean，重用其HTTP配置。</p><h3 id="使用Jest连接到Elasticsearch"><a href="#使用Jest连接到Elasticsearch" class="headerlink" title="使用Jest连接到Elasticsearch"></a>使用Jest连接到Elasticsearch</h3><p>如果您具有<code>Jest</code>类路径，则可以注入<code>JestClient</code>默认目标的自动配置<code>localhost:9200</code>。您可以进一步调整客户端的配置方式，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.elasticsearch.jest.uris=http://search.example.com:9200</span><br><span class="line">spring.elasticsearch.jest.read-timeout=10000</span><br><span class="line">spring.elasticsearch.jest.username=user</span><br><span class="line">spring.elasticsearch.jest.password=secret</span><br></pre></td></tr></table></figure><p>您还可以注册任意数量的bean，以实现 <code>HttpClientConfigBuilderCustomizer</code>更高级的自定义。以下示例调整其他HTTP设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSettingsCustomizer</span> <span class="keyword">implements</span> <span class="title">HttpClientConfigBuilderCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(HttpClientConfig.Builder builder)</span> </span>&#123;</span><br><span class="line">builder.maxTotalConnection(<span class="number">100</span>).defaultMaxTotalConnectionPerRoute(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要完全控制注册，请定义<code>JestClient</code>bean。</p><h3 id="使用Spring数据连接Elasticsearch"><a href="#使用Spring数据连接Elasticsearch" class="headerlink" title="使用Spring数据连接Elasticsearch"></a>使用Spring数据连接Elasticsearch</h3><p>要连接到Elasticsearch，您必须提供一个或多个群集节点的地址。可以通过将<code>spring.data.elasticsearch.cluster-nodes</code> 属性设置为逗号分隔<code>host:port</code>列表来指定地址。使用此配置， 可以像任何其他Spring bean一样注入<code>ElasticsearchTemplate</code>或<code>TransportClient</code>注入，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.elasticsearch.cluster-nodes=localhost:9300</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ElasticsearchTemplate template)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.template = template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您添加自己的<code>ElasticsearchTemplate</code>或<code>TransportClient</code> <code>@Bean</code>，它将替换默认值。</p><h3 id="Spring-Data-Elasticsearch存储库"><a href="#Spring-Data-Elasticsearch存储库" class="headerlink" title="Spring Data Elasticsearch存储库"></a>Spring Data Elasticsearch存储库</h3><p>Spring Data包括对Elasticsearch的存储库支持。与前面讨论的JPA存储库一样，基本原则是根据方法名称自动为您构建查询。</p><p>事实上，Spring Data JPA和Spring Data Elasticsearch共享相同的通用基础架构。您可以从之前的JPA示例中获取，假设它<code>City</code>现在是Elasticsearch <code>@Document</code>类而不是JPA <code>@Entity</code>，它的工作方式相同。</p><blockquote><p>有关Spring Data Elasticsearch的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/elasticsearch/docs/" target="_blank" rel="noopener">参考文档</a>。</p></blockquote><h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p><a href="https://cassandra.apache.org/" target="_blank" rel="noopener">Cassandra</a>是一个开源的分布式数据库管理系统，旨在处理许多商用服务器上的大量数据。Spring Boot提供了Cassandra的自动配置以及<a href="https://github.com/spring-projects/spring-data-cassandra" target="_blank" rel="noopener">Spring Data Cassandra</a>提供的抽象。有一个<code>spring-boot-starter-data-cassandra</code>启动器用于以方便的方式收集依赖项。</p><h3 id="连接到Cassandra"><a href="#连接到Cassandra" class="headerlink" title="连接到Cassandra"></a>连接到Cassandra</h3><p>您可以像使用任何其他Spring Bean一样注入自动配置<code>CassandraTemplate</code>或Cassandra <code>Session</code>实例。这些<code>spring.data.cassandra.*</code>属性可用于自定义连接。通常，您提供<code>keyspace-name</code>和 <code>contact-points</code>属性，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.data.cassandra.keyspace-name=mykeyspace</span><br><span class="line">spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2</span><br></pre></td></tr></table></figure><p>您还可以注册任意数量的bean，以实现 <code>ClusterBuilderCustomizer</code>更高级的自定义。</p><p>以下代码清单显示了如何注入Cassandra bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CassandraTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CassandraTemplate template)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.template = template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果添加自己<code>@Bean</code>的类型<code>CassandraTemplate</code>，则会替换默认值。</p><h3 id="Spring-Data-Cassandra存储库"><a href="#Spring-Data-Cassandra存储库" class="headerlink" title="Spring Data Cassandra存储库"></a>Spring Data Cassandra存储库</h3><p>Spring Data包含对Cassandra的基本存储库支持。目前，这比前面讨论的JPA存储库更有限，需要使用注释查找器方法<code>@Query</code>。</p><blockquote><p>有关Spring Data Cassandra的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/cassandra/docs/" target="_blank" rel="noopener">参考文档</a>。</p></blockquote><h2 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h2><p><a href="https://www.couchbase.com/" target="_blank" rel="noopener">Couchbase</a>是一个开源的，分布式的，多模型的NoSQL面向文档的数据库，针对交互式应用程序进行了优化。Spring Boot提供了Couchbase的自动配置以及<a href="https://github.com/spring-projects/spring-data-couchbase" target="_blank" rel="noopener">Spring Data Couchbase</a>提供的抽象 。有一个 <code>spring-boot-starter-data-couchbase</code>和<code>spring-boot-starter-data-couchbase-reactive</code> 启动器方便的方法收集的依赖关系。</p><h3 id="连接到Couchbase"><a href="#连接到Couchbase" class="headerlink" title="连接到Couchbase"></a>连接到Couchbase</h3><p>你可以得到一个<code>Bucket</code>和<code>Cluster</code>通过添加Couchbase SDK和一些配置。这些<code>spring.couchbase.*</code>属性可用于自定义连接。通常，您提供引导主机，存储桶名称和密码，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123</span><br><span class="line">spring.couchbase.bucket.name=my-bucket</span><br><span class="line">spring.couchbase.bucket.password=secret</span><br></pre></td></tr></table></figure><blockquote><p>您需要<em>至少</em>提供引导主机，在这种情况下，存储桶名称为 <code>default</code>，密码为空字符串。或者，您可以定义自己的<code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code> <code>@Bean</code>控件来控制整个配置。</p></blockquote><p>也可以自定义一些<code>CouchbaseEnvironment</code>设置。例如，以下配置更改用于打开新的超时<code>Bucket</code> 并启用SSL支持的超时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.couchbase.env.timeouts.connect=3000</span><br><span class="line">spring.couchbase.env.ssl.key-store=/location/of/keystore.jks</span><br><span class="line">spring.couchbase.env.ssl.key-store-password=secret</span><br></pre></td></tr></table></figure><p>检查<code>spring.couchbase.env.*</code>属性以获取更多详细信息。</p><h3 id="Spring-Data-Couchbase存储库"><a href="#Spring-Data-Couchbase存储库" class="headerlink" title="Spring Data Couchbase存储库"></a>Spring Data Couchbase存储库</h3><p>Spring Data包括对Couchbase的存储库支持。有关Spring Data Couchbase的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/" target="_blank" rel="noopener">参考文档</a>。</p><p>您可以<code>CouchbaseTemplate</code>像使用任何其他Spring Bean一样注入自动配置的实例，只要有<em>默认值</em> <code>CouchbaseConfigurer</code>（当您启用Couchbase支持时会发生这种情况，如前所述）。</p><p>以下示例显示了如何注入Couchbase bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CouchbaseTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CouchbaseTemplate template)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.template = template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以在自己的配置中定义一些bean来覆盖自动配置提供的bean：</p><ul><li><code>CouchbaseTemplate</code> <code>@Bean</code>的名字是<code>couchbaseTemplate</code>。</li><li><code>IndexManager</code> <code>@Bean</code>用的名称<code>couchbaseIndexManager</code>。</li><li><code>CustomConversions</code> <code>@Bean</code>的名字是<code>couchbaseCustomConversions</code>。</li></ul><p>为避免在您自己的配置中对这些名称进行硬编码，您可以重复使用<code>BeanNames</code>Spring Data Couchbase。例如，您可以自定义要使用的转换器，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomConversions <span class="title">myCustomConversions</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CustomConversions(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果要完全绕过Spring Data Couchbase的自动配置，请提供自己的实现<code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code>。</p></blockquote><h2 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h2><p><a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" target="_blank" rel="noopener">LDAP</a>（轻量级目录访问协议）是一种开放的，与供应商无关的行业标准应用程序协议，用于通过IP网络访问和维护分布式目录信息服务。Spring Boot为任何兼容的LDAP服务器提供自动配置，并为<a href="https://www.ldap.com/unboundid-ldap-sdk-for-java" target="_blank" rel="noopener">UnboundID</a>支持嵌入式内存中LDAP服务器 。</p><p>LDAP抽象由 <a href="https://github.com/spring-projects/spring-data-ldap" target="_blank" rel="noopener">Spring Data LDAP提供</a>。有一个<code>spring-boot-starter-data-ldap</code>启动器用于以方便的方式收集依赖项。</p><h3 id="连接LDAP服务器"><a href="#连接LDAP服务器" class="headerlink" title="连接LDAP服务器"></a>连接LDAP服务器</h3><p>要连接到LDAP服务器，请确保声明对<code>spring-boot-starter-data-ldap</code>启动器 的依赖关系 <code>spring-ldap-core</code>，然后在application.properties中声明服务器的URL，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.urls=ldap://myserver:1235</span><br><span class="line">spring.ldap.username=admin</span><br><span class="line">spring.ldap.password=secret</span><br></pre></td></tr></table></figure><p>如果需要自定义连接设置，可以使用<code>spring.ldap.base</code>和 <code>spring.ldap.base-environment</code>属性。</p><p>一种<code>LdapContextSource</code>是自动配置基于这些设置。如果您需要自定义它，例如使用a <code>PooledContextSource</code>，您仍然可以注入自动配置<code>LdapContextSource</code>。确保将自定义标记<code>ContextSource</code>为<code>@Primary</code>自动配置<code>LdapTemplate</code>使用它。</p><h3 id="Spring-Data-LDAP存储库"><a href="#Spring-Data-LDAP存储库" class="headerlink" title="Spring Data LDAP存储库"></a>Spring Data LDAP存储库</h3><p>Spring Data包括对LDAP的存储库支持。有关Spring Data LDAP的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/" target="_blank" rel="noopener">参考文档</a>。</p><p>您也可以<code>LdapTemplate</code>像使用任何其他Spring Bean一样注入自动配置的实例，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LdapTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(LdapTemplate template)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.template = template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌入式内存LDAP服务器"><a href="#嵌入式内存LDAP服务器" class="headerlink" title="嵌入式内存LDAP服务器"></a>嵌入式内存LDAP服务器</h3><p>出于测试目的，Spring Boot支持从<a href="https://www.ldap.com/unboundid-ldap-sdk-for-java" target="_blank" rel="noopener">UnboundID</a>自动配置内存中的LDAP服务器。要配置服务器，请向依赖项添加依赖项<code>com.unboundid:unboundid-ldapsdk</code>并声明<code>base-dn</code>属性，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.embedded.base-dn=dc=spring,dc=io</span><br></pre></td></tr></table></figure><blockquote><p>可以定义多个base-dn值，但是，由于可分辨名称通常包含逗号，因此必须使用正确的表示法定义它们。</p><p>在yaml文件中，您可以使用yaml列表表示法：</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.ldap.embedded.base-dn:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dc=spring,dc=io</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dc=pivotal,dc=io</span></span><br></pre></td></tr></table></figure><blockquote><p>在属性文件中，必须包含索引作为属性名称的一部分：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.embedded.base-dn[0]=dc=spring,dc=io</span><br><span class="line">spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io</span><br></pre></td></tr></table></figure><p>默认情况下，服务器在随机端口上启动并触发常规LDAP支持。无需指定<code>spring.ldap.urls</code>属性。</p><p>如果<code>schema.ldif</code>类路径中有文件，则用于初始化服务器。如果要从其他资源加载初始化脚本，还可以使用该<code>spring.ldap.embedded.ldif</code>属性。</p><p>默认情况下，标准模式用于验证<code>LDIF</code>文件。您可以通过设置<code>spring.ldap.embedded.validation.enabled</code>属性完全关闭验证。如果您有自定义属性，则可以使用它<code>spring.ldap.embedded.validation.schema</code>来定义自定义属性类型或对象类。</p><h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><p><a href="https://www.influxdata.com/" target="_blank" rel="noopener">InfluxDB</a>是一个开源时间序列数据库，针对运营监控，应用程序指标，物联网传感器数据和实时分析等领域中的时间序列数据的快速，高可用性存储和检索进行了优化。</p><h3 id="连接到InfluxDB"><a href="#连接到InfluxDB" class="headerlink" title="连接到InfluxDB"></a>连接到InfluxDB</h3><p><code>InfluxDB</code>如果<code>influxdb-java</code>客户端在类路径上并且设置了数据库的URL，则Spring Boot会自动配置实例，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.influx.url=http://172.0.0.1:8086</span><br></pre></td></tr></table></figure><p>如果与InfluxDB的连接需要用户和密码，则可以相应地设置 <code>spring.influx.user</code>和<code>spring.influx.password</code>属性。</p><p>InfluxDB依赖于OkHttp。如果需要调整http客户端<code>InfluxDB</code>在幕后使用，可以注册一个<code>InfluxDbOkHttpClientBuilderProvider</code>bean。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-SQL数据库</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-SQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL数据库"><a href="#SQL数据库" class="headerlink" title="SQL数据库"></a>SQL数据库</h1><p>在<a href="https://projects.spring.io/spring-framework/" target="_blank" rel="noopener">Spring框架</a>提供了广泛的支持使用使用SQL数据库，直接JDBC访问<code>JdbcTemplate</code>来完成“对象关系映射”技术，比如Hibernate。<a href="https://projects.spring.io/spring-data/" target="_blank" rel="noopener">Spring Data</a>提供了更多级别的功能：<code>Repository</code>直接从接口创建实现，并使用约定从方法名称生成查询。</p><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>Java的<code>javax.sql.DataSource</code>接口提供了一种使用数据库连接的标准方法。传统上，’DataSource’使用<code>URL</code>一些凭证来建立数据库连接。</p><blockquote><p>有关更多高级示例，请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-a-datasource" target="_blank" rel="noopener">“操作方法”</a>，通常可以完全控制DataSource的配置。</p></blockquote><h3 id="嵌入式数据库支持"><a href="#嵌入式数据库支持" class="headerlink" title="嵌入式数据库支持"></a>嵌入式数据库支持</h3><p>通过使用内存中的嵌入式数据库来开发应用程序通常很方便。显然，内存数据库不提供持久存储。您需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。</p><blockquote><p>“操作方法”部分包含<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-database-initialization" target="_blank" rel="noopener">有关如何初始化数据库的部分</a>。</p></blockquote><p>Spring Boot可以自动配置嵌入式<a href="http://www.h2database.com/" target="_blank" rel="noopener">H2</a>， <a href="http://hsqldb.org/" target="_blank" rel="noopener">HSQL</a>和<a href="https://db.apache.org/derby/" target="_blank" rel="noopener">Derby</a>数据库。您无需提供任何连接URL。您只需要包含要使用的嵌入式数据库的构建依赖项。</p><blockquote><p>如果您在测试中使用此功能，您可能会注意到整个测试套件都会重复使用相同的数据库，而不管您使用的应用程序上下文的数量。如果要确保每个上下文都有一个单独的嵌入式数据库，则应设置<code>spring.datasource.generate-unique-name</code>为<code>true</code>。</p></blockquote><p>例如，典型的POM依赖关系如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>您需要依赖于<code>spring-jdbc</code>自动配置嵌入式数据库。在这个例子中，它被传递过来 <code>spring-boot-starter-data-jpa</code>。</p></blockquote><blockquote><p>如果由于某种原因，您确实为嵌入式数据库配置了连接URL，请注意确保禁用数据库的自动关闭。如果你使用H2，你应该<code>DB_CLOSE_ON_EXIT=FALSE</code>这样做。如果使用HSQLDB，则应确保<code>shutdown=true</code>未使用HSQLDB 。禁用数据库的自动关闭可以在数据库关闭时进行Spring Boot控制，从而确保在不再需要访问数据库时发生。</p></blockquote><h3 id="连接到生产数据库"><a href="#连接到生产数据库" class="headerlink" title="连接到生产数据库"></a>连接到生产数据库</h3><p>也可以使用池自动配置生产数据库连接 <code>DataSource</code>。Spring Boot使用以下算法来选择特定的实现：</p><ol><li>我们更喜欢<a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">HikariCP</a>的性能和并发性。如果HikariCP可用，我们总是选择它。</li><li>否则，如果Tomcat池<code>DataSource</code>可用，我们将使用它。</li><li>如果HikariCP和Tomcat池化数据源都不可用，并且 <a href="https://commons.apache.org/proper/commons-dbcp/" target="_blank" rel="noopener">Commons DBCP2</a>可用，我们就会使用它。</li></ol><p>如果您使用<code>spring-boot-starter-jdbc</code>或<code>spring-boot-starter-data-jpa</code>启动器，您将自动获得依赖<code>HikariCP</code>。</p><blockquote><p>您可以完全绕过该算法，并通过设置<code>spring.datasource.type</code>属性指定要使用的连接池。如果您在Tomcat容器中运行应用程序<code>tomcat-jdbc</code>（默认情况下提供），这一点尤为重要。</p></blockquote><blockquote><p>始终可以手动配置其他连接池。如果您定义自己的<code>DataSource</code>bean，则不会进行自动配置。</p></blockquote><p>DataSource配置由外部配置属性控制 <code>spring.datasource.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost/test</span><br><span class="line">spring.datasource.username=dbuser</span><br><span class="line">spring.datasource.password=dbpass</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><blockquote><p>您至少应该通过设置<code>spring.datasource.url</code> 属性来指定URL 。否则，Spring Boot会尝试自动配置嵌入式数据库。</p></blockquote><blockquote><p>您通常不需要指定<code>driver-class-name</code>，因为Spring Boot可以从大多数数据库推断它<code>url</code>。</p></blockquote><blockquote><p>对于<code>DataSource</code>要创建的池，我们需要能够验证有效的 <code>Driver</code>类是否可用，因此我们在执行任何操作之前检查它。换句话说，如果你设置<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>，那么该类必须是可加载的。</p></blockquote><p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java" target="_blank" rel="noopener"><code>DataSourceProperties</code></a> 更多支持的选项，请参阅 。无论实际实施如何，这些都是标准选项。也可以微调实现特定的设置，使用各自的前缀（<code>spring.datasource.hikari.*</code>， <code>spring.datasource.tomcat.*</code>，和<code>spring.datasource.dbcp2.*</code>）。有关更多详细信息，请参阅您正在使用的连接池实现的文档。</p><p>例如，如果使用 <a href="https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes" target="_blank" rel="noopener">Tomcat连接池</a>，则可以自定义许多其他设置，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">＃如果没有可用连接，则在抛出异常之前要等待的ms数。</span><br><span class="line">spring.datasource.tomcat.max-wait = 10000</span><br><span class="line"></span><br><span class="line">＃可以同时从该池分配的最大活动连接数。</span><br><span class="line">spring.datasource.tomcat.max-active = 50</span><br><span class="line"></span><br><span class="line">＃在从池中借用连接之前验证连接。</span><br><span class="line">spring.datasource.tomcat.test-on-borrow = true</span><br></pre></td></tr></table></figure><h3 id="连接到JNDI数据源"><a href="#连接到JNDI数据源" class="headerlink" title="连接到JNDI数据源"></a>连接到JNDI数据源</h3><p>如果将Spring Boot应用程序部署到Application Server，则可能需要使用Application Server的内置功能配置和管理DataSource，并使用JNDI访问它。</p><p>该<code>spring.datasource.jndi-name</code>属性可以被用作一个替代 <code>spring.datasource.url</code>，<code>spring.datasource.username</code>和<code>spring.datasource.password</code>属性来访问<code>DataSource</code>从一个特定的JNDI位置。例如，以下部分<code>application.properties</code>显示了如何访问定义的JBoss AS <code>DataSource</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.jndi-name=java:jboss/datasources/customers</span><br></pre></td></tr></table></figure><h2 id="使用JdbcTemplate"><a href="#使用JdbcTemplate" class="headerlink" title="使用JdbcTemplate"></a>使用JdbcTemplate</h2><p>Spring <code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>类是自动配置的，您可以<code>@Autowire</code>直接将它们放入自己的bean中，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用<code>spring.jdbc.template.*</code> 属性自定义模板的某些属性，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jdbc.template.max-rows=500</span><br></pre></td></tr></table></figure><blockquote><p>在<code>NamedParameterJdbcTemplate</code>重复使用相同的<code>JdbcTemplate</code>幕后情况。如果<code>JdbcTemplate</code>定义了多个且没有主要候选项，<code>NamedParameterJdbcTemplate</code>则不会自动配置。</p></blockquote><h2 id="JPA和Spring-Data-JPA"><a href="#JPA和Spring-Data-JPA" class="headerlink" title="JPA和Spring Data JPA"></a>JPA和Spring Data JPA</h2><p>Java Persistence API是一种标准技术，可让您将对象“映射”到关系数据库。该<code>spring-boot-starter-data-jpa</code>POM提供了上手的快捷方式。它提供以下关键依赖项：</p><ul><li>Hibernate：最受欢迎的JPA实现之一。</li><li>Spring Data JPA：使实现基于JPA的存储库变得容易。</li><li>Spring ORMs：Spring Framework的核心ORM支持。</li></ul><blockquote><p>我们不会在这里详细介绍JPA或<a href="https://projects.spring.io/spring-data/" target="_blank" rel="noopener">Spring Data</a>。您可以按照<a href="https://spring.io/guides/gs/accessing-data-jpa/" target="_blank" rel="noopener">“访问数据与JPA”</a> 从指导<a href="https://spring.io/" target="_blank" rel="noopener">spring.io</a>并宣读了<a href="https://projects.spring.io/spring-data-jpa/" target="_blank" rel="noopener">春天的数据JPA</a>和 <a href="https://hibernate.org/orm/documentation/" target="_blank" rel="noopener">Hibernate的</a>参考文档。</p></blockquote><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>传统上，JPA“实体”类在<code>persistence.xml</code>文件中指定。使用Spring Boot，此文件不是必需的，而是使用“实体扫描”。默认情况下，将搜索主配置类（注释为<code>@EnableAutoConfiguration</code>或者<code>@SpringBootApplication</code>）下的所有包 。</p><p>任何类别标注了<code>@Entity</code>，<code>@Embeddable</code>或者<code>@MappedSuperclass</code>被认为是。典型的实体类类似于以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...其他成员，通常包括@OneToMany映射</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//JPA规范要求的no-args构造函数</span></span><br><span class="line"><span class="comment">//这个是受保护的，因为它不应该直接使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... etc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>您可以使用<code>@EntityScan</code>注释自定义实体扫描位置。请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration" target="_blank" rel="noopener">第84.4节</a> ” <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration" target="_blank" rel="noopener">，“从Spring配置中分离@Entity定义”</a> “ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration" target="_blank" rel="noopener">操作方法”</a>。</p></blockquote><h3 id="Spring-Data-JPA存储库"><a href="#Spring-Data-JPA存储库" class="headerlink" title="Spring Data JPA存储库"></a>Spring Data JPA存储库</h3><p><a href="https://projects.spring.io/spring-data-jpa/" target="_blank" rel="noopener">Spring Data JPA</a>存储库是您可以定义以访问数据的接口。JPA查询是从您的方法名称自动创建的。例如， <code>CityRepository</code>接口可能会声明一种<code>findAllByState(String state)</code>方法来查找给定状态中的所有城市。</p><p>对于更复杂的查询，您可以使用Spring Data的<a href="https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/Query.html" target="_blank" rel="noopener"><code>Query</code></a>注释来注释您的方法 。</p><p>Spring Data存储库通常从<a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/Repository.html" target="_blank" rel="noopener"><code>Repository</code></a>或 <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html" target="_blank" rel="noopener"><code>CrudRepository</code></a> 接口扩展 。如果使用自动配置，则会从包含主配置类（带有<code>@EnableAutoConfiguration</code>或标注的<code>@SpringBootApplication</code>）的包中搜索存储库 。</p><p>以下示例显示了典型的Spring Data存储库接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Data JPA存储库支持三种不同的引导模式：default，deferred和lazy。要启用延迟或延迟引导，请分别设置<code>spring.data.jpa.repositories.bootstrap-mode</code>为<code>deferred</code>或<code>lazy</code>。使用延迟或延迟引导时，自动配置<code>EntityManagerFactoryBuilder</code> 将使用上下文（<code>AsyncTaskExecutor</code>如果有）作为引导程序执行程序。如果存在多个，则使用命名的那个<code>applicationTaskExecutor</code>。</p><blockquote><p>我们几乎没有涉及Spring Data JPA的表面。有关完整的详细信息，请参阅<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" target="_blank" rel="noopener">Spring Data JPA参考文档</a>。</p></blockquote><h3 id="创建和删除JPA数据库"><a href="#创建和删除JPA数据库" class="headerlink" title="创建和删除JPA数据库"></a>创建和删除JPA数据库</h3><p>默认情况下，<strong>仅</strong>当您使用嵌入式数据库（H2，HSQL或Derby）时，<strong>才会</strong>自动创建JPA数据库。您可以使用<code>spring.jpa.*</code>属性显式配置JPA设置 。例如，要创建和删除表，您可以将以下行添加到<code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.ddl-auto=create-drop</span><br></pre></td></tr></table></figure><blockquote><p>Hibernate自己的内部属性名称（如果你碰巧记得更好）是<code>hibernate.hbm2ddl.auto</code>。您可以使用<code>spring.jpa.properties.*</code>（在将它们添加到实体管理器之前剥离前缀）来设置它以及其他Hibernate本机属性。以下行显示了为Hibernate设置JPA属性的示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.globally_quoted_identifiers=true</span><br></pre></td></tr></table></figure><p>在前面的示例中的线穿过的一个值<code>true</code>的 <code>hibernate.globally_quoted_identifiers</code>属性设置为休眠实体管理器。</p><p>默认情况下，DDL执行（或验证）将延迟到<code>ApplicationContext</code> 启动。还有一个<code>spring.jpa.generate-ddl</code>标志，但如果Hibernate自动配置处于活动状态，则不会使用该标志，因为<code>ddl-auto</code>设置更精细。</p><h3 id="在View中打开EntityManager"><a href="#在View中打开EntityManager" class="headerlink" title="在View中打开EntityManager"></a>在View中打开EntityManager</h3><p>如果您正在运行Web应用程序，则默认情况下Spring Boot会注册 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html" target="_blank" rel="noopener"><code>OpenEntityManagerInViewInterceptor</code></a> 以应用“在视图中打开EntityManager”模式，以允许在Web视图中进行延迟加载。如果你不希望这种行为，你应该设置<code>spring.jpa.open-in-view</code>到 <code>false</code>你<code>application.properties</code>。</p><h2 id="Spring-Data-JDBC"><a href="#Spring-Data-JDBC" class="headerlink" title="Spring Data JDBC"></a>Spring Data JDBC</h2><p>Spring Data包含对JDBC的存储库支持，并将自动为方法生成SQL <code>CrudRepository</code>。对于更高级的查询，<code>@Query</code>提供了注释。</p><p>当必要的依赖项在类路径上时，Spring Boot将自动配置Spring Data的JDBC存储库。它们可以通过单个依赖项添加到项目中<code>spring-boot-starter-data-jdbc</code>。如有必要，您可以通过向应用程序添加<code>@EnableJdbcRepositories</code>注释或 <code>JdbcConfiguration</code>子类来控制Spring Data JDBC的配置。</p><blockquote><p>有关Spring Data JDBC的完整详细信息，请参阅 <a href="https://projects.spring.io/spring-data-jdbc/" target="_blank" rel="noopener">参考文档</a>。</p></blockquote><h2 id="使用H2的Web控制台"><a href="#使用H2的Web控制台" class="headerlink" title="使用H2的Web控制台"></a>使用H2的Web控制台</h2><p>该<a href="http://www.h2database.com/" target="_blank" rel="noopener">H2数据库</a>提供了一个 <a href="http://www.h2database.com/html/quickstart.html#h2_console" target="_blank" rel="noopener">基于浏览器的控制台</a>,Spring启动即可自动配置。满足以下条件时，将自动配置控制台：</p><ul><li>您正在开发基于servlet的Web应用程序。</li><li><code>com.h2database:h2</code> 在类路径上。</li><li>您正在使用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#using-boot-devtools" target="_blank" rel="noopener">Spring Boot的开发人员工具</a>。</li></ul><blockquote><p>如果您没有使用Spring Boot的开发人员工具但仍希望使用H2的控制台，则可以<code>spring.h2.console.enabled</code>使用值配置属性<code>true</code>。</p></blockquote><blockquote><p>H2控制台仅用于开发期间，因此您应该注意确保<code>spring.h2.console.enabled</code>在生产中不要设置为<code>true</code>。</p></blockquote><h3 id="更改H2控制台的路径"><a href="#更改H2控制台的路径" class="headerlink" title="更改H2控制台的路径"></a>更改H2控制台的路径</h3><p>默认情况下，控制台可用于<code>/h2-console</code>。您可以使用该<code>spring.h2.console.path</code>属性自定义控制台的路径。</p><h2 id="使用jOOQ"><a href="#使用jOOQ" class="headerlink" title="使用jOOQ"></a>使用jOOQ</h2><p>Java面向对象查询（<a href="http://www.jooq.org/" target="_blank" rel="noopener">jOOQ</a>）是<a href="http://www.datageekery.com/" target="_blank" rel="noopener">Data Geekery的</a>一个流行产品， 它从您的数据库生成Java代码，并允许您通过其流畅的API构建类型安全的SQL查询。商业版和开源版都可以与Spring Boot一起使用。</p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>为了使用jOOQ类型安全查询，您需要从数据库模式生成Java类。您可以按照<a href="https://www.jooq.org/doc/3.11.9/manual-single-page/#jooq-in-7-steps-step3" target="_blank" rel="noopener">jOOQ用户手册中</a>的说明进行 <a href="https://www.jooq.org/doc/3.11.9/manual-single-page/#jooq-in-7-steps-step3" target="_blank" rel="noopener">操作</a>。如果您使用该 <code>jooq-codegen-maven</code>插件并且还使用<code>spring-boot-starter-parent</code> “父POM”，则可以安全地省略插件的<code>&lt;version&gt;</code>标签。您还可以使用Spring Boot定义的版本变量（例如<code>h2.version</code>）来声明插件的数据库依赖性。以下清单显示了一个示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jooq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;h2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbc</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">driver</span>&gt;</span>org.h2.Driver<span class="tag">&lt;/<span class="name">driver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:h2:~/yourdatabase<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbc</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用DSLContext"><a href="#使用DSLContext" class="headerlink" title="使用DSLContext"></a>使用DSLContext</h3><p>jOOQ提供的流畅API通过<code>org.jooq.DSLContext</code>界面启动。Spring Boot自动配置<code>DSLContext</code>为Spring Bean并将其连接到您的应用程序<code>DataSource</code>。要使用<code>DSLContext</code>，您可以使用<code>@Autowire</code>它，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JooqExample</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DSLContext create;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JooqExample</span><span class="params">(DSLContext dslContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.create = dslContext;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>jOOQ手册倾向于使用一个名为<code>create</code>hold的变量<code>DSLContext</code>。</p></blockquote><p>然后，您可以使用它<code>DSLContext</code>来构建查询，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;GregorianCalendar&gt; <span class="title">authorsBornAfter1980</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.create.selectFrom(AUTHOR)</span><br><span class="line">.where(AUTHOR.DATE_OF_BIRTH.greaterThan(<span class="keyword">new</span> GregorianCalendar(<span class="number">1980</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">.fetch(AUTHOR.DATE_OF_BIRTH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jOOQ-SQL方言"><a href="#jOOQ-SQL方言" class="headerlink" title="jOOQ SQL方言"></a>jOOQ SQL方言</h3><p>除非<code>spring.jooq.sql-dialect</code>已配置该属性，否则Spring Boot会确定用于数据源的SQL方言。如果Spring Boot无法检测到方言，则使用<code>DEFAULT</code>。</p><blockquote><p>Spring Boot只能自动配置开源版本的jOOQ支持的方言。</p></blockquote><h3 id="自定义jOOQ"><a href="#自定义jOOQ" class="headerlink" title="自定义jOOQ"></a>自定义jOOQ</h3><p>通过定义自己的<code>@Bean</code>定义可以实现更高级的自定义，这些定义在<code>Configuration</code>创建jOOQ时使用。您可以为以下jOOQ类型定义bean：</p><ul><li><code>ConnectionProvider</code></li><li><code>ExecutorProvider</code></li><li><code>TransactionProvider</code></li><li><code>RecordMapperProvider</code></li><li><code>RecordUnmapperProvider</code></li><li><code>RecordListenerProvider</code></li><li><code>ExecuteListenerProvider</code></li><li><code>VisitListenerProvider</code></li><li><code>TransactionListenerProvider</code></li></ul><p><code>org.jooq.Configuration</code> <code>@Bean</code>如果要完全控制jOOQ配置，也可以创建自己的。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Security</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Security/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Security/</url>
      
        <content type="html"><![CDATA[<h2 id="Security-安全"><a href="#Security-安全" class="headerlink" title="Security(安全)"></a>Security(安全)</h2><p>如果<a href="https://projects.spring.io/spring-security/" target="_blank" rel="noopener">Spring Security</a>位于类路径上，则默认情况下Web应用程序是安全的。Spring Boot依赖于Spring Security的内容协商策略来确定是否使用<code>httpBasic</code>或<code>formLogin</code>。要向Web应用程序添加方法级安全性，您还可以<code>@EnableGlobalMethodSecurity</code>使用所需的设置进行添加。其他信息可以在 <a href="https://docs.spring.io/spring-security/site/docs/5.1.4.RELEASE/reference/htmlsingle#jc-method" target="_blank" rel="noopener">Spring Security Reference Guide中找到</a>。</p><p>默认设置<code>UserDetailsService</code>只有一个用户。用户名是<code>user</code>，密码是随机的，在应用程序启动时以INFO级别打印，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用生成的安全密码：78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></td></tr></table></figure><blockquote><p>如果您对日志记录配置进行微调，请确保将 <code>org.springframework.boot.autoconfigure.security</code>类别设置为log <code>INFO</code>-level messages。否则，不会打印默认密码。</p></blockquote><p>您可以通过提供<code>spring.security.user.name</code>和 更改用户名和密码<code>spring.security.user.password</code>。</p><p>您在Web应用程序中默认获得的基本功能包括：</p><ul><li>A <code>UserDetailsService</code>（或<code>ReactiveUserDetailsService</code>WebFlux应用程序的情况）bean具有内存存储，单个用户具有生成的密码（请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html" target="_blank" rel="noopener"><code>SecurityProperties.User</code></a> 用户的属性）。</li><li>基于表单的登录或HTTP基本安全性（取决于Content-Type）用于整个应用程序（如果执行器在类路径上，则包括执行器端点）。</li><li>一个<code>DefaultAuthenticationEventPublisher</code>用于发布身份验证事件。</li></ul><p>你可以<code>AuthenticationEventPublisher</code>通过为它添加一个bean 来提供不同的东西。</p><h3 id="MVC安全性"><a href="#MVC安全性" class="headerlink" title="MVC安全性"></a>MVC安全性</h3><p>默认安全配置在<code>SecurityAutoConfiguration</code>和中 实现<code>UserDetailsServiceAutoConfiguration</code>。<code>SecurityAutoConfiguration</code>导入<code>SpringBootWebSecurityConfiguration</code>Web安全性并 <code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这也与非Web应用程序相关。要完全关闭默认Web应用程序安全配置，您可以添加类型的bean <code>WebSecurityConfigurerAdapter</code>（这样做不会禁用<code>UserDetailsService</code>配置或Actuator的安全性）。</p><p>为了还关闭<code>UserDetailsService</code>的配置，您可以添加类型的豆 <code>UserDetailsService</code>，<code>AuthenticationProvider</code>或<code>AuthenticationManager</code>。<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/" target="_blank" rel="noopener">Spring Boot示例中</a>有几个安全的应用程序可以帮助您开始使用常见的用例。</p><p>可以通过添加自定义来覆盖访问规则<code>WebSecurityConfigurerAdapter</code>。Spring Boot提供了便捷方法，可用于覆盖执行器端点和静态资源的访问规则。<code>EndpointRequest</code>可用于创建<code>RequestMatcher</code> 基于<code>management.endpoints.web.base-path</code>属性的。 <code>PathRequest</code>可用于<code>RequestMatcher</code>在常用位置创建资源。</p><h3 id="WebFlux安全性"><a href="#WebFlux安全性" class="headerlink" title="WebFlux安全性"></a>WebFlux安全性</h3><p>与Spring MVC应用程序类似，您可以通过添加<code>spring-boot-starter-security</code>依赖项来保护WebFlux应用程序。默认安全配置在<code>ReactiveSecurityAutoConfiguration</code>和中 实现<code>UserDetailsServiceAutoConfiguration</code>。<code>ReactiveSecurityAutoConfiguration</code>导入<code>WebFluxSecurityConfiguration</code>Web安全性并<code>UserDetailsServiceAutoConfiguration</code> 配置身份验证，这也与非Web应用程序相关。要完全关闭默认Web应用程序安全配置，您可以添加类型的bean <code>WebFilterChainProxy</code>（这样做不会禁用<code>UserDetailsService</code>配置或Actuator的安全性）。</p><p>要关闭<code>UserDetailsService</code>配置，可以添加类型为<code>ReactiveUserDetailsService</code>或的bean <code>ReactiveAuthenticationManager</code>。</p><p>可以通过添加自定义来配置访问规则<code>SecurityWebFilterChain</code>。Spring Boot提供了便捷方法，可用于覆盖执行器端点和静态资源的访问规则。<code>EndpointRequest</code>可用于创建 <code>ServerWebExchangeMatcher</code>基于<code>management.endpoints.web.base-path</code> 属性的。</p><p><code>PathRequest</code>可用于<code>ServerWebExchangeMatcher</code>在常用位置创建资源。</p><p>例如，您可以通过添加以下内容来自定义安全配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityWebFilterChain <span class="title">springSecurityFilterChain</span><span class="params">(ServerHttpSecurity http)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> http.authorizeExchange()</span><br><span class="line">.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()</span><br><span class="line">.pathMatchers(<span class="string">"/foo"</span>, <span class="string">"/bar"</span>)</span><br><span class="line">.authenticated().and()</span><br><span class="line">.formLogin().and()</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><p><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth2</a>是Spring支持的一种广泛使用的授权框架。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>如果您具有<code>spring-security-oauth2-client</code>类路径，则可以利用某些自动配置来轻松设置OAuth2 / Open ID Connect客户端。此配置使用下的属性<code>OAuth2ClientProperties</code>。相同的属性适用于servlet和反应式应用程序。</p><p>您可以在<code>spring.security.oauth2.client</code>前缀下注册多个OAuth2客户端和提供程序 ，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.registration.my-client-1.client-id=abcd</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.client-secret=password</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.scope=user</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.redirect-uri-template=http://my-redirect-uri.com</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code</span><br><span class="line"></span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-id=abcd</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-secret=password</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.scope=email</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.redirect-uri-template=http://my-redirect-uri.com</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code</span><br><span class="line"></span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=http://my-auth-server/oauth/authorize</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.token-uri=http://my-auth-server/oauth/token</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=http://my-auth-server/userinfo</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=http://my-auth-server/token_keys</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</span><br></pre></td></tr></table></figure><p>对于支持<a href="https://openid.net/specs/openid-connect-discovery-1_0.html" target="_blank" rel="noopener">OpenID Connect发现的</a> OpenID Connect提供程序，可以进一步简化配置。需要为提供程序配置一个<code>issuer-uri</code>URI，它将其声明为其颁发者标识符。例如，如果 <code>issuer-uri</code>提供的是“<a href="https://example.com”，`OpenID" target="_blank" rel="noopener">https://example.com”，`OpenID</a> Provider Configuration Request<code>则会进行“https://example.com/.well-known/openid-configuration”。结果预计是一个</code>OpenID Provider Configuration Response<code>。以下示例显示如何使用以下命令配置OpenID Connect Provider</code>issuer-uri`：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.provider.oidc-provider.issuer-uri = https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></td></tr></table></figure><p>默认情况下，Spring Security <code>OAuth2LoginAuthenticationFilter</code>仅处理URL匹配<code>/login/oauth2/code/*</code>。如果要自定义<code>redirect-uri</code>以使用其他模式，则需要提供配置以处理该自定义模式。例如，对于servlet应用程序，您可以添加<code>WebSecurityConfigurerAdapter</code>类似于以下内容的应用程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuth2LoginSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.anyRequest().authenticated()</span><br><span class="line">.and()</span><br><span class="line">.oauth2Login()</span><br><span class="line">.redirectionEndpoint()</span><br><span class="line">.baseUri(<span class="string">"/custom-callback"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OAuth2客户端注册常见providers</strong></p><p>对于常见的OAuth2和OpenID提供商，包括谷歌，Github上，Facebook和1563，我们提供了一组供应商默认的（<code>google</code>，<code>github</code>，<code>facebook</code>，和<code>okta</code>，分别）。</p><p>如果您不需要自定义这些提供程序，则可以将<code>provider</code>属性设置为需要推断默认值的属性。此外，如果客户端注册的密钥与默认支持的提供程序匹配，则Spring Boot也会推断出。</p><p>换句话说，以下示例中的两个配置使用Google提供程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.registration.my-client.client-id = abcd</span><br><span class="line">spring.security.oauth2.client.registration.my-client.client-secret = password</span><br><span class="line">spring.security.oauth2.client.registration.my- client.provider = google</span><br><span class="line"></span><br><span class="line">spring.security.oauth2.client.registration.google.client-id = abcd</span><br><span class="line">spring.security.oauth2.client.registration.google.client-secret = password</span><br></pre></td></tr></table></figure><h4 id="Resource-Server-资源服务器"><a href="#Resource-Server-资源服务器" class="headerlink" title="Resource Server(资源服务器)"></a>Resource Server(资源服务器)</h4><p>如果您具有<code>spring-security-oauth2-resource-server</code>类路径，则只要指定了JWK Set URI或OIDC Issuer URI，Spring Boot就可以设置OAuth2资源服务器，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.resourceserver.jwt.jwk-set-uri = https://example.com/oauth2/default/v1/keys</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.resourceserver.jwt.issuer-uri = https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></td></tr></table></figure><p>相同的属性适用于servlet和反应应用程序。</p><p>或者，您可以<code>JwtDecoder</code>为servlet应用程序或<code>ReactiveJwtDecoder</code>响应应用程序定义自己的bean 。</p><h4 id="Authorization-Server-授权服务器"><a href="#Authorization-Server-授权服务器" class="headerlink" title="Authorization Server(授权服务器)"></a>Authorization Server(授权服务器)</h4><p>目前，Spring Security不支持实施OAuth 2.0授权服务器。但是，此功能可从<a href="https://projects.spring.io/spring-security-oauth/" target="_blank" rel="noopener">Spring Security OAuth</a>项目获得，该项目最终将完全被Spring Security取代。在此之前，您可以使用该<code>spring-security-oauth2-autoconfigure</code>模块轻松设置OAuth 2.0授权服务器; 请参阅其<a href="https://docs.spring.io/spring-security-oauth2-boot" target="_blank" rel="noopener">文档</a>以获取说明</p><h3 id="Actuator-Security-执行器安全性"><a href="#Actuator-Security-执行器安全性" class="headerlink" title="Actuator Security(执行器安全性)"></a>Actuator Security(执行器安全性)</h3><p>出于安全考虑，默认情况下除了<code>/health</code>和<code>/info</code>禁用所有执行器。该<code>management.endpoints.web.exposure.include</code>属性可用于启用执行器。</p><p>如果春季安全是在类路径上，并没有其他WebSecurityConfigurerAdapter存在，比其他所有的驱动器<code>/health</code>，并<code>/info</code>通过春天开机自动配置安全。如果您定义自定义<code>WebSecurityConfigurerAdapter</code>，Spring Boot自动配置将退回，您将完全控制执行器访问规则。</p><blockquote><p>在设置之前<code>management.endpoints.web.exposure.include</code>，请确保暴露的执行器不包含敏感信息和/或通过将它们放在防火墙后面或通过Spring Security等方式进行保护。</p></blockquote><h4 id="跨站点请求伪造保护"><a href="#跨站点请求伪造保护" class="headerlink" title="跨站点请求伪造保护"></a>跨站点请求伪造保护</h4><p>由于Spring Boot依赖于Spring Security的默认值，因此默认情况下会启用CSRF保护。这意味着执行器端点需要<code>POST</code>（关闭和记录器端点），<code>PUT</code>或者<code>DELETE</code>在使用默认安全配置时将获得403禁止错误。</p><blockquote><p>我们建议仅在创建非浏览器客户端使用的服务时才完全禁用CSRF保护。</p></blockquote><p>有关CSRF保护的其他信息，请参阅“ <a href="https://docs.spring.io/spring-security/site/docs/5.1.4.RELEASE/reference/htmlsingle#csrf" target="_blank" rel="noopener">Spring Security参考指南”</a>。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-开发Web应用程序</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="开发Web应用程序"><a href="#开发Web应用程序" class="headerlink" title="开发Web应用程序"></a>开发Web应用程序</h2><p>Spring Boot非常适合Web应用程序开发。您可以使用嵌入式Tomcat，Jetty，Undertow或Netty创建自包含的HTTP服务器。大多数Web应用程序使用该<code>spring-boot-starter-web</code>模块快速启动和运行。您还可以选择使用该<code>spring-boot-starter-webflux</code>模块构建响应式Web应用程序 。</p><p>如果您还没有开发Spring Boot Web应用程序，可以按照“Hello World！”进行操作。“ <em>入门”</em>部分中的示例 。</p><h3 id="Spring-Web-MVC框架"><a href="#Spring-Web-MVC框架" class="headerlink" title="Spring Web MVC框架"></a>Spring Web MVC框架</h3><p>在<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">SpringWeb MVC框架</a>（通常简称为“SpringMVC”）是一个丰富的“模型视图控制器” Web框架。Spring MVC允许您创建特殊<code>@Controller</code>或<code>@RestController</code>bean来处理传入的HTTP请求。控制器中的方法通过使用<code>@RequestMapping</code>注释映射到HTTP 。</p><p>以下代码显示了<code>@RestController</code>为JSON数据提供服务的典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="meta">@RequestMapping</span>（value =“/ users”）</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping</span>（value =“/ &#123;user&#125;”，method = RequestMethod.GET）</span><br><span class="line"> <span class="keyword">public</span> User getUser（ <span class="meta">@PathVariable</span> Long user）&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>（value =“/ &#123;user&#125; / customers”，method = RequestMethod.GET） </span><br><span class="line">List &lt;Customer&gt; getUserCustomers（ <span class="meta">@PathVariable</span> Long user）&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>（value =“/ &#123;user&#125;”，method = RequestMethod.DELETE）</span><br><span class="line"> <span class="keyword">public</span> User deleteUser（ <span class="meta">@PathVariable</span> Long user）&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring MVC是核心Spring Framework的一部分，详细信息可在<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">参考文档中找到</a>。也有涵盖Spring MVC中提供一些指南<a href="https://spring.io/guides" target="_blank" rel="noopener">spring.io/guides</a>。</p><h4 id="Spring-MVC自动配置"><a href="#Spring-MVC自动配置" class="headerlink" title="Spring MVC自动配置"></a>Spring MVC自动配置</h4><p>Spring Boot为Spring MVC提供自动配置，适用于大多数应用程序。</p><p>自动配置在Spring的默认值之上添加了以下功能：</p><ul><li>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>豆类。</li><li>支持提供静态资源，包括对WebJars的支持（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">本文档稍后介绍</a>））。</li><li>自动注册<code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code>豆类。</li><li>支持<code>HttpMessageConverters</code>（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-message-converters" target="_blank" rel="noopener">本文档后面部分</a>）。</li><li>自动注册<code>MessageCodesResolver</code>（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-message-codes" target="_blank" rel="noopener">本文档后面部分</a>）。</li><li>静态<code>index.html</code>支持。</li><li>自定义<code>Favicon</code>支持（<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-favicon" target="_blank" rel="noopener">本文档稍后介绍</a>）。</li><li>自动使用<code>ConfigurableWebBindingInitializer</code>bean（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-web-binding-initializer" target="_blank" rel="noopener">本文档稍后介绍</a>）。</li></ul><p>如果您想保留Spring Boot MVC功能并且想要添加其他 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC配置</a>（拦截器，格式化程序，视图控制器和其他功能），您可以添加自己的<code>@Configuration</code>类类型<code>WebMvcConfigurer</code>但<strong>不需要</strong> <code>@EnableWebMvc</code>。如果您希望提供，或的 自定义实例<code>RequestMappingHandlerMapping</code>，则可以声明 实例以提供此类组件。<code>RequestMappingHandlerAdapter`</code>ExceptionHandlerExceptionResolver<code></code>WebMvcRegistrationsAdapter`</p><p>如果您想完全控制Spring MVC，可以添加自己的<code>@Configuration</code> 注释<code>@EnableWebMvc</code>。</p><h4 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h4><p>Spring MVC使用该<code>HttpMessageConverter</code>接口来转换HTTP请求和响应。明智的默认设置包含在开箱即用中。例如，对象可以自动转换为JSON（通过使用Jackson库）或XML（如果可用，则使用Jackson XML扩展，或者如果Jackson XML扩展不可用，则使用JAXB）。默认情况下，字符串是以编码的<code>UTF-8</code>。</p><p>如果需要添加或自定义转换器，可以使用Spring Boot的 <code>HttpMessageConverters</code>类，如下面的清单所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpMessageConverter</code>上下文中存在的任何bean都将添加到转换器列表中。您也可以以相同的方式覆盖默认转换器。</p><h4 id="自定义JSON序列化程序和反序列化程序"><a href="#自定义JSON序列化程序和反序列化程序" class="headerlink" title="自定义JSON序列化程序和反序列化程序"></a>自定义JSON序列化程序和反序列化程序</h4><p>如果您使用Jackson序列化和反序列化JSON数据，您可能希望编写自己的类<code>JsonSerializer</code>和<code>JsonDeserializer</code>类。自定义序列化程序通常 <a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers" target="_blank" rel="noopener">通过模块向Jackson注册</a>，但Spring Boot提供了另一种<code>@JsonComponent</code>注释，可以更容易地直接注册Spring Beans。</p><p>您可以<code>@JsonComponent</code>直接使用注释<code>JsonSerializer</code>或 <code>JsonDeserializer</code>实现。您还可以在包含序列化程序/反序列化程序作为内部类的类上使用它，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.jackson.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的所有<code>@JsonComponent</code>豆子都会<code>ApplicationContext</code>自动在杰克逊注册。因为<code>@JsonComponent</code>是元注释<code>@Component</code>，所以通常的组件扫描规则适用。</p><p>春季启动也提供 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java" target="_blank" rel="noopener"><code>JsonObjectSerializer</code></a>和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java" target="_blank" rel="noopener"><code>JsonObjectDeserializer</code></a>基础类，序列化对象时提供标准版本的杰克逊有用的替代。见 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html" target="_blank" rel="noopener"><code>JsonObjectSerializer</code></a>和<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html" target="_blank" rel="noopener"><code>JsonObjectDeserializer</code></a>在Javadoc了解详情。</p><h4 id="MessageCodesResolver"><a href="#MessageCodesResolver" class="headerlink" title="MessageCodesResolver"></a>MessageCodesResolver</h4><p>Spring MVC有一个生成错误代码的策略，用于从绑定错误中呈现错误消息：<code>MessageCodesResolver</code>。如果设置了<code>spring.mvc.message-codes-resolver.format</code>财产<code>PREFIX_ERROR_CODE</code>或 <code>POSTFIX_ERROR_CODE</code>春季启动为您创建一个（见枚举<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html" target="_blank" rel="noopener"><code>DefaultMessageCodesResolver.Format</code></a>）。</p><h4 id="静态内容"><a href="#静态内容" class="headerlink" title="静态内容"></a>静态内容</h4><p>默认情况下，Spring Boot从类路径中的<code>/static</code>（ <code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>）目录或者根目录中提供静态内容<code>ServletContext</code>。它使用<code>ResourceHttpRequestHandler</code>Spring MVC，以便您可以通过添加自己<code>WebMvcConfigurer</code>的<code>addResourceHandlers</code>方法来修改该行为并覆盖该 方法。</p><p>在独立的Web应用程序中，容器中的默认servlet也会启用，并作为后备，从<code>ServletContext</code>if 的根目录提供内容，决定不处理它。大多数情况下，这不会发生（除非你修改默认的MVC配置），因为Spring总是可以通过它来处理请求 <code>DispatcherServlet</code>。</p><p>默认情况下，会映射资源<code>/**</code>，但您可以使用该<code>spring.mvc.static-path-pattern</code>属性对其进行调整 。例如，重新定位所有资源 <code>/resources/**</code>可以实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.static-path-pattern = /resources/**</span><br></pre></td></tr></table></figure><p>您还可以使用该<code>spring.resources.static-locations</code>属性自定义静态资源位置 （将默认值替换为目录位置列表）。根Servlet上下文路径<code>&quot;/&quot;</code>也会自动添加为位置。</p><p>除了前面提到的“标准”静态资源位置之外，还为<a href="https://www.webjars.org/" target="_blank" rel="noopener">Webjars内容</a>制作了一个特例。具有路径的任何资源 <code>/webjars/**</code>都是从jar文件提供的，如果它们以Webjars格式打包的话。</p><blockquote><p><code>src/main/webapp</code>如果您的应用程序打包为jar，请不要使用该目录。虽然这个目录是一个通用的标准，它的工作原理<strong>只是</strong>war的包装，它是默默大多数构建工具忽略，如果你生成一个jar。</p></blockquote><p>Spring Boot还支持Spring MVC提供的高级资源处理功能，允许使用缓存破坏静态资源或使用与Webjars无关的URL。</p><p>要为Webjars使用版本无关的URL，请添加<code>webjars-locator-core</code>依赖项。然后声明你的Webjar。以jQuery为例，添加 <code>&quot;/webjars/jquery/jquery.min.js&quot;</code>结果 <code>&quot;/webjars/jquery/x.y.z/jquery.min.js&quot;</code>。<code>x.y.z</code>Webjar版本在哪里。</p><blockquote><p>如果你使用JBoss，你需要声明<code>webjars-locator-jboss-vfs</code> 依赖而不是<code>webjars-locator-core</code>。否则，所有Webjars都会解析为 <code>404</code>。</p></blockquote><p>要使用缓存清除，以下配置会为所有静态资源配置缓存清除解决方案，从而有效地<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>在URL中添加内容哈希，例如 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled = true</span><br><span class="line">spring.resources.chain.strategy.content.paths = /**</span><br></pre></td></tr></table></figure><blockquote><p>由于<code>ResourceUrlEncodingFilter</code>为Thymeleaf和FreeMarker自动配置了资源链接，因此在运行时会在模板中重写 。您应该在使用JSP时手动声明此过滤器。目前不支持其他模板引擎，但可以使用自定义模板宏/帮助程序和使用 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html" target="_blank" rel="noopener"><code>ResourceUrlProvider</code></a>。</p></blockquote><p>使用（例如）JavaScript模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也得到支持并可以合并的原因。“固定”策略在URL中添加静态版本字符串而不更改文件名，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled = true</span><br><span class="line">spring.resources.chain.strategy.content.paths = / **</span><br><span class="line">spring.resources.chain.strategy.fixed.enabled = true</span><br><span class="line">spring.resources.chain.strategy.fixed .paths = / js / lib /</span><br><span class="line">spring.resources.chain.strategy.fixed.version = v12</span><br></pre></td></tr></table></figure><p>使用此配置，JavaScript模块位于<code>&quot;/js/lib/&quot;</code>使用固定版本控制策略（<code>&quot;/v12/js/lib/mymodule.js&quot;</code>），而其他资源仍使用内容one（<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>）。</p><p>有关更多支持选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java" target="_blank" rel="noopener"><code>ResourceProperties</code></a> </p><blockquote><p>此功能已在专门的<a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources" target="_blank" rel="noopener">博客文章</a>和Spring Framework的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources" target="_blank" rel="noopener">参考文档中</a>进行了详细描述 。</p></blockquote><h4 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h4><p>Spring Boot支持静态和模板化欢迎页面。它首先<code>index.html</code>在配置的静态内容位置中查找 文件。如果找不到，则查找<code>index</code>模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。</p><h4 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h4><p>Spring Boot <code>favicon.ico</code>在配置的静态内容位置和类路径的根（按此顺序）中查找a 。如果存在这样的文件，它将自动用作应用程序的favicon。</p><h4 id="路径匹配和内容协商"><a href="#路径匹配和内容协商" class="headerlink" title="路径匹配和内容协商"></a>路径匹配和内容协商</h4><p>Spring MVC可以通过查看请求路径并将其与应用程序中定义的映射（例如，<code>@GetMapping</code> Controller方法上的注释）相匹配，将传入的HTTP请求映射到处理程序。</p><p>Spring Boot默认选择禁用后缀模式匹配，这意味着请求<code>&quot;GET /projects/spring-boot.json&quot;</code>不会与<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>映射匹配 。这被认为是<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match" target="_blank" rel="noopener">Spring MVC应用程序</a>的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match" target="_blank" rel="noopener">最佳实践</a>。对于没有发送正确“接受”请求标头的HTTP客户端，此功能在过去主要有用; 我们需要确保将正确的内容类型发送给客户端。如今，内容协商更加可靠。</p><p>还有其他方法可以处理不一致发送正确“接受”请求标头的HTTP客户端。我们可以使用查询参数来确保将请求<code>&quot;GET /projects/spring-boot?format=json&quot;</code> 映射到<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>以下内容，而不是使用后缀匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-parameter = true</span><br><span class="line"></span><br><span class="line">＃我们可以更改参数名称，默认为“format”：</span><br><span class="line">＃spring.mvc.contentnegotiation.parameter-name = myparam</span><br><span class="line"></span><br><span class="line">＃我们还可以注册其他文件扩展名/媒体类型：</span><br><span class="line">spring.mvc.contentnegotiation.media-types.markdown = text/markdown</span><br></pre></td></tr></table></figure><p>如果您了解警告并仍希望您的应用程序使用后缀模式匹配，则需要以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-path-extension = true</span><br><span class="line">spring.mvc.pathmatch.use-suffix-pattern = true</span><br></pre></td></tr></table></figure><p>或者，不是打开所有后缀模式，而是仅支持已注册的后缀模式更安全：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-path-extension = true</span><br><span class="line">spring.mvc.pathmatch.use-registered-suffix-pattern = true</span><br><span class="line"></span><br><span class="line">＃您还可以注册其他文件扩展名/媒体类型：</span><br><span class="line">＃spring.mvc.contentnegotiation.media-types.adoc = text/asciidoc</span><br></pre></td></tr></table></figure><h4 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h4><p>Spring MVC使用一个 <code>WebBindingInitializer</code>来初始化<code>WebDataBinder</code>特定请求。如果你自己创建<code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot会自动配置Spring MVC来使用它。</p><h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>除REST Web服务外，您还可以使用Spring MVC来提供动态HTML内容。Spring MVC支持各种模板技术，包括Thymeleaf，FreeMarker和JSP。此外，许多其他模板引擎包括他们自己的Spring MVC集成。</p><p>Spring Boot包括对以下模板引擎的自动配置支持：</p><ul><li><a href="https://freemarker.apache.org/docs/" target="_blank" rel="noopener">FreeMarker</a></li><li><a href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine" target="_blank" rel="noopener">Groovy</a></li><li><a href="http://www.thymeleaf.org/" target="_blank" rel="noopener">Thymeleaf</a></li><li><a href="https://mustache.github.io/" target="_blank" rel="noopener">Mustache</a></li></ul><blockquote><p>如果可能，应该避免使用JSP。将它们与嵌入式servlet容器一起使用时有几个 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-jsp-limitations" target="_blank" rel="noopener">已知的限制</a>。</p></blockquote><p>当您使用其中一个模板引擎和默认配置时，您的模板将自动从中获取<code>src/main/resources/templates</code>。</p><blockquote><p>根据您运行应用程序的方式，IntelliJ IDEA以不同方式对类路径进行排序。从主方法在IDE中运行应用程序会导致与使用Maven或Gradle或其打包的jar运行应用程序时的顺序不同。这可能导致Spring Boot无法在类路径中找到模板。如果遇到此问题，可以在IDE中重新排序类路径，以便首先放置模块的类和资源。或者，您可以配置模板前缀以搜索<code>templates</code>类路径上的每个目录，如下所示： <code>classpath*:/templates/</code>。</p></blockquote><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>默认情况下，Spring Boot提供了一个<code>/error</code>以合理方式处理所有错误的映射，并将其注册为servlet容器中的“全局”错误页面。对于计算机客户端，它会生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，有一个“whitelabel”错误视图，它以HTML格式呈现相同的数据（以自定义它，添加<code>View</code>解析后的数据<code>error</code>）。要完全替换默认行为，您可以实现 <code>ErrorController</code>并注册该类型的bean定义，或者添加类型的bean <code>ErrorAttributes</code>以使用现有机制但替换内容。</p><blockquote><p>在<code>BasicErrorController</code>可以用作自定义基类 <code>ErrorController</code>。如果要为新内容类型添加处理程序（默认情况下是<code>text/html</code>专门处理并为其他所有内容提供后备），这将特别有用。为此，请扩展<code>BasicErrorController</code>，添加<code>@RequestMapping</code>具有<code>produces</code>属性的公共方法 ，并创建新类型的bean。</p></blockquote><p>您还可以定义一个带注释的类，<code>@ControllerAdvice</code>以自定义要为特定控制器和/或异常类型返回的JSON文档，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(basePackageClasses = AcmeController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeControllerAdvice</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@ExceptionHandler</span>(YourException.class)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line">ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">HttpStatus status = getStatus(request);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> CustomErrorType(status.value(), ex.getMessage()), status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> HttpStatus <span class="title">getStatus</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Integer statusCode = (Integer) request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>);</span><br><span class="line"><span class="keyword">if</span> (statusCode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的示例中，如果<code>YourException</code>由在同一个包中定义的控制器抛出，则使用POJO <code>AcmeController</code>的JSON表示<code>CustomErrorType</code>而不是<code>ErrorAttributes</code>表示。</p><p><strong>自定义错误页面</strong></p><p>如果要显示给定状态代码的自定义HTML错误页面，可以将文件添加到文件<code>/error</code>夹。错误页面可以是静态HTML（即，添加到任何静态资源文件夹下），也可以使用模板构建。文件名应该是确切的状态代码或系列掩码。</p><p>例如，要映射<code>404</code>到静态HTML文件，您的文件夹结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure><p>要<code>5xx</code>使用FreeMarker模板映射所有错误，您的文件夹结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.ftl</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure><p>对于更复杂的映射，您还可以添加实现该<code>ErrorViewResolver</code> 接口的bean ，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorViewResolver</span> <span class="keyword">implements</span> <span class="title">ErrorViewResolver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Use the request or status to optionally return a ModelAndView</span></span><br><span class="line"><span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以使用常规的Spring MVC功能，例如 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers" target="_blank" rel="noopener"><code>@ExceptionHandler</code>方法</a>和 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice" target="_blank" rel="noopener"><code>@ControllerAdvice</code></a>。在 <code>ErrorController</code>随后拿起任何未处理的异常。</p><p><strong>映射Spring MVC之外的错误页面</strong></p><p>对于不使用Spring MVC的应用程序，可以使用该<code>ErrorPageRegistrar</code> 接口直接注册<code>ErrorPages</code>。这种抽象直接与底层嵌入式servlet容器一起工作，即使你没有Spring MVC也可以工作 <code>DispatcherServlet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ErrorPageRegistrar <span class="title">errorPageRegistrar</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyErrorPageRegistrar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorPageRegistrar</span> <span class="keyword">implements</span> <span class="title">ErrorPageRegistrar</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</span><br><span class="line">registry.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">"/400"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果您注册的<code>ErrorPage</code>路径最终由a处理<code>Filter</code> （与一些非Spring Web框架（如Jersey和Wicket）一样），那么 <code>Filter</code>必须将其显式注册为<code>ERROR</code>调度程序，如以下示例所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">registration.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">...</span><br><span class="line">registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class="line"><span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，默认值<code>FilterRegistrationBean</code>不包括<code>ERROR</code>调度程序类型。</p><p>小心：当部署到servlet容器时，Spring Boot使用其错误页面过滤器将具有错误状态的请求转发到相应的错误页面。如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0及更高版本在成功完成servlet的服务方法后提交响应。您应该通过设置<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>为禁用此行为 <code>false</code>。</p><h4 id="Spring-HATEOAS"><a href="#Spring-HATEOAS" class="headerlink" title="Spring HATEOAS"></a>Spring HATEOAS</h4><p>如果您开发使用超媒体的RESTful API，Spring Boot为Spring HATEOAS提供自动配置，适用于大多数应用程序。自动配置取代了使用<code>@EnableHypermediaSupport</code>和注册多个bean 的需要，以便于构建基于超媒体的应用程序，包括 <code>LinkDiscoverers</code>（用于客户端支持）和<code>ObjectMapper</code>配置为正确编组响应到所需表示的响应。的<code>ObjectMapper</code>是通过设置各种定制的<code>spring.jackson.*</code>属性，或者，如果存在的话，通过一个<code>Jackson2ObjectMapperBuilder</code>豆。</p><p>您可以使用控制Spring HATEOAS的配置 <code>@EnableHypermediaSupport</code>。请注意，这样做会禁用<code>ObjectMapper</code>前面描述的自定义。</p><h4 id="CORS支持"><a href="#CORS支持" class="headerlink" title="CORS支持"></a>CORS支持</h4><p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank" rel="noopener">跨源资源共享</a> （CORS）是<a href="https://caniuse.com/#feat=cors" target="_blank" rel="noopener">大多数浏览器</a>实现 的<a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener">W3C规范</a>，允许您以灵活的方式指定授权何种跨域请求，而不是使用一些安全性较低且功能较弱的方法，如IFRAME或JSONP。</p><p>从版本4.2开始，Spring MVC <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#cors" target="_blank" rel="noopener">支持CORS</a>。 在Spring Boot应用程序中使用带有 注释的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#controller-method-cors-configuration" target="_blank" rel="noopener">控制器方法CORS配置</a><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html" target="_blank" rel="noopener"><code>@CrossOrigin</code></a>不需要任何特定配置。 可以通过使用自定义方法注册bean 来定义<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#global-cors-configuration" target="_blank" rel="noopener">全局CORS配置</a>，如以下示例所示：<code>WebMvcConfigurer</code>. <code>addCorsMappings(CorsRegistry)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">registry.addMapping(<span class="string">"/api/**"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-WebFlux框架"><a href="#Spring-WebFlux框架" class="headerlink" title="Spring WebFlux框架"></a>Spring WebFlux框架</h3><p>Spring WebFlux是Spring Framework 5.0中引入的新的响应式Web框架。与Spring MVC不同，它不需要Servlet API，完全异步且无阻塞，并 通过<a href="https://projectreactor.io/" target="_blank" rel="noopener">Reactor项目</a>实现<a href="http://www.reactive-streams.org/" target="_blank" rel="noopener">Reactive Streams</a>规范。</p><p>Spring WebFlux有两种版本：基于功能和注释。基于注释的注释非常接近Spring MVC模型，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;user&#125;/customers"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">deleteUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“WebFlux.fn”是功能变体，它将路由配置与请求的实际处理分开，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">monoRouterFunction</span><span class="params">(UserHandler userHandler)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> route(GET(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">                .and(accept(APPLICATION_JSON)), userHandler::getUser)</span><br><span class="line">.andRoute(GET(<span class="string">"/&#123;user&#125;/customers"</span>)</span><br><span class="line">                .and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)</span><br><span class="line">.andRoute(DELETE(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">                .and(accept(APPLICATION_JSON)), userHandler::deleteUser);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUserCustomers</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">deleteUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebFlux是Spring Framework的一部分，详细信息可在其 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn" target="_blank" rel="noopener">参考文档中找到</a>。</p><blockquote><p>您可以根据需要定义任意数量的<code>RouterFunction</code>bean来模块化路由器的定义。如果需要应用优先级，可以订购Bean。</p></blockquote><p>要开始，请将<code>spring-boot-starter-webflux</code>模块添加到您的应用程序中。</p><blockquote><p>在应用程序中添加两个<code>spring-boot-starter-web</code>和<code>spring-boot-starter-webflux</code>模块会导致Spring Boot自动配置Spring MVC，而不是WebFlux。选择此行为是因为许多Spring开发人员<code>spring-boot-starter-webflux</code> 在其Spring MVC应用程序中添加了使用被动的<code>WebClient</code>。您仍然可以通过将所选应用程序类型设置为来强制执行您的选择<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code>。</p></blockquote><h4 id="Spring-WebFlux自动配置"><a href="#Spring-WebFlux自动配置" class="headerlink" title="Spring WebFlux自动配置"></a>Spring WebFlux自动配置</h4><p>Spring Boot为Spring WebFlux提供自动配置，适用于大多数应用程序。</p><p>自动配置在Spring的默认值之上添加了以下功能：</p><ul><li>为for <code>HttpMessageReader</code>和<code>HttpMessageWriter</code>实例配置编解码器（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webflux-httpcodecs" target="_blank" rel="noopener">在本文档后面介绍</a>）。</li><li>支持提供静态资源，包括对WebJars的支持（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">在本文档后面介绍</a>）。</li></ul><p>如果你想保留Spring Boot WebFlux功能，并且想要添加额外的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#web-reactive" target="_blank" rel="noopener">WebFlux配置</a>，你可以添加自己的 <code>@Configuration</code>类类<code>WebFluxConfigurer</code>但<strong>不需要</strong><code>@EnableWebFlux</code>。</p><p>如果您想完全控制Spring WebFlux，可以添加自己的 <code>@Configuration</code>注释<code>@EnableWebFlux</code>。</p><h4 id="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器"><a href="#带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器" class="headerlink" title="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器"></a>带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</h4><p>Spring WebFlux使用<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>接口转换HTTP请求和响应。<code>CodecConfigurer</code>通过查看类路径中可用的库，它们被配置为具有合理的默认值。</p><p>Spring Boot通过使用<code>CodecCustomizer</code>实例进一步自定义。例如，<code>spring.jackson.*</code>配置密钥应用于Jackson编解码器。</p><p>如果需要添加或自定义编解码器，可以创建自定义<code>CodecCustomizer</code> 组件，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.codec.CodecCustomizer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CodecCustomizer <span class="title">myCodecCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> codecConfigurer -&gt; &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以利用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-json-components" target="_blank" rel="noopener">Boot的自定义JSON序列化程序和反序列化程序</a>。</p><h4 id="静态内容-1"><a href="#静态内容-1" class="headerlink" title="静态内容"></a>静态内容</h4><p>默认情况下，Spring Boot从类路径中名为<code>/static</code>（ <code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>）的目录中提供静态内容。它使用<code>ResourceWebHandler</code>Spring WebFlux，以便您可以通过添加自己<code>WebFluxConfigurer</code>的<code>addResourceHandlers</code>方法来修改该行为并覆盖该方法。</p><p>默认情况下，映射资源<code>/**</code>，但您可以通过设置<code>spring.webflux.static-path-pattern</code>属性来调整它 。例如，重新定位所有资源 <code>/resources/**</code>可以实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.webflux.static-path-pattern = /resources/**</span><br></pre></td></tr></table></figure><p>您还可以使用自定义静态资源位置 <code>spring.resources.static-locations</code>。这样做会将默认值替换为目录位置列表。如果这样做，默认的欢迎页面检测将切换到您的自定义位置。因此，如果<code>index.html</code>您的任何位置在启动时存在，则它是应用程序的主页。</p><p>除了前面列出的“标准”静态资源位置之外，还为<a href="https://www.webjars.org/" target="_blank" rel="noopener">Webjars内容</a>制作了一个特例。具有路径的任何资源 <code>/webjars/**</code>都是从jar文件提供的，如果它们以Webjars格式打包的话。</p><blockquote><p>Spring WebFlux应用程序并不严格依赖于Servlet API，因此它们不能作为war文件部署，也不能使用该<code>src/main/webapp</code>目录。</p></blockquote><h4 id="模板引擎-1"><a href="#模板引擎-1" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>除REST Web服务外，您还可以使用Spring WebFlux来提供动态HTML内容。Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker和Mustache。</p><p>Spring Boot包括对以下模板引擎的自动配置支持：</p><ul><li><a href="https://freemarker.apache.org/docs/" target="_blank" rel="noopener">FreeMarker</a></li><li><a href="http://www.thymeleaf.org/" target="_blank" rel="noopener">Thymeleaf</a></li><li><a href="https://mustache.github.io/" target="_blank" rel="noopener">Mustache</a></li></ul><p>当您使用其中一个模板引擎和默认配置时，您的模板将自动从中获取<code>src/main/resources/templates</code>。</p><h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>Spring Boot提供了<code>WebExceptionHandler</code>一种以合理的方式处理所有错误的方法。它在处理顺序中的位置紧接在WebFlux提供的处理程序之前，这些处理程序被认为是最后一个。对于计算机客户端，它会生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，有一个“whitelabel”错误处理程序，它以HTML格式呈现相同的数据。您还可以提供自己的HTML模板来显示错误（请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webflux-error-handling-custom-error-pages" target="_blank" rel="noopener">下一节</a>）。</p><p>自定义此功能的第一步通常涉及使用现有机制，但替换或扩充错误内容。为此，您可以添加类型的bean <code>ErrorAttributes</code>。</p><p>要更改错误处理行为，可以实现<code>ErrorWebExceptionHandler</code>并注册该类型的bean定义。由于a <code>WebExceptionHandler</code>是一个非常低级的，Spring Boot还提供了一个方便<code>AbstractErrorWebExceptionHandler</code>的让你以WebFlux功能方式处理错误，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomErrorWebExceptionHandler</span> <span class="keyword">extends</span> <span class="title">AbstractErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//在这里定义构造函数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RouterFunctions</span><br><span class="line">.route(aPredicate, aHandler)</span><br><span class="line">.andRoute(anotherPredicate, anotherHandler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要获得更完整的图片，您还可以<code>DefaultErrorWebExceptionHandler</code> 直接子类化并覆盖特定方法。</p><p><strong>自定义错误页面</strong></p><p>如果要显示给定状态代码的自定义HTML错误页面，可以将文件添加到文件<code>/error</code>夹。错误页面可以是静态HTML（即，添加到任何静态资源文件夹下）或使用模板构建。文件名应该是确切的状态代码或系列掩码。</p><p>例如，要映射<code>404</code>到静态HTML文件，您的文件夹结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure><p>要<code>5xx</code>使用<code>Mustache</code>模板映射所有错误，您的文件夹结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.mustache</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure><h4 id="Web过滤器"><a href="#Web过滤器" class="headerlink" title="Web过滤器"></a>Web过滤器</h4><p>Spring WebFlux提供了一个<code>WebFilter</code>可以实现过滤HTTP请求 - 响应交换的接口。<code>WebFilter</code>在应用程序上下文中找到的bean将自动用于过滤每个交换。</p><p>如果过滤器的顺序很重要，则可以实现<code>Ordered</code>或注释<code>@Order</code>。Spring Boot自动配置可以为您配置Web过滤器。执行此操作时，将使用下表中显示的订单：</p><table><thead><tr><th style="text-align:center">Web Filter</th><th style="text-align:center">Order</th></tr></thead><tbody><tr><td style="text-align:center"><code>MetricsWebFilter</code></td><td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td></tr><tr><td style="text-align:center"><code>WebFilterChainProxy</code> （spring Security）</td><td style="text-align:center"><code>-100</code></td></tr><tr><td style="text-align:center"><code>HttpTraceWebFilter</code></td><td style="text-align:center"><code>Ordered.LOWEST_PRECEDENCE - 10</code></td></tr></tbody></table><h3 id="JAX-RS-and-Jersey"><a href="#JAX-RS-and-Jersey" class="headerlink" title="JAX-RS and Jersey"></a>JAX-RS and Jersey</h3><p>如果您更喜欢REST端点的JAX-RS编程模型，则可以使用其中一个可用的实现而不是Spring MVC。<a href="https://jersey.github.io/" target="_blank" rel="noopener">Jersey</a>和 <a href="https://cxf.apache.org/" target="_blank" rel="noopener">Apache CXF</a>开箱即用。CXF要求您在应用程序上下文中注册<code>Servlet</code>或<code>Filter</code>作为其注册<code>@Bean</code>。Jersey有一些原生的Spring支持，因此我们还在Spring Boot中为它提供了自动配置支持以及启动器。</p><p>要开始使用Jersey，请将其<code>spring-boot-starter-jersey</code>作为依赖项包含在内，然后您需要一个注册所有端点<code>@Bean</code>的类型<code>ResourceConfig</code>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyConfig</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JerseyConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">register(Endpoint.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Jersey对扫描可执行档案的支持相当有限。例如，它无法扫描<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#deployment-install" target="_blank" rel="noopener">完全可执行jar文件</a>中的包中或<code>WEB-INF/classes</code>运行可执行war文件时的端点。为避免此限制，<code>packages</code>不应使用该方法，并且应使用该<code>register</code>方法单独注册端点，如上例所示。</p></blockquote><p>对于更高级的自定义，您还可以注册实现的任意数量的bean <code>ResourceConfigCustomizer</code>。</p><p>所有已注册的端点都应<code>@Components</code>使用HTTP资源注释（<code>@GET</code>和其他），如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line"><span class="meta">@GET</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Endpoint</code>是Spring <code>@Component</code>，它的生命周期由Spring管理，您可以使用<code>@Autowired</code>注释注入依赖项并使用<code>@Value</code> 注释注入外部配置。默认情况下，Jersey servlet已注册并映射到<code>/*</code>。您可以通过添加<code>@ApplicationPath</code>到您 的地图来更改映射<code>ResourceConfig</code>。</p><p>默认情况下，Jersey被设置为 名为<code>@Bean</code>的类型的Servlet 。默认情况下，servlet是懒惰地初始化的，但您可以通过设置来自定义该行为。您可以通过创建具有相同名称的bean来禁用或覆盖该bean。您还可以通过设置（在这种情况下，替换或覆盖是）来使用过滤器而不是servlet 。过滤器有一个，您可以设置。通过使用指定属性的映射，可以为servlet和过滤器注册提供init参数。<code>ServletRegistrationBean</code> <code>jerseyServletRegistration</code> <code>spring.jersey.servlet.load-on-startup</code> <code>spring.jersey.type=filter</code> <code>@Bean</code> <code>jerseyFilterRegistration</code> <code>@Order</code> <code>spring.jersey.filter.order</code> <code>spring.jersey.init.*</code></p><p>有一个<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/spring-boot-sample-jersey" target="_blank" rel="noopener">Jersey sample</a>以便您可以看到如何设置。</p><h3 id="嵌入式Servlet容器支持"><a href="#嵌入式Servlet容器支持" class="headerlink" title="嵌入式Servlet容器支持"></a>嵌入式Servlet容器支持</h3><p>Spring Boot包括对嵌入式<a href="https://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat</a>， <a href="https://www.eclipse.org/jetty/" target="_blank" rel="noopener">Jetty</a>和<a href="http://undertow.io/" target="_blank" rel="noopener">Undertow</a>服务器的支持。大多数开发人员使用适当的“Starter”来获取完全配置的实例。默认情况下，嵌入式服务器侦听端口上的HTTP请求<code>8080</code>。</p><blockquote><p>如果您选择在<a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a>上使用Tomcat ，请注意，默认情况下，临时目录用于存储已编译的JSP，文件上载等。<code>tmpwatch</code>应用程序运行时可能会删除此目录，从而导致失败。要避免此行为，您可能希望自定义<code>tmpwatch</code>配置，以便<code>tomcat.*</code>不删除或配置目录以<code>server.tomcat.basedir</code>使嵌入式Tomcat使用其他位置。</p></blockquote><h4 id="Servlet，Filter和Listeners"><a href="#Servlet，Filter和Listeners" class="headerlink" title="Servlet，Filter和Listeners"></a>Servlet，Filter和Listeners</h4><p>使用嵌入式servlet容器时，可以<code>HttpSessionListener</code>通过使用Spring bean或扫描Servlet组件，从Servlet规范中注册servlet，过滤器和所有侦听器（如HttpSessionListener）。</p><p><strong>将Servlet，过滤器和监听器注册为Spring Bean</strong></p><p>作为Spring bean的任何<code>Servlet</code>，<code>Filter</code>或者servlet <code>*Listener</code>实例都是在嵌入式容器中注册的。如果要从<code>application.properties</code>配置期间引用值，这可能特别方便。</p><p>默认情况下，如果上下文仅包含一个Servlet，则将其映射到<code>/</code>。在多个servlet bean的情况下，bean名称用作路径前缀。过滤器映射到 <code>/*</code>。</p><p>如果以公约为基础测绘不够灵活，你可以使用 <code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>以及 <code>ServletListenerRegistrationBean</code>类的完全控制。</p><p>Spring Boot附带了许多可以定义Filter bean的自动配置。以下是过滤器及其各自顺序的一些示例（较低的顺序值表示较高的优先级）：</p><table><thead><tr><th style="text-align:center">ServletFilter</th><th style="text-align:center">Order</th></tr></thead><tbody><tr><td style="text-align:center"><code>OrderedCharacterEncodingFilter</code></td><td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE</code></td></tr><tr><td style="text-align:center"><code>WebMvcMetricsFilter</code></td><td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td></tr><tr><td style="text-align:center"><code>ErrorPageFilter</code></td><td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td></tr><tr><td style="text-align:center"><code>HttpTraceFilter</code></td><td style="text-align:center"><code>Ordered.LOWEST_PRECEDENCE - 10</code></td></tr></tbody></table><p>将Filter beans无序放置通常是安全的。</p><p>如果需要特定的顺序，则应避免配置读取请求主体的过滤器<code>Ordered.HIGHEST_PRECEDENCE</code>，因为它可能违反应用程序的字符编码配置。如果Servlet过滤器包装请求，则应使用小于或等于的顺序进行配置 <code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>。</p><h4 id="Servlet上下文初始化"><a href="#Servlet上下文初始化" class="headerlink" title="Servlet上下文初始化"></a>Servlet上下文初始化</h4><p>嵌入式servlet容器不直接执行Servlet 3.0+ <code>javax.servlet.ServletContainerInitializer</code>接口或Spring<code>org.springframework.web.WebApplicationInitializer</code>接口。这是一个有意的设计决策，旨在降低设计在战争中运行的第三方库可能会破坏Spring Boot应用程序的风险。</p><p>如果需要在Spring Boot应用程序中执行servlet上下文初始化，则应注册实现该<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的bean 。单一<code>onStartup</code>方法提供对s的访问，<code>ServletContext</code>并且如果需要，可以轻松地用作现有的适配器<code>WebApplicationInitializer</code>。</p><p><strong>扫描Servlet，过滤器和侦听器</strong></p><p>当使用嵌入式容器中，类自动登记注释有 <code>@WebServlet</code>，<code>@WebFilter</code>和<code>@WebListener</code>可以通过使用被使能 <code>@ServletComponentScan</code>。</p><blockquote><p><code>@ServletComponentScan</code> 在独立容器中没有任何效果，而是使用容器的内置发现机制。</p></blockquote><h4 id="ServletWebServerApplicationContext"><a href="#ServletWebServerApplicationContext" class="headerlink" title="ServletWebServerApplicationContext"></a>ServletWebServerApplicationContext</h4><p>在引擎盖下，Spring Boot使用不同类型的<code>ApplicationContext</code>嵌入式servlet容器支持。该<code>ServletWebServerApplicationContext</code>是一种特殊类型的<code>WebApplicationContext</code>通过搜索单说引导自身 <code>ServletWebServerFactory</code>豆。通常是<code>TomcatServletWebServerFactory</code>,,<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code> 已经自动配置。</p><blockquote><p>您通常不需要了解这些实现类。大多数应用程序都自动配置，并适当的<code>ApplicationContext</code>和 <code>ServletWebServerFactory</code>以您的名义创建。</p></blockquote><h4 id="自定义嵌入式Servlet容器"><a href="#自定义嵌入式Servlet容器" class="headerlink" title="自定义嵌入式Servlet容器"></a>自定义嵌入式Servlet容器</h4><p>可以使用Spring <code>Environment</code> 属性配置公共servlet容器设置。通常，您将在<code>application.properties</code> 文件中定义属性。</p><p>常用服务器设置包括：</p><ul><li>网络设置：侦听传入HTTP请求的端口（<code>server.port</code>），要绑定的接口地址<code>server.address</code>等等。</li><li>会话设置：会话是持久性（<code>server.servlet.session.persistence</code>），会话超时（<code>server.servlet.session.timeout</code>），会话数据（<code>server.servlet.session.store-dir</code>）的位置以及会话cookie配置（<code>server.servlet.session.cookie.*</code>）。</li><li>错误管理：错误页面的位置（<code>server.error.path</code>）等。</li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-ssl" target="_blank" rel="noopener">SSL</a></li><li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#how-to-enable-http-response-compression" target="_blank" rel="noopener">HTTP compression</a></li></ul><p>Spring Boot尽可能尝试公开常见设置，但这并不总是可行。对于这些情况，专用命名空间提供特定于服务器的自定义（请参阅 <code>server.tomcat</code>和<code>server.undertow</code>）。例如， 可以使用嵌入式servlet容器的特定功能配置<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-accesslogs" target="_blank" rel="noopener">访问日志</a>。</p><blockquote><p>请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java" target="_blank" rel="noopener"><code>ServerProperties</code></a>课程以获取完整列表。</p></blockquote><p><strong>程序化定制</strong></p><p>如果需要以编程方式配置嵌入式servlet容器，可以注册实现该<code>WebServerFactoryCustomizer</code>接口的Spring bean 。 <code>WebServerFactoryCustomizer</code>提供对其的访问 <code>ConfigurableServletWebServerFactory</code>，其中包括许多自定义setter方法。以下示例以编程方式设置端口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationBean</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">server.setPort(<span class="number">9000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>并且<code>UndertowServletWebServerFactory</code> 是专用变体，<code>ConfigurableServletWebServerFactory</code>分别为Tomcat，Jetty和Undertow提供了额外的自定义setter方法。</p></blockquote><p><strong>直接自定义ConfigurableServletWebServerFactory</strong></p><p>如果前面的定制技术太有限，你可以注册 <code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或 <code>UndertowServletWebServerFactory</code> bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableServletWebServerFactory <span class="title">webServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">factory.setPort(<span class="number">9000</span>);</span><br><span class="line">factory.setSessionTimeout(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">factory.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/notfound.html"</span>));</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为许多配置选项提供了Setter。如果您需要做一些更具异国情调的事情，还会提供一些受保护的方法“挂钩”。有关详细信息，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html" target="_blank" rel="noopener">源代码文档</a>。</p><h4 id="JSP限制"><a href="#JSP限制" class="headerlink" title="JSP限制"></a>JSP限制</h4><p>运行使用嵌入式servlet容器的Spring Boot应用程序（并打包为可执行存档）时，JSP支持存在一些限制。</p><ul><li>使用Jetty和Tomcat，如果使用war包装，它应该可以工作。可执行的war将在启动时运行<code>java -jar</code>，并且也可以部署到任何标准容器。使用可执行jar时不支持JSP。</li><li>Undertow不支持JSP。</li><li>创建自定义<code>error.jsp</code>页面不会覆盖<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-error-handling" target="_blank" rel="noopener">错误处理</a>的默认视图 。 应该使用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-error-handling-custom-error-pages" target="_blank" rel="noopener">自定义错误页面</a>。</li></ul><p>有一个<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp" target="_blank" rel="noopener">JSP示例</a>以便您可以看到如何设置。</p><h3 id="嵌入式Reactive-Server支持"><a href="#嵌入式Reactive-Server支持" class="headerlink" title="嵌入式Reactive Server支持"></a>嵌入式Reactive Server支持</h3><p>Spring Boot包括对以下嵌入式响应式Web服务器的支持：Reactor Netty，Tomcat，Jetty和Undertow。大多数开发人员使用适当的“Starter”来获取完全配置的实例。默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p><h3 id="Reactive-Server资源配置"><a href="#Reactive-Server资源配置" class="headerlink" title="Reactive Server资源配置"></a>Reactive Server资源配置</h3><p>在自动配置Reactor Netty或Jetty服务器时，Spring Boot将创建特定的bean，为服务器实例提供HTTP资源：<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>。</p><p>默认情况下，这些资源也将与Reactor Netty和Jetty客户端共享，以获得最佳性能，具体如下：</p><ul><li>相同的技术用于服务器和客户端</li><li>客户端实例是使用<code>WebClient.Builder</code>Spring Boot自动配置的bean 构建的</li></ul><p>开发人员可以通过提供自定义<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>bean 来覆盖Jetty和Reactor Netty的资源配置- 这将应用于客户端和服务器。</p><p>您可以在<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webclient-runtime" target="_blank" rel="noopener">WebClient Runtime</a>部分中了解有关客户端资源配置的更多信息 。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-JSON</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-JSON/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-JSON/</url>
      
        <content type="html"><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>Spring Boot提供了与三个JSON映射库的集成：</p><ul><li>GSON</li><li>Jackson</li><li>JSON-B</li></ul><p>Jackson是首选的默认库</p><h3 id="jackson"><a href="#jackson" class="headerlink" title="jackson"></a>jackson</h3><p>提供杰克逊的自动配置，杰克逊是其中的一部分 <code>spring-boot-starter-json</code>。当Jackson在类路径上时，<code>ObjectMapper</code> 会自动配置bean。提供了几个配置属性来自 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-customize-the-jackson-objectmapper" target="_blank" rel="noopener">定义配置 <code>ObjectMapper</code></a>。</p><h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>提供Gson的自动配置。当Gson在类路径上时，<code>Gson</code>会自动配置bean。<code>spring.gson.*</code>提供了几个配置属性来自定义配置。为了获得更多控制，<code>GsonBuilderCustomizer</code>可以使用一个或多个 bean。</p><h3 id="JSON-B"><a href="#JSON-B" class="headerlink" title="JSON-B"></a>JSON-B</h3><p>提供Gson的自动配置。当Gson在类路径上时，<code>Gson</code>会自动配置bean。<code>spring.gson.*</code>提供了几个配置属性来自定义配置。为了获得更多控制，<code>GsonBuilderCustomizer</code>可以使用一个或多个 bean。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-国际化</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E5%9B%BD%E9%99%85%E5%8C%96/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E5%9B%BD%E9%99%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>Spring Boot支持本地化消息，以便您的应用程序可以满足不同语言首选项的用户。默认情况下，Spring Boot会<code>messages</code>在类路径的根目录中查找资源包的存在。</p><blockquote><p>当配置的资源包的默认属性文件可用时（即<code>messages.properties</code>默认情况下），将应用自动配置。如果资源包仅包含特定于语言的属性文件，则需要添加默认值。</p></blockquote><p>可以使用<code>spring.messages</code>命名空间配置资源包的基本名称以及其他几个属性，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.basename = messages，config.i18n.messages</span><br><span class="line">spring.messages.fallback-to-system-locale = false</span><br></pre></td></tr></table></figure><blockquote><p><code>spring.messages.basename</code> 支持以逗号分隔的位置列表，包括限定符或从类路径根解析的资源。</p></blockquote><p>有关更多支持选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.java" target="_blank" rel="noopener"> <code>MessageSourceProperties</code></a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> i18n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Logging</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Logging/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Logging/</url>
      
        <content type="html"><![CDATA[<h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h2><p>Spring Boot使用<a href="https://commons.apache.org/logging" target="_blank" rel="noopener">Commons Logging</a>进行所有内部日志记录，但保留底层日志实现。为<a href="https://docs.oracle.com/javase/8/docs/api//java/util/logging/package-summary.html" target="_blank" rel="noopener">Java Util Logging</a>，<a href="https://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">Log4J2</a>和 <a href="http://logback.qos.ch/" target="_blank" rel="noopener">Logback</a>提供了默认配置 。在每种情况下，记录器都预先配置为使用控制台输出，并且还提供可选的文件输出。</p><p>默认情况下，如果使用“Starters”，则使用Logback进行日志记录。还包括适当的Logback路由，以确保使用Java Util Logging，Commons Logging，Log4J或SLF4J的依赖库都能正常工作。</p><blockquote><p>Java有很多日志框架可供使用。如果以上列表看起来令人困惑，请不要担心。通常，您不需要更改日志记录依赖项，并且Spring Boot默认值可以正常工作。</p></blockquote><h3 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class="line">2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class="line">2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]</span><br><span class="line">2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]</span><br></pre></td></tr></table></figure><p>输出以下信息：</p><ul><li>日期和时间：毫秒精度，易于排序。</li><li>日志级别：<code>ERROR</code>，<code>WARN</code>，<code>INFO</code>，<code>DEBUG</code>，或<code>TRACE</code>。</li><li>进程ID。</li><li>一个<code>---</code>分离器来区分实际日志消息的开始。</li><li>线程名称：用方括号括起来（可能会截断控制台输出）。</li><li>记录器名称：这通常是源类名称（通常缩写）。</li><li>日志消息。</li></ul><blockquote><p>Logback没有<code>FATAL</code>级别。它映射到<code>ERROR</code>。</p></blockquote><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>默认日志配置会在写入时将消息回显到控制台。默认情况下，会记录<code>ERROR</code>-level，<code>WARN</code>-level和<code>INFO</code>-level消息。您还可以通过使用<code>--debug</code>标志启动应用程序来启用“调试”模式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> java -jar myapp.jar --debug</span><br></pre></td></tr></table></figure><blockquote><p>你也可以<code>debug=true</code>在你的指定<code>application.properties</code>。</p></blockquote><p>启用调试模式后，将选择一些核心记录器（嵌入式容器，Hibernate和Spring Boot）以输出更多信息。启用调试模式并<em>没有</em>配置您的应用程序记录所有消息<code>DEBUG</code>的水平。</p><p>或者，您可以通过使用<code>--trace</code>标志（或<code>trace=true</code>在您的应用程序中）启动应用程序来启用“跟踪”模式 <code>application.properties</code>。这样做可以为选择的核心记录器（嵌入式容器，Hibernate模式生成和整个Spring组合）启用跟踪日志记录。</p><h3 id="彩色编码输出"><a href="#彩色编码输出" class="headerlink" title="彩色编码输出"></a>彩色编码输出</h3><p>如果您的终端支持ANSI，则使用颜色输出来提高可读性。您可以设置 <code>spring.output.ansi.enabled</code>为 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/ansi/AnsiOutput.Enabled.html" target="_blank" rel="noopener">支持的值</a>以覆盖自动检测。</p><p>通过使用<code>%clr</code>转换字配置颜色编码。在最简单的形式中，转换器根据日志级别为输出着色，如以下示例所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span>clr(%5p)</span><br></pre></td></tr></table></figure><p>下表描述了日志级别到颜色的映射：</p><table><thead><tr><th style="text-align:center">水平</th><th style="text-align:center">颜色</th></tr></thead><tbody><tr><td style="text-align:center"><code>FATAL</code></td><td style="text-align:center">红色</td></tr><tr><td style="text-align:center"><code>ERROR</code></td><td style="text-align:center">红色</td></tr><tr><td style="text-align:center"><code>WARN</code></td><td style="text-align:center">黄色</td></tr><tr><td style="text-align:center"><code>INFO</code></td><td style="text-align:center">绿色</td></tr><tr><td style="text-align:center"><code>DEBUG</code></td><td style="text-align:center">绿色</td></tr><tr><td style="text-align:center"><code>TRACE</code></td><td style="text-align:center">绿色</td></tr></tbody></table><p>或者，您可以通过将其作为转换选项指定应使用的颜色或样式。例如，要使文本变为黄色，请使用以下设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span>clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;yellow&#125;</span><br></pre></td></tr></table></figure><p>支持以下颜色和样式：</p><ul><li><code>blue</code></li><li><code>cyan</code></li><li><code>faint</code></li><li><code>green</code></li><li><code>magenta</code></li><li><code>red</code></li><li><code>yellow</code></li></ul><h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3><p>默认情况下，Spring Boot仅记录到控制台，不会写入日志文件。如果除了控制台输出之外还要编写日志文件，则需要设置 <code>logging.file</code>或<code>logging.path</code>属性（例如，在您的中 <code>application.properties</code>）。</p><p>下表显示了如何<code>logging.*</code>一起使用这些属性：</p><p><strong>记录属性</strong></p><table><thead><tr><th style="text-align:center"><code>logging.file</code></th><th style="text-align:center"><code>logging.path</code></th><th style="text-align:center">例子</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><em>（没有）</em></td><td style="text-align:center"><em>（没有）</em></td><td style="text-align:center"></td><td style="text-align:center">仅控制台记录。</td></tr><tr><td style="text-align:center">具体文件</td><td style="text-align:center"><em>（没有）</em></td><td style="text-align:center"><code>my.log</code></td><td style="text-align:center">写入指定的日志文件。名称可以是精确位置或相对于当前目录。</td></tr><tr><td style="text-align:center"><em>（没有）</em></td><td style="text-align:center">具体目录</td><td style="text-align:center"><code>/var/log</code></td><td style="text-align:center">写入<code>spring.log</code>指定的目录。名称可以是精确位置或相对于当前目录。</td></tr></tbody></table><p>日志文件在达到10 MB时会轮换，与控制台输出一样，默认情况下会记录<code>ERROR</code>-level， <code>WARN</code>-level和<code>INFO</code>-level消息。可以使用<code>logging.file.max-size</code>属性更改大小限制。除非<code>logging.file.max-history</code>已设置属性，否则以前轮换的文件将无限期归档。</p><blockquote><p>日志记录系统在应用程序生命周期的早期初始化。因此，在通过<code>@PropertySource</code> 注释加载的属性文件中找不到日志记录属性。</p></blockquote><blockquote><p>日志记录属性独立于实际的日志记录基础结构。因此，<code>logback.configurationFile</code>spring Boot不管理特定的配置键（例如Logback）。</p></blockquote><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>所有支持的日志系统可以在弹簧设置的记录器级别 <code>Environment</code>（例如，<code>application.properties</code>通过使用） <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code>，其中<code>level</code>为TRACE，DEBUG，INFO，WARN，ERROR，FATAL或OFF之一。该<code>root</code>记录器可以通过使用被配置<code>logging.level.root</code>。</p><p>以下示例显示了潜在的日志记录设置<code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logging.level.root=WARN</span><br><span class="line">logging.level.org.springframework.web=DEBUG</span><br><span class="line">logging.level.org.hibernate=ERROR</span><br></pre></td></tr></table></figure><h3 id="日志组"><a href="#日志组" class="headerlink" title="日志组"></a>日志组</h3><p>能够将相关记录器组合在一起以便可以同时配置它们通常很有用。例如，您通常可以更改<em>所有</em> Tomcat相关记录器的日志记录级别 ，但您无法轻松记住顶级软件包。</p><p>为了解决这个问题，Spring Boot允许您在Spring中定义日志记录组 <code>Environment</code>。例如，以下是如何通过将“Tomcat”组添加到您的<code>application.properties</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.group.tomcat = org.apache.catalina，org.apache.coyote，org.apache.tomcat</span><br></pre></td></tr></table></figure><p>定义后，您可以使用一行更改组中所有记录器的级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.tomcat = TRACE</span><br></pre></td></tr></table></figure><p>Spring Boot包含以下预定义的日志记录组，可以直接使用：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">Loggers</th></tr></thead><tbody><tr><td style="text-align:center">WEB</td><td style="text-align:center"><code>org.springframework.core.codec</code>，<code>org.springframework.http</code>，<code>org.springframework.web</code></td></tr><tr><td style="text-align:center">SQL</td><td style="text-align:center"><code>org.springframework.jdbc.core</code>， <code>org.hibernate.SQL</code></td></tr></tbody></table><h3 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h3><p>可以通过在类路径中包含适当的库来激活各种日志记录系统，并且可以通过在类路径的根目录中或在以下Spring <code>Environment</code> 属性指定的位置提供合适的配置文件来进一步自定义：<code>logging.config</code>。</p><p>您可以使用<code>org.springframework.boot.logging.LoggingSystem</code>系统属性强制Spring Boot使用特定的日志记录系统 。该值应该是实现的完全限定类名<code>LoggingSystem</code>。您还可以通过使用值来完全禁用Spring Boot的日志记录配置<code>none</code>。</p><blockquote><p>由于记录被初始化<strong>之前</strong>的<code>ApplicationContext</code>创建，这是不可能控制来自伐木<code>@PropertySources</code>春季<code>@Configuration</code>文件。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。</p></blockquote><p>根据您的日志记录系统，将加载以下文件：</p><table><thead><tr><th style="text-align:center">日志实现</th><th style="text-align:center">定制</th></tr></thead><tbody><tr><td style="text-align:center">logback</td><td style="text-align:center"><code>logback-spring.xml</code>，<code>logback-spring.groovy</code>，<code>logback.xml</code>，或者<code>logback.groovy</code></td></tr><tr><td style="text-align:center">Log4j2</td><td style="text-align:center"><code>log4j2-spring.xml</code> 或者 <code>log4j2.xml</code></td></tr><tr><td style="text-align:center">JDK（Java Util Logging）</td><td style="text-align:center"><code>logging.properties</code></td></tr></tbody></table><blockquote><p>如果可能，我们建议您使用<code>-spring</code>变量进行日志记录配置（例如，<code>logback-spring.xml</code>而不是<code>logback.xml</code>）。如果使用标准配置位置，Spring无法完全控制日志初始化。</p></blockquote><blockquote><p>Java Util Logging存在已知的类加载问题，从“可执行jar”运行时会导致问题。如果可能的话，我们建议您在从“可执行jar”运行时避免使用它。</p></blockquote><p>为了帮助进行自定义，一些其他属性从Spring转移 <code>Environment</code>到System属性，如下表所述：</p><table><thead><tr><th style="text-align:center">Spring环境</th><th style="text-align:center">系统属性</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>logging.exception-conversion-word</code></td><td style="text-align:center"><code>LOG_EXCEPTION_CONVERSION_WORD</code></td><td style="text-align:center">记录异常时使用的转换字。</td></tr><tr><td style="text-align:center"><code>logging.file</code></td><td style="text-align:center"><code>LOG_FILE</code></td><td style="text-align:center">如果已定义，则在默认日志配置中使用它。</td></tr><tr><td style="text-align:center"><code>logging.file.max-size</code></td><td style="text-align:center"><code>LOG_FILE_MAX_SIZE</code></td><td style="text-align:center">最大日志文件大小（如果启用了LOG_FILE）。（仅支持默认的Logback设置。）</td></tr><tr><td style="text-align:center"><code>logging.file.max-history</code></td><td style="text-align:center"><code>LOG_FILE_MAX_HISTORY</code></td><td style="text-align:center">要保留的最大归档日志文件数（如果启用了LOG_FILE）。（仅支持默认的Logback设置。）</td></tr><tr><td style="text-align:center"><code>logging.path</code></td><td style="text-align:center"><code>LOG_PATH</code></td><td style="text-align:center">如果已定义，则在默认日志配置中使用它。</td></tr><tr><td style="text-align:center"><code>logging.pattern.console</code></td><td style="text-align:center"><code>CONSOLE_LOG_PATTERN</code></td><td style="text-align:center">要在控制台上使用的日志模式（stdout）。（仅支持默认的Logback设置。）</td></tr><tr><td style="text-align:center"><code>logging.pattern.dateformat</code></td><td style="text-align:center"><code>LOG_DATEFORMAT_PATTERN</code></td><td style="text-align:center">日志日期格式的Appender模式。（仅支持默认的Logback设置。）</td></tr><tr><td style="text-align:center"><code>logging.pattern.file</code></td><td style="text-align:center"><code>FILE_LOG_PATTERN</code></td><td style="text-align:center">要在文件中使用的日志模式（如果<code>LOG_FILE</code>已启用）。（仅支持默认的Logback设置。）</td></tr><tr><td style="text-align:center"><code>logging.pattern.level</code></td><td style="text-align:center"><code>LOG_LEVEL_PATTERN</code></td><td style="text-align:center">呈现日志级别时使用的格式（默认<code>%5p</code>）。（仅支持默认的Logback设置。）</td></tr><tr><td style="text-align:center"><code>PID</code></td><td style="text-align:center"><code>PID</code></td><td style="text-align:center">当前进程ID（如果可能，则在未定义为OS环境变量时发现）。</td></tr></tbody></table><p>所有受支持的日志记录系统在分析其配置文件时都可以查阅系统属性。有关<code>spring-boot.jar</code>示例，请参阅默认配置：</p><ul><li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml" target="_blank" rel="noopener">logback</a></li><li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml" target="_blank" rel="noopener">Log4j 2</a></li><li><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties" target="_blank" rel="noopener">Java Util日志记录</a></li></ul><blockquote><p>如果要在日志记录属性中使用占位符，则应使用 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-placeholders-in-properties" target="_blank" rel="noopener">Spring Boot的语法</a>而不是底层框架的语法。值得注意的是，如果使用Logback，则应将其<code>:</code> 用作属性名称与其默认值之间的分隔符，而不是使用<code>:-</code>。</p></blockquote><blockquote><p>您可以通过仅覆盖<code>LOG_LEVEL_PATTERN</code>（或<code>logging.pattern.level</code>使用Logback）将MDC和其他临时内容添加到日志行 。例如，如果使用<code>logging.pattern.level=user:%X{user} %5p</code>，则默认日志格式包含“user”的MDC条目（如果存在），如以下示例所示。</p><p>2015-09-30 12:30:04.031 user:someone INFO 22174 — [  nio-8080-exec-0] demo.Controller<br>Handling authenticated request</p></blockquote><h3 id="Logback扩展"><a href="#Logback扩展" class="headerlink" title="Logback扩展"></a>Logback扩展</h3><p>Spring Boot包含许多Logback扩展，可以帮助进行高级配置。您可以在<code>logback-spring.xml</code>配置文件中使用这些扩展名。</p><blockquote><p>由于标准<code>logback.xml</code>配置文件加载过早，因此无法在其中使用扩展。您需要使用<code>logback-spring.xml</code>或定义 <code>logging.config</code>属性。</p></blockquote><blockquote><p>扩展不能与Logback的 <a href="http://logback.qos.ch/manual/configuration.html#autoScan" target="_blank" rel="noopener">配置扫描一起使用</a>。如果您尝试这样做，更改配置文件会导致类似于以下记录之一的错误：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]</span><br><span class="line">ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</span><br></pre></td></tr></table></figure><h4 id="特定于配置文件的配置"><a href="#特定于配置文件的配置" class="headerlink" title="特定于配置文件的配置"></a>特定于配置文件的配置</h4><p>该<code>&lt;springProfile&gt;</code>标签可以让你选择性地包括或排除基于主动春型材配置的部分。在<code>&lt;configuration&gt;</code>元素内的任何位置都支持配置文件节。使用该<code>name</code>属性指定哪个配置文件接受配置。所述<code>&lt;springProfile&gt;</code>标记可包含一个简单的配置文件的名称（例如<code>staging</code>）或轮廓表达。例如，简档表达式允许表达更复杂的简档逻辑 <code>production &amp; (eu-central | eu-west)</code>。有关详细信息，请查阅 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java" target="_blank" rel="noopener">参考指南</a>。以下清单显示了三个示例配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span>  <span class="attr">name</span> = <span class="string">“staging”</span> &gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">！</span> <span class="attr">-</span> “暂存”配置文件处于活动状态时要启用的配置 <span class="attr">-</span> &gt;</span> </span><br><span class="line"><span class="tag">&lt;/ <span class="attr">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span>  <span class="attr">name</span> = <span class="string">“dev</span> | <span class="attr">staging</span>” &gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">！</span> <span class="attr">-</span> 在“<span class="attr">dev</span>”或“<span class="attr">staging</span>”配置文件处于活动状态时启用的配置 <span class="attr">-</span> &gt;</span> </span><br><span class="line"><span class="tag">&lt;/ <span class="attr">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span>  <span class="attr">name</span> = <span class="string">“！production”</span> &gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">！</span> <span class="attr">-</span> “生产”配置文件未激活时要启用的配置 <span class="attr">-</span> &gt;</span> </span><br><span class="line"><span class="tag">&lt;/ <span class="attr">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="环境属性"><a href="#环境属性" class="headerlink" title="环境属性"></a>环境属性</h4><p>该<code>&lt;springProperty&gt;</code>标记允许您公开Spring中的属性<code>Environment</code>以便在Logback中使用。如果要<code>application.properties</code>在Logback配置中访问文件中的值，则此操作非常有用 。标签的工作方式与Logback的标准<code>&lt;property&gt;</code>标签类似。但是，<code>value</code>您可以指定<code>source</code>属性（来自<code>Environment</code>），而不是指定直接 属性。如果需要将属性存储在<code>local</code>范围之外的其他位置，则可以使用该<code>scope</code> 属性。如果需要回退值（如果未在中设置属性 <code>Environment</code>），则可以使用该<code>defaultValue</code>属性。以下示例显示如何公开在Logback中使用的属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span>  <span class="attr">scope</span> = <span class="string">“context”</span>  <span class="attr">name</span> = <span class="string">“fluentHost”</span>  <span class="attr">source</span> = <span class="string">“myapp.fluentd.host”</span> </span></span><br><span class="line"><span class="tag"><span class="attr">defaultValue</span> = <span class="string">“localhost”</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">“FLUENT”</span> <span class="attr">class</span>=<span class="string">“ch.qos.logback.more.appenders.DataFluentAppender”</span> &gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span> $ &#123;fluentHost&#125; <span class="tag">&lt;/ <span class="attr">remoteHost</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProperty</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>source</code>必须在串的情况下（如指定<code>my.property-name</code>）。但是，可以<code>Environment</code>使用宽松规则将属性添加到属性中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人想说一</title>
      <link href="/2019/03/20/%E4%B8%AA%E4%BA%BA%E6%83%B3%E8%AF%B4%E4%B8%80/"/>
      <url>/2019/03/20/%E4%B8%AA%E4%BA%BA%E6%83%B3%E8%AF%B4%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>​    虽说纯看文档无聊，对于我个人来说，大部分都已经使用过的，因此理解起来并没有太大难度。在后续会推出相应的学习Demo，以便复习和具体应用</p>]]></content>
      
      
      <categories>
          
          <category> live </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Profiles</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Profiles/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Profiles/</url>
      
        <content type="html"><![CDATA[<h2 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h2><p>Spring Profiles提供了一种隔离应用程序配置部分并使其仅在特定环境中可用的方法。任何<code>@Component</code>或<code>@Configuration</code> 可以标记<code>@Profile</code>以限制何时加载，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用<code>spring.profiles.active</code> <code>Environment</code>属性指定哪些配置文件处于活动状态。您可以使用本章前面介绍的任何方法指定属性。例如，您可以将其包含在您的中<code>application.properties</code>，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active = dev，hsqldb</span><br></pre></td></tr></table></figure><p>您还可以使用以下开关在命令行上指定它： <code>--spring.profiles.active=dev,hsqldb</code>。</p><h3 id="添加活动配置文件"><a href="#添加活动配置文件" class="headerlink" title="添加活动配置文件"></a>添加活动配置文件</h3><p>该<code>spring.profiles.active</code>属性遵循与其他属性相同的排序规则：最高<code>PropertySource</code>胜利。这意味着您可以在其中指定活动配置文件<code>application.properties</code>，然后使用命令行开关<strong>替换</strong>它们。</p><p>有时，将特定于配置文件的属性<strong>添加</strong>到活动配置文件而不是替换它们是有用的。该<code>spring.profiles.include</code>属性可用于无条件添加活动配置文件。该<code>SpringApplication</code>入口点还设置附加配置文件的Java API（即那些由活化的顶级 <code>spring.profiles.active</code>属性）。请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/SpringApplication.html" target="_blank" rel="noopener">SpringApplication中</a>的<code>setAdditionalProfiles()</code>方法 。</p><p>例如，当使用开关运行具有以下属性的应用程序时<code>--spring.profiles.active=prod</code>，也会激活<code>proddb</code>和<code>prodmq</code>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">my.property:</span> <span class="string">fromyamlfile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">spring.profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="string">spring.profiles.include:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">proddb</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">prodmq</span></span><br></pre></td></tr></table></figure><blockquote><p>请记住，<code>spring.profiles</code>可以在YAML文档中定义属性，以确定此特定文档何时包含在配置中。有关更多详细信息<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-change-configuration-depending-on-the-environment" target="_blank" rel="noopener">，</a>请参见 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-change-configuration-depending-on-the-environment" target="_blank" rel="noopener">第77.7节“根据环境更改配置”</a></p></blockquote><h3 id="以编程方式设置配置文件"><a href="#以编程方式设置配置文件" class="headerlink" title="以编程方式设置配置文件"></a>以编程方式设置配置文件</h3><p>您可以<code>SpringApplication.setAdditionalProfiles(…)</code>在应用程序运行之前通过调用以编程方式设置活动配置文 也可以使用Spring的<code>ConfigurableEnvironment</code>界面激活配置文件。</p><h3 id="特定于配置文件的配置文件"><a href="#特定于配置文件的配置文件" class="headerlink" title="特定于配置文件的配置文件"></a>特定于配置文件的配置文件</h3><p>引用的<code>application.properties</code>（或<code>application.yml</code>）和文件的特定于配置文件的变体<code>@ConfigurationProperties</code>被视为文件并加载。有关详细信息<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-profile-specific-properties" target="_blank" rel="noopener">，</a>请参见“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-profile-specific-properties" target="_blank" rel="noopener">第24.4节”“特定</a>于<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-profile-specific-properties" target="_blank" rel="noopener">配置文件的属性”</a>。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> profiles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-类型安全配置属性</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="类型安全配置属性"><a href="#类型安全配置属性" class="headerlink" title="类型安全配置属性"></a>类型安全配置属性</h2><p>使用<code>@Value(&quot;${property}&quot;)</code>注释注入配置属性有时会很麻烦，尤其是在使用多个属性或数据本质上是分层的情况下。Spring Boot提供了一种使用属性的替代方法，该方法允许强类型bean管理和验证应用程序的配置，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"acme"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> InetAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoteAddress</span><span class="params">(InetAddress remoteAddress)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Security <span class="title">getSecurity</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singleton(<span class="string">"USER"</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的POJO定义了以下属性：</p><ul><li><code>acme.enabled</code>，默认值为<code>false</code>。</li><li><code>acme.remote-address</code>，具有可以强制的类型<code>String</code>。</li><li><code>acme.security.username</code>，使用嵌套的“安全”对象，其名称由属性名称决定。特别是，那里根本没有使用返回类型<code>SecurityProperties</code>。</li><li><code>acme.security.password</code>。</li><li><code>acme.security.roles</code>，收集<code>String</code>。</li></ul><blockquote><p>getter和setter通常是必需的，因为绑定是通过标准的Java Beans属性描述符，就像在Spring MVC中一样。在下列情况下可以省略setter：</p><ul><li>映射，只要它们被初始化，就需要一个getter但不一定是setter，因为它们可以被绑定器变异。</li><li>可以通过索引（通常使用YAML）或使用单个逗号分隔值（属性）访问集合和数组。在后一种情况下，必须设置一个setter。我们建议始终为这些类型添加setter。如果初始化集合，请确保它不是不可变的（如上例所示）。</li><li>如果初始化嵌套的POJO属性（如<code>Security</code>前面示例中的字段），则不需要setter。如果您希望绑定器使用其默认构造函数动态创建实例，则需要一个setter。</li></ul><p>有些人使用Project Lombok自动添加getter和setter。确保Lombok不为此类型生成任何特定构造函数，因为容器会自动使用它来实例化对象。</p><p>最后，仅考虑标准Java Bean属性，并且不支持对静态属性的绑定。</p></blockquote><p>您还需要列出要在<code>@EnableConfigurationProperties</code>注释中注册的属性类 ，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>（AcmeProperties.class）</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当<code>@ConfigurationProperties</code>bean以这种方式注册时，bean具有常规名称：<code>&lt;prefix&gt;-&lt;fqn&gt;</code>，其中<code>&lt;prefix&gt;</code>是<code>@ConfigurationProperties</code>注释中指定的环境键前缀，并且<code>&lt;fqn&gt;</code>是bean的完全限定名称。如果注释未提供任何前缀，则仅使用bean的完全限定名称。</p><p>上例中的bean名称是<code>acme-com.example.AcmeProperties</code>。</p></blockquote><p>即使前面的配置创建了常规bean <code>AcmeProperties</code>，我们也建议<code>@ConfigurationProperties</code>只处理环境，特别是不从上下文中注入其他bean。话虽如此，<code>@EnableConfigurationProperties</code>注释<em>也会</em>自动应用于您的项目，以便从中配置任何注释的<em>现有</em> bean 。您可以通过确保 已经是bean 来快捷方式，如以下示例所示：<code>@ConfigurationProperties</code></p><p><code>Environment</code></p><p><code>MyConfiguration</code></p><p><code>AcmeProperties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@ConfigurationProperties</span>（prefix =“acme”）</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...参见前面的例子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种配置风格特别适用于<code>SpringApplication</code>外部YAML配置，如以下示例所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">acme:</span></span><br><span class="line"><span class="attr">remote-address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">roles:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">USER</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ADMIN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># additional configuration as required</span></span><br></pre></td></tr></table></figure><p>要使用<code>@ConfigurationProperties</code>bean，可以使用与任何其他bean相同的方式注入它们，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AcmeProperties properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(AcmeProperties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = properties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Server server = <span class="keyword">new</span> Server(<span class="keyword">this</span>.properties.getRemoteAddress());</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>@ConfigurationProperties</code>还可以生成元数据文件，IDE可以使用这些文件为您自己的密钥提供自动完成功能。有关详细信息<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#configuration-metadata" target="_blank" rel="noopener">，</a>请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#configuration-metadata" target="_blank" rel="noopener">附录B，</a><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#configuration-metadata" target="_blank" rel="noopener"><em>配置元数据</em></a>附录。</p></blockquote><h2 id="第三方配置"><a href="#第三方配置" class="headerlink" title="第三方配置"></a>第三方配置</h2><p>除了<code>@ConfigurationProperties</code>用于注释类之外，您还可以在公共<code>@Bean</code>方法上使用它。当您想要将属性绑定到控件之外的第三方组件时，这样做会特别有用。</p><p>要从<code>Environment</code>属性配置bean ，请添加<code>@ConfigurationProperties</code>到其bean注册，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>（prefix =“another”）</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"> <span class="keyword">public</span> AnotherComponent anotherComponent（）&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>another</code>前缀定义的任何属性都<code>AnotherComponent</code>以与前面<code>AcmeProperties</code>示例类似的方式映射到该bean 。</p><h2 id="松弛结合"><a href="#松弛结合" class="headerlink" title="松弛结合"></a>松弛结合</h2><p>Spring Boot使用一些宽松的规则来绑定bean的<code>Environment</code>属性 <code>@ConfigurationProperties</code>，因此不需要在<code>Environment</code>属性名和bean属性名之间进行精确匹配 。这有用的常见示例包括破折号分隔的环境属性（例如，<code>context-path</code>绑定到<code>contextPath</code>）和大写环境属性（例如，<code>PORT</code>绑定到 <code>port</code>）。</p><p>例如，请考虑以下<code>@ConfigurationProperties</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"acme.my-project.person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的示例中，可以使用以下属性名称：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">注意</th></tr></thead><tbody><tr><td style="text-align:center"><code>acme.my-project.person.first-name</code></td><td style="text-align:center">建议用于<code>.properties</code>和<code>.yml</code>文件。</td></tr><tr><td style="text-align:center"><code>acme.myProject.person.firstName</code></td><td style="text-align:center">标准的驼峰案例语法。</td></tr><tr><td style="text-align:center"><code>acme.my_project.person.first_name</code></td><td style="text-align:center">下划线符号，这是在用另一种格式<code>.properties</code>和<code>.yml</code> 文件。</td></tr><tr><td style="text-align:center"><code>ACME_MYPROJECT_PERSON_FIRSTNAME</code></td><td style="text-align:center">大写格式，使用系统环境变量时建议使用。</td></tr></tbody></table><blockquote><p><code>prefix</code>注释的值<em>必须</em>是kebab大小写（小写并且用<code>-</code>，例如<code>acme.my-project.person</code>）。</p></blockquote><p>每个属性源放宽绑定规则：</p><table><thead><tr><th style="text-align:center">Property Source</th><th style="text-align:center">Simple</th><th style="text-align:center">List</th></tr></thead><tbody><tr><td style="text-align:center">属性文件</td><td style="text-align:center">骆驼案，kebab案例或下划线表示法</td><td style="text-align:center">标准列表语法使用<code>[ ]</code>或逗号分隔值</td></tr><tr><td style="text-align:center">YAML文件</td><td style="text-align:center">骆驼案，kebab案例或下划线表示法</td><td style="text-align:center">标准YAML列表语法或逗号分隔值</td></tr><tr><td style="text-align:center">环境变量</td><td style="text-align:center">大写格式，下划线作为分隔符。<code>_</code>不应在属性名称中使用</td><td style="text-align:center">由下划线包围的数字值，例如 <code>MY_ACME_1_OTHER = my.acme[1].other</code></td></tr><tr><td style="text-align:center">系统属性</td><td style="text-align:center">骆驼案，kebab案例或下划线表示法</td><td style="text-align:center">标准列表语法使用<code>[ ]</code>或逗号分隔值</td></tr></tbody></table><blockquote><p>我们建议，在可能的情况下，属性以小写的kebab格式存储，例如<code>my.property-name=acme</code>。</p></blockquote><p>绑定到<code>Map</code>属性时，如果<code>key</code>包含除小写字母数字字符以外的任何内容，则<code>-</code>需要使用括号表示法以保留原始值。如果密钥未被包围<code>[]</code>，则任何非字母数字或<code>-</code>删除的字符。例如，考虑将以下属性绑定到<code>Map</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">acme:</span></span><br><span class="line"><span class="attr">  map:</span></span><br><span class="line">    <span class="string">"[/key1]"</span><span class="string">:</span> <span class="string">value1</span></span><br><span class="line">    <span class="string">"[/key2]"</span><span class="string">:</span> <span class="string">value2</span></span><br><span class="line">    <span class="string">/key3:</span> <span class="string">value3</span></span><br></pre></td></tr></table></figure><p>上面的属性将绑定到<code>Map</code>with <code>/key1</code>，<code>/key2</code>并<code>key3</code>作为地图中的键。</p><h2 id="合并复杂类型"><a href="#合并复杂类型" class="headerlink" title="合并复杂类型"></a>合并复杂类型</h2><p>当列表在多个位置配置时，覆盖通过替换整个列表来工作。</p><p>例如，假设一个<code>MyPojo</code>具有对象<code>name</code>和<code>description</code>那些属性 <code>null</code>默认。以下示例公开了以下<code>MyPojo</code>对象 列表<code>AcmeProperties</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"acme"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;MyPojo&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MyPojo&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请考虑以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">acme:</span></span><br><span class="line"><span class="attr">  list:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">my</span> <span class="string">name</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">my</span> <span class="string">description</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">acme:</span></span><br><span class="line"><span class="attr">  list:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">my</span> <span class="string">another</span> <span class="string">name</span></span><br></pre></td></tr></table></figure><p>如果<code>dev</code>配置文件未激活，则<code>AcmeProperties.list</code>包含一个<code>MyPojo</code>条目，如先前定义的那样。<code>dev</code>但是，如果启用了配置文件，则<code>list</code> <em>仍然</em> 只包含一个条目（名称<code>my another name</code>和描述<code>null</code>）。此配置<em>不会</em><code>MyPojo</code>向列表添加第二个实例，也不会合并项目。</p><p>当<code>List</code>在多个配置文件中指定a时，将使用具有最高优先级（并且仅具有该优先级）的配置文件。请考虑以下示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">acme:</span></span><br><span class="line"><span class="attr">  list:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">my</span> <span class="string">name</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">my</span> <span class="string">description</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">another</span> <span class="string">name</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">another</span> <span class="string">description</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">acme:</span></span><br><span class="line"><span class="attr">  list:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">my</span> <span class="string">another</span> <span class="string">name</span></span><br></pre></td></tr></table></figure><p>在前面的示例中，如果<code>dev</code>配置文件处于活动状态，则<code>AcmeProperties.list</code>包含 <em>一个</em> <code>MyPojo</code>条目（名称<code>my another name</code>和描述<code>null</code>）。对于YAML，逗号分隔列表和YAML列表都可用于完全覆盖列表的内容。</p><p>对于<code>Map</code>属性，您可以绑定从多个源中提取的属性值。但是，对于多个源中的相同属性，使用具有最高优先级的属性。以下示例公开了一个<code>Map&lt;String, MyPojo&gt;</code>from <code>AcmeProperties</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"acme"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MyPojo&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MyPojo&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请考虑以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">acme:</span></span><br><span class="line"><span class="attr">  map:</span></span><br><span class="line"><span class="attr">    key1:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">my</span> <span class="string">name</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">my</span> <span class="string">description</span> <span class="number">1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">acme:</span></span><br><span class="line"><span class="attr">  map:</span></span><br><span class="line"><span class="attr">    key1:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">dev</span> <span class="string">name</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    key2:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">dev</span> <span class="string">name</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">dev</span> <span class="string">description</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果<code>dev</code>配置文件未处于活动状态，则<code>AcmeProperties.map</code>包含一个带密钥的条目<code>key1</code> （名称<code>my name 1</code>和描述<code>my description 1</code>）。<code>dev</code>但是，如果启用了配置文件，则<code>map</code>包含两个带有键的条目<code>key1</code> （名称<code>dev name 1</code>和描述<code>my description 1</code>）和 <code>key2</code>（名称<code>dev name 2</code>和描述<code>dev description 2</code>）。</p><blockquote><p>前面的合并规则适用于所有属性源的属性，而不仅仅适用于YAML文件。</p></blockquote><h2 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h2><p>Spring Boot尝试在绑定到<code>@ConfigurationProperties</code>bean 时将外部应用程序属性强制转换为正确的类型。如果需要自定义类型转换，则可以提供<code>ConversionService</code>bean（带有bean命名<code>conversionService</code>）或自定义属性编辑器（通过<code>CustomEditorConfigurer</code>bean）或自定义<code>Converters</code>（带有注释为bean的bean定义<code>@ConfigurationPropertiesBinding</code>）。</p><blockquote><p>由于在应用程序生命周期中很早就请求此bean，因此请确保限制您<code>ConversionService</code>正在使用的依赖项。通常，您在创建时可能无法完全初始化所需的任何依赖项。<code>ConversionService</code>如果配置密钥强制不需要，您可能需要重命名自定义，并且只依赖于合格的自定义转换器<code>@ConfigurationPropertiesBinding</code>。</p></blockquote><h3 id="转换持续时间"><a href="#转换持续时间" class="headerlink" title="转换持续时间"></a>转换持续时间</h3><p>Spring Boot专门支持表达持续时间。如果公开 <code>java.time.Duration</code>属性，则可以使用应用程序属性中的以下格式：</p><ul><li>常规<code>long</code>表示（除非<code>@DurationUnit</code>已指定，否则使用毫秒作为默认单位 ）</li><li>标准的ISO-8601格式 <a href="https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence-" target="_blank" rel="noopener"> <code>java.util.Duration</code></a>的使用</li><li>一种更易读的格式，其中值和单位耦合（例如<code>10s</code>10秒）</li></ul><p>请考虑以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"app.system"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSystemProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DurationUnit</span>(ChronoUnit.SECONDS)</span><br><span class="line"><span class="keyword">private</span> Duration sessionTimeout = Duration.ofSeconds(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Duration readTimeout = Duration.ofMillis(<span class="number">1000</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> Duration <span class="title">getSessionTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.sessionTimeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionTimeout</span><span class="params">(Duration sessionTimeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Duration <span class="title">getReadTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.readTimeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadTimeout</span><span class="params">(Duration readTimeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.readTimeout = readTimeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要指定30秒的会话超时<code>30</code>，<code>PT30S</code>并且<code>30s</code>都是等效的。的500ms的读超时可以以任何形式如下指定：<code>500</code>，<code>PT0.5S</code>和 <code>500ms</code>。</p><p>您也可以使用任何支持的单位。这些是：</p><ul><li><code>ns</code> 为纳秒</li><li><code>us</code> 微秒</li><li><code>ms</code> 毫秒</li><li><code>s</code> 几秒钟</li><li><code>m</code> 几分钟</li><li><code>h</code> 用了几个小时</li><li><code>d</code> 持续数天</li></ul><p>默认单位是毫秒，可以使用<code>@DurationUnit</code>上面的示例中所示进行覆盖。</p><blockquote><p>如果要从仅<code>Long</code>用于表示持续时间的先前版本升级，请确保定义单位（使用<code>@DurationUnit</code>），如果它不是交换机旁边的毫秒数<code>Duration</code>。这样做可以提供透明的升级路径，同时支持更丰富的格式。</p></blockquote><h3 id="转换数据大小"><a href="#转换数据大小" class="headerlink" title="转换数据大小"></a>转换数据大小</h3><p>Spring Framework有一个<code>DataSize</code>值类型，允许以字节为单位表示大小。如果公开<code>DataSize</code>属性，则可以使用应用程序属性中的以下格式：</p><ul><li>常规<code>long</code>表示（使用字节作为默认单位，除非 <code>@DataSizeUnit</code>已指定）</li><li>更可读的格式，其中值和单元耦合（例如，<code>10MB</code>意味着10兆字节）</li></ul><p>请考虑以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"app.io"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppIoProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DataSizeUnit</span>(DataUnit.MEGABYTES)</span><br><span class="line"><span class="keyword">private</span> DataSize bufferSize = DataSize.ofMegabytes(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DataSize sizeThreshold = DataSize.ofBytes(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSize <span class="title">getBufferSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.bufferSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBufferSize</span><span class="params">(DataSize bufferSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.bufferSize = bufferSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSize <span class="title">getSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.sizeThreshold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSizeThreshold</span><span class="params">(DataSize sizeThreshold)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sizeThreshold = sizeThreshold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定10兆字节的缓冲区大小，<code>10</code>并且<code>10MB</code>是等效的。可以将大小阈值256个字节指定为<code>256</code>或<code>256B</code>。</p><p>您也可以使用任何支持的单位。这些是：</p><ul><li><code>B</code> 用于字节</li><li><code>KB</code> 为千字节</li><li><code>MB</code> 对于兆字节</li><li><code>GB</code> 为千兆字节</li><li><code>TB</code> 对于太字节</li></ul><p>默认单位是字节，可以使用<code>@DataSizeUnit</code>上面的示例中所示进行覆盖。</p><blockquote><p>如果要从仅<code>Long</code>用于表示大小的先前版本升级，请确保定义单位（使用<code>@DataSizeUnit</code>），如果它不是交换机旁边的字节<code>DataSize</code>。这样做可以提供透明的升级路径，同时支持更丰富的格式。</p></blockquote><h2 id="ConfigurationProperties验证"><a href="#ConfigurationProperties验证" class="headerlink" title="@ConfigurationProperties验证"></a>@ConfigurationProperties验证</h2><p>Spring Boot尝试在<code>@ConfigurationProperties</code>使用Spring的<code>@Validated</code>注释注释时验证类。您可以<code>javax.validation</code> 直接在配置类上使用JSR-303 约束注释。为此，请确保符合条件的JSR-303实现位于类路径上，然后将约束注释添加到字段中，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"acme"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>您还可以通过注释<code>@Bean</code>创建配置属性的方法来触发验证<code>@Validated</code>。</p></blockquote><p>虽然嵌套属性也会在绑定时进行验证，但最好还是将关联字段注释为<code>@Valid</code>。这确保即使没有找到嵌套属性也会触发验证。以下示例基于前面的<code>AcmeProperties</code>示例构建 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"acme"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Valid</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotEmpty</span></span><br><span class="line"><span class="keyword">public</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以<code>Validator</code>通过创建名为的bean定义 来添加自定义Spring <code>configurationPropertiesValidator</code>。<code>@Bean</code>应声明该方法<code>static</code>。配置属性验证器是在应用程序生命周期的早期创建的，并且将该<code>@Bean</code>方法声明为static可以创建bean而无需实例化<code>@Configuration</code>该类。这样做可以避免早期实例化可能导致的任何问题。有一个 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/spring-boot-sample-property-validation" target="_blank" rel="noopener">属性验证示例</a>，显示如何设置。</p><blockquote><p>该<code>spring-boot-actuator</code>模块包括一个暴露所有<code>@ConfigurationProperties</code>bean 的端点 。将Web浏览器指向 <code>/actuator/configprops</code>或使用等效的JMX端点。有关详细信息，请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints" target="_blank" rel="noopener">生产就绪功能</a> ”部分。</p></blockquote><h2 id="ConfigurationProperties与-Value"><a href="#ConfigurationProperties与-Value" class="headerlink" title="@ConfigurationProperties与@Value"></a>@ConfigurationProperties与@Value</h2><p><code>@Value</code>的注释是核心容器的功能，和它不提供相同的功能，类型安全配置属性。下表汇总了支持的功能<code>@ConfigurationProperties</code>和<code>@Value</code>：</p><table><thead><tr><th style="text-align:center">特征</th><th style="text-align:center"><code>@ConfigurationProperties</code></th><th style="text-align:center"><code>@Value</code></th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-relaxed-binding" target="_blank" rel="noopener">轻松绑定</a></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#configuration-metadata" target="_blank" rel="noopener">元数据支持</a></td><td style="text-align:center">是</td><td style="text-align:center">没有</td></tr><tr><td style="text-align:center"><code>SpEL</code> 评测</td><td style="text-align:center">没有</td><td style="text-align:center">是</td></tr></tbody></table><p>如果为自己的组件定义一组配置键，我们建议您将它们分组到带注释的POJO中<code>@ConfigurationProperties</code>。您还应该知道，因为<code>@Value</code>不支持宽松绑定，所以如果您需要使用环境变量来提供值，则它不是一个好的候选者。</p><p>最后，虽然您可以编写<code>SpEL</code>表达式<code>@Value</code>，但不会从<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-external-config-application-property-files" target="_blank" rel="noopener">应用程序属性文件中</a>处理此类表达式。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> properties </tag>
            
            <tag> yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-自定义Banner</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E8%87%AA%E5%AE%9A%E4%B9%89Banner/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E8%87%AA%E5%AE%9A%E4%B9%89Banner/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义横幅"><a href="#自定义横幅" class="headerlink" title="自定义横幅"></a>自定义横幅</h2><p>可以通过向<code>banner.txt</code>类路径添加文件或将<code>spring.banner.location</code>属性设置为此类文件的位置来更改启动时打印的横幅。如果文件的编码不是UTF-8，则可以进行设置<code>spring.banner.charset</code>。除了一个文本文件，你还可以添加一个<code>banner.gif</code>，<code>banner.jpg</code>或<code>banner.png</code> 图像文件到类路径或设置<code>spring.banner.image.location</code>属性。图像将转换为ASCII艺术表示，并打印在任何文本横幅上方。</p><p>在<code>banner.txt</code>文件中，您可以使用以下任何占位符：</p><table><thead><tr><th style="text-align:center">量</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>${application.version}</code></td><td style="text-align:center">应用程序的版本号，如声明中所声明的<code>MANIFEST.MF</code>。例如，<code>Implementation-Version: 1.0</code>打印为<code>1.0</code>。</td></tr><tr><td style="text-align:center"><code>${application.formatted-version}</code></td><td style="text-align:center">应用程序的版本号，在<code>MANIFEST.MF</code>显示中声明并格式化（用括号括起来并以前缀为例<code>v</code>）。例如<code>(v1.0)</code>。</td></tr><tr><td style="text-align:center"><code>${spring-boot.version}</code></td><td style="text-align:center">您正在使用的Spring Boot版本。例如<code>2.1.3.RELEASE</code>。</td></tr><tr><td style="text-align:center"><code>${spring-boot.formatted-version}</code></td><td style="text-align:center">您正在使用的Spring Boot版本，格式化显示（用括号括起来并带有前缀<code>v</code>）。例如<code>(v2.1.3.RELEASE)</code>。</td></tr><tr><td style="text-align:center"><code>${Ansi.NAME}</code></td></tr></tbody></table><p><code>${AnsiColor.NAME}</code><br><code>${AnsiBackground.NAME}</code><br><code>${AnsiStyle.NAME}</code> | <code>NAME</code>ANSI转义码的名称在哪里。详情<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java" target="_blank" rel="noopener"><code>AnsiPropertySource</code></a>。 |<br>|                    <code>${application.title}</code>                    | 申请的标题，如声明中所述<code>MANIFEST.MF</code>。例如<code>Implementation-Title: MyApp</code>打印为<code>MyApp</code>。 |</p><blockquote><p><code>SpringApplication.setBanner(…)</code>如果要以编程方式生成横幅，则可以使用该方法。使用<code>org.springframework.boot.Banner</code>界面并实现自己的<code>printBanner()</code>方法。</p></blockquote><p>您还可以使用该<code>spring.main.banner-mode</code>属性来确定是否必须在<code>System.out</code>（<code>console</code>）上打印横幅，发送到配置的记录器（<code>log</code>），或者根本不生成横幅（<code>off</code>）。</p><p>打印的横幅在以下名称下注册为单例bean : <code>springBootBanner</code>.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring：</span></span><br><span class="line"><span class="string">main：</span></span><br><span class="line"><span class="string">banner-mode：“off”</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Banner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-@SpringBootApplication</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-SpringBootApplication/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-SpringBootApplication/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-SpringBootApplication-Annotation"><a href="#使用-SpringBootApplication-Annotation" class="headerlink" title="使用@SpringBootApplication Annotation"></a>使用@SpringBootApplication Annotation</h2><p>许多Spring Boot开发人员喜欢他们的应用程序使用自动配置，组件扫描，并能够在他们的“应用程序类”上定义额外的配置。<code>@SpringBootApplication</code>可以使用单个 注释来启用这三个功能，即：</p><ul><li><code>@EnableAutoConfiguration</code>：启用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#using-boot-auto-configuration" target="_blank" rel="noopener">Spring Boot的自动配置机制</a></li><li><code>@ComponentScan</code>：<code>@Component</code>在应用程序所在的包上启用扫描（请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#using-boot-structuring-your-code" target="_blank" rel="noopener">最佳实践</a>）</li><li><code>@Configuration</code>：允许在上下文中注册额外的bean或导入其他配置类</li></ul><p>的<code>@SpringBootApplication</code>注释是相当于使用<code>@Configuration</code>， <code>@EnableAutoConfiguration</code>以及<code>@ComponentScan</code>与他们的默认属性，如显示在下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于@Configuration,@EnableAutoConfiguration和@ComponentScan一起使用</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> main（String [] args）&#123;</span><br><span class="line">SpringApplication.run（Application .class，args）;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@SpringBootApplication</code>还提供了别名定制的属性 <code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。</p></blockquote><blockquote><p>这些功能都不是必需的，您可以选择通过它启用的任何功能替换此单个注释。例如，您可能不希望在应用程序中使用组件扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> com.example.myapplication;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.context.annotation.ComponentScan</span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line">&gt; <span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">@Configuration</span></span><br><span class="line">&gt; <span class="meta">@EnableAutoConfiguration</span></span><br><span class="line">&gt; <span class="meta">@Import</span>(&#123;MyConfig.class，MyAnotherConfig.class&#125;)</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args）&#123;</span><br><span class="line">&gt;     SpringApplication.run（Application .class，args）;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在此示例中，<code>Application</code>与任何其他Spring Boot应用程序一样，除了 <code>@Component</code>未自动检测到注释类并且显式导入用户定义的bean（请参阅参考资料<code>@Import</code>）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-依赖注入</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Beans和依赖注入"><a href="#Spring-Beans和依赖注入" class="headerlink" title="Spring Beans和依赖注入"></a>Spring Beans和依赖注入</h2><p>您可以自由地使用任何标准的Spring Framework技术来定义bean及其注入的依赖项。为简单起见，我们经常发现使用 <code>@ComponentScan</code>（找到你的bean）和使用<code>@Autowired</code>（做构造函数注入）效果很好。</p><p>如果按照上面的建议构建代码（在根包中定位应用程序类），则可以添加<code>@ComponentScan</code>不带任何参数的代码。您的所有应用程序组件（的<code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code>等）自动注册为春豆。</p><p>以下示例显示了一个<code>@Service</code>使用构造函数注入来获取所需<code>RiskAssessor</code>bean的Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatabaseAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果bean有一个构造函数，则可以省略<code>@Autowired</code>，如下例所示：(长知识了)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatabaseAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用构造函数注入如何将<code>riskAssessor</code>字段标记为 <code>final</code>，表示无法随后更改。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Autowired </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-AutoConfiguration</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-AutoConfiguration/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-AutoConfiguration/</url>
      
        <content type="html"><![CDATA[<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>​    Spring Boot自动配置尝试根据您添加的jar依赖项自动配置Spring应用程序。例如，如果<code>HSQLDB</code> 在您的类路径上，并且您尚未手动配置任何数据库连接bean，则Spring Boot会自动配置内存数据库。</p><p>​    您需要通过向其中一个类添加<code>@EnableAutoConfiguration</code>或 <code>@SpringBootApplication</code>注释来选择自动配置<code>@Configuration</code>。</p><blockquote><p>您应该只添加一个<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code> 注释。我们通常建议您仅将一个或另一个添加到主 <code>@Configuration</code>类。</p></blockquote><h2 id="更换自动配置"><a href="#更换自动配置" class="headerlink" title="更换自动配置"></a>更换自动配置</h2><p>​    自动配置是非侵入性的。在任何时候，您都可以开始定义自己的配置以替换自动配置的特定部分。例如，如果添加自己的<code>DataSource</code>bean，则默认的嵌入式数据库支持会退回。</p><p>​    如果您需要了解当前正在应用的自动配置以及原因，请使用<code>--debug</code>交换机启动应用程序。这样做可以为选择的核心记录器启用调试日志，并将条件报告记录到控制台。</p><h2 id="禁用特定的自动配置类"><a href="#禁用特定的自动配置类" class="headerlink" title="禁用特定的自动配置类"></a>禁用特定的自动配置类</h2><p>​    如果发现正在应用您不需要的特定自动配置类，则可以使用<code>@EnableAutoConfiguration</code>的<code>exclude</code>属性禁用它们，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure。*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc。*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation。*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>（exclude = &#123;DataSourceAutoConfiguration.class&#125;）</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类不在类路径上，则可以使用<code>excludeName</code>注释的属性并指定完全限定名称。最后，您还可以使用该<code>spring.autoconfigure.exclude</code>属性控制要排除的自动配置类列表 。</p><blockquote><p>可以在注释级别和使用属性定义排除项。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoConfiguration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Configuration</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Configuration/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Configuration/</url>
      
        <content type="html"><![CDATA[<h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>​    Spring Boot支持基于Java的配置。尽管可以使用 <code>SpringApplicationXML</code>源，但我们通常建议您的主要源是单个<code>@Configuration</code>类。通常，定义<code>main</code>方法的类是主要的候选者<code>@Configuration</code>。</p><blockquote><p>许多Spring配置示例已在Internet上发布，使用XML配置。如果可能，请始终尝试使用等效的基于Java的配置。搜索<code>Enable*</code>注释可能是一个很好的起点。</p></blockquote><h2 id="导入其他配置类"><a href="#导入其他配置类" class="headerlink" title="导入其他配置类"></a>导入其他配置类</h2><p>​    你不需要把所有的<code>@Configuration</code>都放在一个类里。<code>@Import</code>注释可以用于导入额外的配置类。或者，您可以使用 <code>@ComponentScan</code>自动获取所有Spring组件，包括 <code>@Configuration</code>类。</p><h2 id="导入XML配置文件"><a href="#导入XML配置文件" class="headerlink" title="导入XML配置文件"></a>导入XML配置文件</h2><p>​    如果您必须使用基于XML的配置，我们建议您仍然从一个<code>@Configuration</code>类开始。然后，您可以使用<code>@ImportResource</code>注释来加载XML配置文件</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Configuration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Starters</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Starters/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Starters/</url>
      
        <content type="html"><![CDATA[<h2 id="Starters简介"><a href="#Starters简介" class="headerlink" title="Starters简介"></a>Starters简介</h2><p>​    启动器是一组方便的依赖关系描述符，您可以在应用程序中包含这些描述符。您可以获得所需的所有Spring和相关技术的一站式服务，而无需查看示例代码和复制粘贴依赖描述符的负载。例如，如果要开始使用Spring和JPA进行数据库访问，请<code>spring-boot-starter-data-jpa</code>在项目中包含依赖项。</p><p>启动器包含许多依赖项，这些依赖项是使项目快速启动和运行所需的依赖项，以及一组受支持的托管传递依赖项。</p><blockquote><p>什么是名字</p><p>所有官方首发都遵循类似的命名模式; <code>spring-boot-starter-*</code>，这里<code>*</code>是特定类型的应用程序。此命名结构旨在帮助您找到启动器。许多IDE中的Maven集成允许您按名称搜索依赖项。例如，安装了适当的Eclipse或STS插件后，您可以<code>ctrl-space</code>在POM编辑器中输入“spring-boot-starter”以获取完整列表。</p><p>第三方启动者不应该开头为spring-boot，因为它是为官方Spring Boot工件保留的。相反，第三方启动器通常以项目名称开头。例如，<code>thirdpartyproject</code>通常会命名一个名为的第三方启动项目 <code>thirdpartyproject-spring-boot-starter</code>。</p></blockquote><p>以下应用程序启动程序由Spring Boot在<code>org.springframework.boot</code>组下提供 ：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">spring-boot-starter</td><td style="text-align:center">核心启动器，包括自动配置支持，日志记录和YAML</td></tr><tr><td style="text-align:center">spring-boot-starter-activemq</td><td style="text-align:center">Apache ActiveMQ进行JMS消息传递</td></tr><tr><td style="text-align:center">spring-boot-starter-amqp</td><td style="text-align:center">Spring AMQP和Rabbit MQ</td></tr><tr><td style="text-align:center">spring-boot-starter-aop</td><td style="text-align:center">Spring AOP和AspectJ进行面向方面编程</td></tr><tr><td style="text-align:center">spring-boot-starter-artemis</td><td style="text-align:center">Apache Artemis进行JMS消息传递</td></tr><tr><td style="text-align:center">spring-boot-starter-batch</td><td style="text-align:center">Spring Batch</td></tr><tr><td style="text-align:center">spring-boot-starter-cache</td><td style="text-align:center">Spring Framework的缓存支持</td></tr><tr><td style="text-align:center">spring-boot-starter-cloud-connectors</td><td style="text-align:center">Spring Cloud Connectors的启动器，简化了Cloud Foundry和Heroku等云平台中的服务连接</td></tr><tr><td style="text-align:center">spring-boot-starter-data-cassandra</td><td style="text-align:center">Cassandra分布式数据库和Spring Data Cassandra</td></tr><tr><td style="text-align:center">spring-boot-starter-data-cassandra-reactive</td><td style="text-align:center">Cassandra分布式数据库和Spring Data Cassandra Reactive</td></tr><tr><td style="text-align:center">spring-boot-starter-data-couchbase</td><td style="text-align:center">Couchbase面向文档的数据库和Spring Data Couchbase</td></tr><tr><td style="text-align:center">spring-boot-starter-data-couchbase-reactive</td><td style="text-align:center">Couchbase面向文档的数据库和Spring Data Couchbase Reactive</td></tr><tr><td style="text-align:center">spring-boot-starter-data-elasticsearch</td><td style="text-align:center">Elasticsearch搜索和分析引擎以及Spring Data Elasticsearch</td></tr><tr><td style="text-align:center">spring-boot-starter-data-jdbc</td><td style="text-align:center">Spring Data JDBC</td></tr><tr><td style="text-align:center">spring-boot-starter-data-jpa</td><td style="text-align:center">将Spring Data JPA与Hibernate一起使用</td></tr><tr><td style="text-align:center">spring-boot-starter-data-ldap</td><td style="text-align:center">Spring Data LDAP</td></tr><tr><td style="text-align:center">spring-boot-starter-data-mongodb</td><td style="text-align:center">MongoDB面向文档的数据库和Spring Data MongoDB</td></tr><tr><td style="text-align:center">spring-boot-starter-data-mongodb-reactive</td><td style="text-align:center">MongoDB面向文档的数据库和Spring Data MongoDB Reactive</td></tr><tr><td style="text-align:center">spring-boot-starter-data-neo4j</td><td style="text-align:center">Neo4j图形数据库和Spring Data Neo4j</td></tr><tr><td style="text-align:center">spring-boot-starter-data-redis</td><td style="text-align:center">在Spring Data Redis和Lettuce客户端上使用Redis键值数据存储</td></tr><tr><td style="text-align:center">spring-boot-starter-data-redis-reactive</td><td style="text-align:center">带有Spring Data Redis被动的Redis键值数据存储和Lettuce客户端</td></tr><tr><td style="text-align:center">spring-boot-starter-data-rest</td><td style="text-align:center">Spring Data REST通过REST公开Spring Data存储库</td></tr><tr><td style="text-align:center">spring-boot-starter-data-solr</td><td style="text-align:center">在Spring Data Solr中使用Apache Solr搜索平台</td></tr><tr><td style="text-align:center">spring-boot-starter-freemarker</td><td style="text-align:center">FreeMarker视图构建MVC Web应用程序</td></tr><tr><td style="text-align:center">spring-boot-starter-groovy-templates</td><td style="text-align:center">Groovy模板视图构建MVC Web应用程序</td></tr><tr><td style="text-align:center">spring-boot-starter-hateoas</td><td style="text-align:center">Spring MVC和Spring HATEOAS构建基于超媒体的RESTful Web应用程序</td></tr><tr><td style="text-align:center">spring-boot-starter-integration</td><td style="text-align:center">Spring Integration</td></tr><tr><td style="text-align:center">spring-boot-starter-jdbc</td><td style="text-align:center">将JDBC与HikariCP连接池一起使用</td></tr><tr><td style="text-align:center">spring-boot-starter-jersey</td><td style="text-align:center">JAX-RS和Jersey构建RESTful Web应用程序，替代spring-boot-starter-web</td></tr><tr><td style="text-align:center">spring-boot-starter-jooq</td><td style="text-align:center">jOOQ访问SQL数据库的启动器。替代spring-boot-starter-data-jpa或spring-boot-starter-jdbc</td></tr><tr><td style="text-align:center">spring-boot-starter-json</td><td style="text-align:center">阅读和写作json</td></tr><tr><td style="text-align:center">spring-boot-starter-jta-atomikos</td><td style="text-align:center">Atomikos进行JTA交易</td></tr><tr><td style="text-align:center">spring-boot-starter-jta-bitronix</td><td style="text-align:center">Bitronix进行JTA事务</td></tr><tr><td style="text-align:center">spring-boot-starter-mail</td><td style="text-align:center">Java Mail和Spring Framework的电子邮件发送支持</td></tr><tr><td style="text-align:center">spring-boot-starter-mustache</td><td style="text-align:center">Mustache视图构建Web应用程序</td></tr><tr><td style="text-align:center">spring-boot-starter-oauth2-client</td><td style="text-align:center">Spring Security的OAuth2 / OpenID Connect客户端功能</td></tr><tr><td style="text-align:center">spring-boot-starter-oauth2-resource-server</td><td style="text-align:center">Spring Security的OAuth2资源服务器功能</td></tr><tr><td style="text-align:center">spring-boot-starter-quartz</td><td style="text-align:center">Quartz调度程序</td></tr><tr><td style="text-align:center">spring-boot-starter-security</td><td style="text-align:center">Spring Security</td></tr><tr><td style="text-align:center">spring-boot-starter-test</td><td style="text-align:center">JUnit，Hamcrest和Mockito等库来测试Spring Boot应用程序</td></tr><tr><td style="text-align:center">spring-boot-starter-thymeleaf</td><td style="text-align:center">Thymeleaf视图构建MVC Web应用程序</td></tr><tr><td style="text-align:center">spring-boot-starter-validation</td><td style="text-align:center">Java Bean Validation和Hibernate Validator</td></tr><tr><td style="text-align:center">spring-boot-starter-web</td><td style="text-align:center">Spring MVC构建Web（包括RESTful）应用程序的启动器。使用Tomcat作为默认嵌入式容器</td></tr><tr><td style="text-align:center">spring-boot-starter-web-services</td><td style="text-align:center">Spring Web Services</td></tr><tr><td style="text-align:center">spring-boot-starter-webflux</td><td style="text-align:center">Spring Framework的Reactive Web支持构建WebFlux应用程序</td></tr><tr><td style="text-align:center">spring-boot-starter-websocket</td><td style="text-align:center">Spring Framework的WebSocket支持构建WebSocket应用程序</td></tr></tbody></table><p>生产模块功能：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">spring-boot-starter-actuator</td><td style="text-align:center">Spring Boot的Actuator的启动器，它提供生产就绪功能，帮助您监控和管理您的应用程序</td></tr></tbody></table><p>最后，如果要排除或交换特定的技术方面，Spring Boot还包括以下启动器：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">spring-boot-starter-jetty</td><td style="text-align:center">Jetty作为嵌入式servlet容器，替代spring-boot-starter-tomcat</td></tr><tr><td style="text-align:center">spring-boot-starter-log4j2</td><td style="text-align:center">Log4j2进行日志记录。替代spring-boot-starter-logging</td></tr><tr><td style="text-align:center">spring-boot-starter-logging</td><td style="text-align:center">Logback进行日志记录。默认日志启动器</td></tr><tr><td style="text-align:center">spring-boot-starter-reactor-netty</td><td style="text-align:center">Reactor Netty作为嵌入式响应式HTTP服务器</td></tr><tr><td style="text-align:center">spring-boot-starter-tomcat</td><td style="text-align:center">Tomcat作为嵌入式servlet容器。使用的默认servlet容器启动器spring-boot-starter-web</td></tr><tr><td style="text-align:center">spring-boot-starter-undertow</td><td style="text-align:center">Undertow作为嵌入式servlet容器。替代spring-boot-starter-tomcat</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Starters </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SpringBoot-Maven</title>
      <link href="/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Maven/"/>
      <url>/2019/03/20/%E4%BD%BF%E7%94%A8SpringBoot-Maven/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本次学习的SpringBoot版本为2.1.3.RELEASE，同时文档内容有点多，只会拿出个人认为要学习的部分来学习</p><h2 id="直接继承Starter-Parent"><a href="#直接继承Starter-Parent" class="headerlink" title="直接继承Starter Parent"></a>直接继承Starter Parent</h2><p>在<code>pom.xml</code>文件中添加以下代码:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>您要在此依赖项上指定Spring Boot版本号。如果导入其他启动器，则可以省略版本号。</p></blockquote><p>我们还可以通过<code>properties</code>来更好的管理版本信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在指定版本号处指定引入的设置的属性值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在父pom中引用"><a href="#在父pom中引用" class="headerlink" title="在父pom中引用"></a>在父pom中引用</h2><p>不是每个人都喜欢从<code>spring-boot-starter-parent</code>POM 继承。您可能拥有自己需要使用的公司标准父级，或者您可能更愿意明确声明所有Maven配置。</p><p>如果您不想使用<code>spring-boot-starter-parent</code>，您仍然可以通过使用<code>scope=import</code>依赖项来保持依赖项管理（但不是插件管理）的好处 ，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上所述，前面的示例设置不允许您使用属性覆盖单个依赖项。要获得相同的结果，您需要在输入之前在<code>dependencyManagement</code>项目中添加一个 条目。例如，要升级到另一个Spring Data版本系列，您可以将以下元素添加到<code>pom.xml</code>：<code>spring-boot-dependencies</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Override Spring Data release train provided by Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>需要进行一下系统的学习了</title>
      <link href="/2019/03/19/%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BA%86/"/>
      <url>/2019/03/19/%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    虽说目前大部分的技术都已经入门了，但是没有系统化的学习流程，导致脑中的知识点特别零散，需要好好的进行一次系统化的学习。这段时间找不到工作，想过公考(大四的时候考过一次，失败)，但不感兴趣，还是得遵从自己的内心。不想生活失去乐趣，不想成为行尸走肉般的廉价劳动力，不想受制于人，等等，，，</p><p>​    本次系统化的学习预计时间为1个月，主要是针对SpringBoot和SpringCloud的学习，根据官方参考文档来学习，理论加上实操。多余的就不说了，加油吧…</p>]]></content>
      
      
      <categories>
          
          <category> live </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora的简单使用</title>
      <link href="/2019/03/19/Typora%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/03/19/Typora%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora的简单使用"><a href="#Typora的简单使用" class="headerlink" title="Typora的简单使用"></a>Typora的简单使用</h1><h2 id="Typora的优点"><a href="#Typora的优点" class="headerlink" title="Typora的优点"></a>Typora的优点</h2><ul><li>简洁美观</li><li>实时预览</li><li>扩展语法</li><li>跨平台</li><li><strong>免费</strong></li></ul><h2 id="主要功能介绍"><a href="#主要功能介绍" class="headerlink" title="主要功能介绍"></a>主要功能介绍</h2><p>###对文字的特殊标注</p><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>快捷键<code>ctrl</code>+<code>1</code>到<code>6</code></p><p><code># //这是一级标题</code></p><p><code>## //这是二级标题</code></p><p><code>... //一共6级</code></p><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><p>快捷键 <code>ctrl</code>+<code>u</code>实现文字带下划线</p><p>效果：<u>下划线</u></p><p>源代码：<code>&lt;u&gt;下划线&lt;/u&gt;</code></p><h4 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h4><p>在需要加粗的文字前后加上两个<code>*</code>，快捷键<code>ctrl</code>+<code>b</code></p><p>效果：<strong>加粗</strong></p><p>源代码：<code>**加粗**</code></p><h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>在需要斜体的文字前后加上一个<code>*</code>，快捷键<code>ctrl</code>+<code>i</code></p><p>效果：<em>斜体</em></p><p>源代码：<code>*斜体*</code></p><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>快捷键<code>alt</code>+<code>shift</code>+<code>5</code>文字前后加上两个英文输入法的~</p><p>效果：<del>删除线</del></p><p>源代码：<code>~~删除线~~</code></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>快捷键<code>ctrl</code>+<code>shift</code>+<code>q</code></p><blockquote><p>这段话引用自…</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这段话引用自...</span></span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>输入任意开始数字+<code>.</code>+<code>空格</code>始有序列表</p><p>例如：<code>2</code>+<code>.</code> +<code>空格</code></p><ol start="2"><li>列表项1</li><li>列表项2</li><li>列表项3</li></ol><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>输入<code>+</code>或<code>-</code>或<code>*</code>加上<code>空格</code></p><p>例如：<code>+</code>+<code>空格</code></p><ul><li>列表项1</li><li>列表项2 </li><li>列表项3</li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>快捷键<code>ctrl</code>+<code>t</code></p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:right">姓名</th><th style="text-align:center">学号</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:right">张三</td><td style="text-align:center">10001</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">李四</td><td style="text-align:center">10002</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 序号 | 姓名 | 学号  |</span><br><span class="line">| :--- | ---: | :---: |</span><br><span class="line">| 1    | 张三 | 10001 |</span><br><span class="line">| 2    | 李四 | 10002 |</span><br></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>三个或三个以上的<code>-</code>或<code>*</code></p><hr><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>快捷键<code>ctrl</code>+<code>shift</code>+<code>i</code></p><p><img src="D:\迅雷下载\user.jpg" alt="头像"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">头像</span>](<span class="link">D:\迅雷下载\user.jpg</span>)</span><br></pre></td></tr></table></figure><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><p>快捷键<code>ctrl</code>+<code>k</code></p><p><a href="https://www.hao123.com" target="_blank" rel="noopener">hao123</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">hao123</span>](<span class="link">https://www.hao123.com</span>)</span><br></pre></td></tr></table></figure><h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><p>快捷键<code>ctrl</code>+<code>shift</code>+<code>m</code><br>$$<br>数学公式<br>$$</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>行内代码：快捷键<code>ctrl</code>+<code>shift</code>+<code>或者直接`</code></p><p><code>这是行内代码</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`这是行内代码`</span></span><br></pre></td></tr></table></figure><p>代码块：快捷键<code>ctrl</code>+<code>shift</code>+<code>k</code>或者三个<code>~</code>+<code>回车</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个Java代码块</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​~~~java</span><br><span class="line">这是一个Java代码块</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">#### 5.5生成目录</span></span><br><span class="line"></span><br><span class="line">[TOC]</span><br><span class="line"></span><br><span class="line"><span class="code">`[toc]`</span>+<span class="code">`回车`</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 三、输出文件格式多样化</span></span><br><span class="line"></span><br><span class="line">详情请参考菜单栏中<span class="code">`文件`</span>下的<span class="code">`导出`</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+Github搭建自己的博客（小技巧）</title>
      <link href="/2019/03/19/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%89/"/>
      <url>/2019/03/19/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Hexo-Github搭建自己的博客（小技巧）"><a href="#使用Hexo-Github搭建自己的博客（小技巧）" class="headerlink" title="使用Hexo+Github搭建自己的博客（小技巧）"></a>使用Hexo+Github搭建自己的博客（小技巧）</h1><h2 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h2><p>目前NexT主题最新的是V6.0版本，这个版本中可以有4种动态背景：</p><ul><li>Canvas-nest</li><li>three_waves</li><li>canvas_lines</li><li>canvas_sphere</li></ul><p>设置方法也很简单，直接设置里需要的动态背景为<code>true</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="文章底部带-号的标签"><a href="#文章底部带-号的标签" class="headerlink" title="文章底部带#号的标签"></a>文章底部带#号的标签</h2><p>去掉文章后面的标签前面的#号。</p><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h2 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h2><p>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件,并添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;</span></span><br><span class="line">        -------------本文结束</span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-paw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        感谢您的阅读-------------</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后， 添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">&#123;% include 'passage-end-tag.swig' %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后打开主题配置文件<code>_config.yml</code>,在末尾添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。</p><h2 id="侧边栏社交小图标设置"><a href="#侧边栏社交小图标设置" class="headerlink" title="侧边栏社交小图标设置"></a>侧边栏社交小图标设置</h2><p>打开主题配置文件<code>_config.yml</code>，搜索<code>social:</code>, ||之后是在图标库中对应的图标。注意空格就行。</p><p>图标库链接：<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">http://fontawesome.io/icons/</a></p><h2 id="主页文章加阴影"><a href="#主页文章加阴影" class="headerlink" title="主页文章加阴影"></a>主页文章加阴影</h2><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line"><span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(202, 203, 203, .5);</span><br><span class="line"><span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(202, 203, 204, .5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加热度"><a href="#添加热度" class="headerlink" title="添加热度"></a>添加热度</h2><p>next主题集成<code>leanCloud</code>，打开<code>/themes/next/layout/_macro/post.swig</code></p><p>在<code>&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</code>下添加一句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>℃<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后打开，<code>/themes/next/languages/zh-Hans.yml</code></p><p>将<code>visitors: 阅读次数</code>改为<code>visitors: 热度</code></p><h2 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h2><p>默认的网站图标是一个N，当然是需要制定一个图了，在网上找到图后，将其放在<code>/themes/next/source/images</code>里面，然后在主题配置文件中修改下图所示图片位置</p><p>还有一些就不详细说了，另外注意下好多的东西已经过时了。比如next主题已经换了域了。很多教程还停留在3.0时代，但是现在next的版本是V6.0，截止我这篇教程发布的时期。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章就只是简单的介绍了下NexT主题，关于这个主题呢，要达到个性化定制的话，还是需要再花点功夫的。还有就是这个hexo s预览效果确实不好，修改了网站内容之后，需要重新hexo clean再hexo s才能看到效果，有同样问题的兄dei就不需要担心自己的修改是错的。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+Github搭建自己的博客（进阶）</title>
      <link href="/2019/03/19/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/"/>
      <url>/2019/03/19/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Hexo-Github搭建自己的博客（进阶）"><a href="#使用Hexo-Github搭建自己的博客（进阶）" class="headerlink" title="使用Hexo+Github搭建自己的博客（进阶）"></a>使用Hexo+Github搭建自己的博客（进阶）</h1><p>主题的配置：这里以NexT主题作为题材</p><h2 id="安装NexT"><a href="#安装NexT" class="headerlink" title="安装NexT"></a>安装NexT</h2><p>在其文件夹中鼠标右键，点击Git Base Here</p><p>输入命令：<code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Administrator@yd MINGW64 /d/GitHub/hexo</span><br><span class="line"><span class="meta">$</span> git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">Cloning into 'themes/next'...</span><br><span class="line">remote: Enumerating objects: 12033, done.</span><br><span class="line">remote: Total 12033 (delta 0), reused 0 (delta 0), pack-reused 12033</span><br><span class="line">Receiving objects: 100% (12033/12033), 12.95 MiB | 824.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (6960/6960), done.</span><br></pre></td></tr></table></figure><h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>在站点目录中（hexo），打开配置文件<code>_config.yml</code>，修改<code>theme：next</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><h2 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h2><p>端口号被占用还是得先修改端口号，然后启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Administrator@yd MINGW64 /d/GitHub/hexo</span><br><span class="line"><span class="meta">$</span> hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN  ========================= ATTENTION! ==========================</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN   NexT repository is moving here: https://github.com/theme-next</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN   It's rebase to v6.0.0 and future maintenance will resume there</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><h2 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h2><p>在next主题目录下的<code>_config.yml</code>文件中将<code>scheme</code>设定为<code>Pisces</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure><h2 id="语言设定"><a href="#语言设定" class="headerlink" title="语言设定"></a>语言设定</h2><p>在站点根目录下修改配置文件<code>_cofig.yml</code>中的<code>language</code>为<code>zh-Hans</code>（简体中文）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure><h2 id="修改菜单项"><a href="#修改菜单项" class="headerlink" title="修改菜单项"></a>修改菜单项</h2><p>在主题目录下修改配置文件<code>_cofig.yml</code>中的<code>menu</code>，增添一个<code>something</code>（注：千万不要在这设置中文，后面的值那是查找文件的地方！若你的站点运行在子目录中，请将链接前缀的 / 去掉）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在子目录（例如domain.tld/blog）中运行站点时，从链接值（/archives -&gt; archives）中删除前导斜杠。</span></span><br><span class="line"><span class="comment">#用法：`Key：/ link / ||icon`</span></span><br><span class="line"><span class="comment">#Key是菜单项的名称。 如果此菜单的翻译将在语言中找到 - 此翻译将被加载; 如果不是 - 将使用密钥名称。</span></span><br><span class="line"><span class="comment">#关键是案例敏感。</span></span><br><span class="line"><span class="comment">#` ||'delimeter之前的值是目标链接。</span></span><br><span class="line"><span class="comment">#在|||`delimeter之后的值是FontAwesome图标的名称。</span></span><br><span class="line"><span class="comment">#如果未指定图标（带或不带分隔符），则将加载问题图标。</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"><span class="attr">  something:</span> <span class="string">/something</span></span><br></pre></td></tr></table></figure><p>这些配置都要与你主题目录下的<code>languages</code>文件中对应的yml文档里配置相关联。比如你在站点根目录中的配置文件设置<code>language</code>为<code>zh-Hans</code>，那么就要进入到主题目录下的<code>languages</code>文件中修改<code>zh-Hans.yml</code>，这样才能显示出菜单项新增的中文内容（以something为例子）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">  archive:</span> <span class="string">归档</span></span><br><span class="line"><span class="attr">  category:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">  tag:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">日程表</span></span><br><span class="line"></span><br><span class="line"><span class="attr">author:</span> <span class="string">博主</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">首页</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">归档</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">关于</span></span><br><span class="line"><span class="attr">  search:</span> <span class="string">搜索</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">日程表</span></span><br><span class="line"><span class="attr">  sitemap:</span> <span class="string">站点地图</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">公益404</span></span><br><span class="line"><span class="attr">  something:</span> <span class="string">什么事</span></span><br></pre></td></tr></table></figure><h2 id="设置侧栏位置"><a href="#设置侧栏位置" class="headerlink" title="设置侧栏位置"></a>设置侧栏位置</h2><p>修改主题目录下<code>sidebar</code>的<code>position</code>值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position, available value: left | right (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="comment">#position: left</span></span><br><span class="line"><span class="attr">  position:</span> <span class="string">right</span></span><br></pre></td></tr></table></figure><h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p>在站点根目录下载配置文件中新增<code>avatar</code>，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在<code>source/images/</code>目录下）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/images/user.jpg</span></span><br></pre></td></tr></table></figure><h2 id="设置文章代码主题"><a href="#设置文章代码主题" class="headerlink" title="设置文章代码主题"></a>设置文章代码主题</h2><p>在主题目录下修改配置文件<code>highlight_theme</code>，默认值为<code>nomal</code>。可以设置为<code>night</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br></pre></td></tr></table></figure><h2 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h2><p>前面通过修改next主题下的<code>_config.yml</code>文件中的<code>menu</code>选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示<code>page not found</code>。此时我们要新建一个页面</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Administrator@yd</span> <span class="string">MINGW64</span> <span class="string">/d/GitHub/hexo</span></span><br><span class="line"><span class="string">$</span> <span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">tags</span></span><br><span class="line"><span class="string">INFO</span>  <span class="attr">Created:</span> <span class="attr">D:\GitHub\hexo\source\tags\index.md</span></span><br></pre></td></tr></table></figure><p>在新建的<code>index.md</code>文件中添加<code>type: &quot;tags&quot;</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2019-03-19 07:31:27</span><br><span class="line">type: tags</span><br></pre></td></tr></table></figure><p>当要为某一篇文章添加标签，只需在<code>blog/source/_post</code>目录下的具体文章的tags中添加标签即可，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: '你好,Hexo'</span><br><span class="line">date: 2019-03-19 07:31:27</span><br><span class="line">type: [hexo,github,npm,基础]</span><br><span class="line">categories: 搭建博客</span><br></pre></td></tr></table></figure><h2 id="添加关于我页面，步骤和以上差不多"><a href="#添加关于我页面，步骤和以上差不多" class="headerlink" title="添加关于我页面，步骤和以上差不多"></a>添加关于我页面，步骤和以上差不多</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Administrator@yd MINGW64 /d/GitHub/hexo</span><br><span class="line"><span class="meta">$</span> hexo new page about</span><br><span class="line">INFO  Created: D:\GitHub\hexo\source\about\index.md</span><br></pre></td></tr></table></figure><p>在新建的<code>index.md</code>文件中添加如下内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2019-03-19 07:27:47</span><br><span class="line">---</span><br><span class="line"><span class="section">## 关于我</span></span><br><span class="line"></span><br><span class="line">一个爱学习的好宝宝~~~</span><br><span class="line"></span><br><span class="line">email：994300880@qq.com</span><br></pre></td></tr></table></figure><h2 id="在首页添加github导航条"><a href="#在首页添加github导航条" class="headerlink" title="在首页添加github导航条"></a>在首页添加github导航条</h2><p>点击<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">这里</a>选择需要的样式，然后将代码复制到<code>themes/next/layout/_layout.swig</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125;"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"headband"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加到这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/you"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"149"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">height</span>=<span class="string">"149"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">src</span>=<span class="string">"https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"attachment-full size-full"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">alt</span>=<span class="string">"Fork me on GitHub"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">data-recalc-dims</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 结束 --&gt;</span></span><br></pre></td></tr></table></figure><p>并将<code>href</code>改为你的github地址</p><h2 id="实现点击出现桃心效果"><a href="#实现点击出现桃心效果" class="headerlink" title="实现点击出现桃心效果"></a>实现点击出现桃心效果</h2><p>创建js文件：在<code>/themes/next/source/js/src</code>下新建文件<code>clicklove.js</code>，接着把该链接下的代码拷贝粘贴到<code>clicklove.js</code>文件中。<br>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>修改<code>_layout.swig</code>：在<code>\themes\next\layout\_layout.swig</code>文件末尾添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/clicklove.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修改作者头像并旋转"><a href="#修改作者头像并旋转" class="headerlink" title="修改作者头像并旋转"></a>修改作者头像并旋转</h2><p>打开<code>\themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>，在里面添加如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 头像圆形 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0</span> -<span class="number">1px</span> <span class="number">0</span> <span class="number">#333</span>sf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 </span></span><br><span class="line"><span class="comment">    (ase-out)动画播放的速度曲线为以低速结束 </span></span><br><span class="line"><span class="comment">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: -webkit-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: -moz-transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1.0s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* 鼠标经过停止头像旋转 </span></span><br><span class="line"><span class="comment">  -webkit-animation-play-state:paused;</span></span><br><span class="line"><span class="comment">  animation-play-state:paused;*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 鼠标经过头像旋转360度 */</span></span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Z 轴旋转动画 */</span></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在网站底部加上访问量"><a href="#在网站底部加上访问量" class="headerlink" title="在网站底部加上访问量"></a>在网站底部加上访问量</h2><p>打开<code>\themes\next\layout\_partials\footer.swig</code>文件,在类<code>copyright</code>前(在第一行)加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 统计JS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 结束 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"copyright"</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>然后在合适的位置添加显示统计的代码(位置还是上述这个文件)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 合适的位置添加显示统计 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user-md"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span></span><br><span class="line">  本站访客数:<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 统计结束 --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="修改底部的官方logo"><a href="#修改底部的官方logo" class="headerlink" title="修改底部的官方logo"></a>修改底部的官方logo</h2><p>找到 <code>\themes\next\layout\_partials\</code>下面的<code>footer.swig</code>文件，打开会发现，如下图的语句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 统计JS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 结束 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 合适的位置添加显示统计 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-user-md"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span></span><br><span class="line">  本站访客数:<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 统计结束 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"copyright"</span>&gt;</span>&#123;#</span><br><span class="line">#&#125;&#123;% set current = date(Date.now(), "YYYY") %&#125;&#123;#</span><br><span class="line">#&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;</span><br><span class="line">    &#123;&#123; theme.footer.since &#125;&#125; &amp;mdash; &#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;<span class="tag">&lt;<span class="name">span</span> <span class="attr">itemprop</span>=<span class="string">"copyrightYear"</span>&gt;</span>&#123;&#123; current &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"with-love"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-&#123;&#123; theme.footer.icon &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 第一个框 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"author"</span> <span class="attr">itemprop</span>=<span class="string">"copyrightHolder"</span>&gt;</span></span><br><span class="line">      &#123;&#123; theme.footer.copyright || config.author &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 结束 --&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;% if theme.post_wordcount.totalcount %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-area-chart"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;% if theme.post_wordcount.item_text %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>&#123;&#123; __('post.totalcount') &#125;&#125;&amp;#58;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; __('post.totalcount') &#125;&#125;"</span>&gt;</span>&#123;#</span><br><span class="line">    #&#125;&#123;&#123; totalcount(site, '0,0.0a') &#125;&#125;&#123;#</span><br><span class="line">  #&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第二个框 --&gt;</span></span><br><span class="line">&#123;% if theme.footer.powered %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span>&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __('footer.powered', '<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> </span></span><br><span class="line"><span class="tag">                                <span class="attr">href</span>=<span class="string">"https://hexo.io"</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span>') &#125;&#125;&#123;#</span><br><span class="line">#&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 结束 --&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第三个框 --&gt;</span></span><br><span class="line">&#123;% if theme.footer.theme.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-info"</span>&gt;</span>&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __('footer.theme') &#125;&#125; &amp;mdash; &#123;#</span><br><span class="line">  #&#125;<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">href</span>=<span class="string">"https://github.com/iissnan/hexo-theme-next"</span>&gt;</span>&#123;#</span><br><span class="line">    #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;#</span><br><span class="line">  #&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 结束 --&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.custom_text %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer-custom"</span>&gt;</span>&#123;#</span><br><span class="line">  #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;#</span><br><span class="line">#&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>第一个框 是下面侧栏的“日期❤ XXX”</p><p>如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。</p><p>第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把<a>…</a>标签这部分删除即可，留着两个单引号’’,否则会出错哦。</p><p>第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将<a>..</a>都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。</p><p>接下来，处理剩余的中文信息。找到这个地方<code>\themes\next\languages\</code> 下面的语言文件<code>zh-Hans.yml</code>（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">counter:</span></span><br><span class="line"><span class="attr">  tag_cloud:</span></span><br><span class="line"><span class="attr">    zero:</span> <span class="string">暂无标签</span></span><br><span class="line"><span class="attr">    one:</span> <span class="string">目前共计</span> <span class="number">1</span> <span class="string">个标签</span></span><br><span class="line"><span class="attr">    other:</span> <span class="string">"目前共计 %d 个标签"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  categories:</span></span><br><span class="line"><span class="attr">    zero:</span> <span class="string">暂无分类</span></span><br><span class="line"><span class="attr">    one:</span> <span class="string">目前共计</span> <span class="number">1</span> <span class="string">个分类</span></span><br><span class="line"><span class="attr">    other:</span> <span class="string">"目前共计 %d 个分类"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  archive_posts:</span></span><br><span class="line"><span class="attr">    zero:</span> <span class="string">暂无日志。</span></span><br><span class="line"><span class="attr">    one:</span> <span class="string">目前共计</span> <span class="number">1</span> <span class="string">篇日志。</span></span><br><span class="line"><span class="attr">    other:</span> <span class="string">"目前共计 %d 篇日志。"</span></span><br></pre></td></tr></table></figure><p>看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+Github搭建自己的博客（基础）</title>
      <link href="/2019/03/19/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
      <url>/2019/03/19/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Hexo-Github搭建自己的博客（基础）"><a href="#使用Hexo-Github搭建自己的博客（基础）" class="headerlink" title="使用Hexo+Github搭建自己的博客（基础）"></a>使用Hexo+Github搭建自己的博客（基础）</h1><p>前言：电脑系统为window 7，64位</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="安装Node-js和配置好Node-js环境，打开cmd命令行，成功界面如下"><a href="#安装Node-js和配置好Node-js环境，打开cmd命令行，成功界面如下" class="headerlink" title="安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下"></a>安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\系统名&gt;node -v</span><br><span class="line">v10.11.4</span><br><span class="line"></span><br><span class="line">C:\Users\系统名&gt;npm -v</span><br><span class="line">6.4.2</span><br></pre></td></tr></table></figure><h3 id="安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现两个选择"><a href="#安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现两个选择" class="headerlink" title="安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现两个选择"></a>安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现两个选择</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git GUI Here</span><br><span class="line">Git Bash Here</span><br></pre></td></tr></table></figure><p>注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。</p><h3 id="Github账户注册和新建项目，项目必须要遵守格式：账户名-github-io，不然接下来会有很多麻烦。并且需要勾选Initialize-this-repository-with-a-README"><a href="#Github账户注册和新建项目，项目必须要遵守格式：账户名-github-io，不然接下来会有很多麻烦。并且需要勾选Initialize-this-repository-with-a-README" class="headerlink" title="Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README"></a>Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README</h3><p>在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。</p><h3 id="安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面"><a href="#安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面" class="headerlink" title="安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面"></a>安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\系统名&gt;D:</span><br><span class="line"></span><br><span class="line">D:\&gt;cd Github</span><br><span class="line"></span><br><span class="line">D:\Github&gt;cd hexo</span><br><span class="line"></span><br><span class="line">D:\Github\hexo&gt;</span><br></pre></td></tr></table></figure><ul><li><p>输入npm install hexo -g，开始安装Hexo</p></li><li><p>输入hexo -v，检查hexo是否安装成功</p></li><li><p>输入hexo init，初始化该文件夹（有点漫长的等待。。。）</p><p>看到后面的“Start blogging with Hexo！”，激动有木有！！！！！</p></li><li><p>输入npm install，安装所需要的组件</p></li><li><p>输入hexo g，首次体验Hexo</p></li><li><p>输入hexo s，开启服务器，访问该网址，正式体验Hexo</p><p>问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号</p></li><li><p>成功访问首页</p></li></ul><h3 id="将Hexo与Github-page联系起来，设置Git的user-name和email（如果是第一次的话）"><a href="#将Hexo与Github-page联系起来，设置Git的user-name和email（如果是第一次的话）" class="headerlink" title="将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）"></a>将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）</h3><p>在hexo文件夹里面鼠标右键，点击Git Base Here</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Administrator@yd MINGW64 /d/GitHub/hexo</span><br><span class="line"><span class="meta">$</span> git config --global user.name "用户名"</span><br><span class="line"></span><br><span class="line">Administrator@yd MINGW64 /d/GitHub/hexo</span><br><span class="line"><span class="meta">$</span> git config --global user.email "邮箱"</span><br></pre></td></tr></table></figure><ul><li><p>输入cd ~/.ssh，检查是否由.ssh的文件夹</p></li><li><p>输入ls，列出该文件下的内容。下图说明存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Administrator@yd MINGW64 ~/.ssh</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">id_rsa  id_rsa.pub  known_hosts</span><br></pre></td></tr></table></figure></li><li><p>输入ssh-keygen -t rsa -C “邮箱”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）</p></li><li><p>输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p></li><li><p>再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</p></li><li><p>登录Github，点击头像下的settings，添加ssh</p></li><li><p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</p></li><li><p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p><p><strong>问题</strong>：假如ssh-key配置失败，那么只要以下步骤就能完全解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">首先，清除所有的key-pair</span><br><span class="line">ssh-add -D</span><br><span class="line">rm -r ~/.ssh</span><br><span class="line">删除你在github中的public-key</span><br><span class="line"></span><br><span class="line">重新生成ssh密钥对</span><br><span class="line">ssh-keygen -t rsa -C "xxx@xxx.com"</span><br><span class="line"></span><br><span class="line">接下来正常操作</span><br><span class="line">在github上添加公钥public-key:</span><br><span class="line">1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板</span><br><span class="line">2、在github上添加公钥时，直接复制即可</span><br><span class="line">3、保存</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">在终端 ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置Deployment，在其文件夹中，找到-config-yml文件，修改repo值（在末尾）"><a href="#配置Deployment，在其文件夹中，找到-config-yml文件，修改repo值（在末尾）" class="headerlink" title="配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）"></a>配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p><code>repository</code>的值为github项目里的ssh（右下角）</p><h3 id="新建一篇博客，在cmd执行命令：hexo-new-post-“博客名”"><a href="#新建一篇博客，在cmd执行命令：hexo-new-post-“博客名”" class="headerlink" title="新建一篇博客，在cmd执行命令：hexo new post “博客名”"></a>新建一篇博客，在cmd执行命令：hexo new post “博客名”</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Github\hexo&gt;hexo new post "hello,Hexo"</span><br><span class="line">INFO Created: D:\Github\hexo\source\_posts\hello-Hexo.md</span><br></pre></td></tr></table></figure><p>这时候在文件夹_posts目录下将会看到已经创建的文件</p><ul><li>在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save</li><li>使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了</li><li>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章</li></ul><p>好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来是进阶的操作</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开头篇</title>
      <link href="/2019/03/19/%E5%BC%80%E5%A4%B4%E7%AF%87/"/>
      <url>/2019/03/19/%E5%BC%80%E5%A4%B4%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>​    今天学习使用Hexo+Github搭建个人博客，这个框架大部分都是依赖Yaml配置文件进行功能的配置，确实很方便，简单的进行了一下定制化，目前可以开始使用了，可能有些功能无法使用或舒适性不强，待后续学习改进…</p>]]></content>
      
      
      <categories>
          
          <category> live </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
