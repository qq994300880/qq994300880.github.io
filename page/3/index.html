<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="正忙着优秀~~~"><meta name="keywords" content><meta name="author" content="YoungDream,undefined"><meta name="copyright" content="YoungDream"><title>小小搬砖工【YD Blog】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon-16x16-user.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!--link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!--link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!--script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"0BGAOITLJQ","apiKey":"2c864a8b4720c83c2ddfc7e53d4c1711","indexName":"article_NAME","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/user.jpg"></div><div class="author-info-name">YoungDream</div><div class="author-info-description">正忙着优秀~~~</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/qq994300880" target="_blank">GitHub<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="http://wpa.qq.com/msgrd?v=3&amp;uin=994300880&amp;site=qq&amp;menu=yes" target="_blank">QQ<i class="icon-dot bg-color6"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">50</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">62</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">7</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">YD Blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-JTA的分布式事务/">使用SpringBoot-JTA的分布式事务</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/jta/">jta</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/atomikos/">atomikos</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/bitronix/">bitronix</a></div></div><div class="post-content"><div class="main-content content"><h1 id="JTA的分布式事务"><a href="#JTA的分布式事务" class="headerlink" title="JTA的分布式事务"></a>JTA的分布式事务</h1><p>Spring Boot通过使用<a href="http://www.atomikos.com/" target="_blank" rel="noopener">Atomikos</a>或<a href="https://github.com/bitronix/btm" target="_blank" rel="noopener">Bitronix</a> 嵌入式事务管理器支持跨多个XA资源的分布式JTA事务。部署到合适的Java EE Application Server时，也支持JTA事务。</p>
<p>检测到JTA环境时，Spring <code>JtaTransactionManager</code>用于管理事务。自动配置的JMS，DataSource和JPA bean已升级为支持XA事务。您可以使用标准的Spring惯用语，例如<code>@Transactional</code>，参与分布式事务。如果您在JTA环境中并仍希望使用本地事务，则可以将该<code>spring.jta.enabled</code>属性设置<code>false</code>为禁用JTA自动配置。</p>
<h2 id="使用Atomikos事务管理器"><a href="#使用Atomikos事务管理器" class="headerlink" title="使用Atomikos事务管理器"></a>使用Atomikos事务管理器</h2><p><a href="https://www.atomikos.com/" target="_blank" rel="noopener">Atomikos</a>是一个流行的开源事务管理器，可以嵌入到Spring Boot应用程序中。您可以使用 <code>spring-boot-starter-jta-atomikos</code>Starter引入相应的Atomikos库。Spring Boot自动配置Atomikos并确保将适当的<code>depends-on</code>设置应用于Spring bean以正确启动和关闭顺序。</p>
<p>默认情况下，Atomikos事务日志将写入<code>transaction-logs</code>应用程序主目录（应用程序jar文件所在的目录）中的目录。您可以通过<code>spring.jta.log-dir</code>在<code>application.properties</code>文件中设置属性来自定义此目录的位置 。以…开头的属性<code>spring.jta.atomikos.properties</code>也可用于自定义Atomikos<code>UserTransactionServiceImp</code>。有关 完整的详细信息，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html" target="_blank" rel="noopener"><code>AtomikosProperties</code>Javadoc</a>。</p>
<blockquote>
<p>为确保多个事务管理器可以安全地协调相同的资源管理器，必须使用唯一ID配置每个Atomikos实例。默认情况下，此ID是运行Atomikos的计算机的IP地址。要确保生产中的唯一性，应<code>spring.jta.transaction-manager-id</code> 为应用程序的每个实例配置具有不同值的属性。</p>
</blockquote>
<h2 id="使用Bitronix事务管理器"><a href="#使用Bitronix事务管理器" class="headerlink" title="使用Bitronix事务管理器"></a>使用Bitronix事务管理器</h2><p><a href="https://github.com/bitronix/btm" target="_blank" rel="noopener">Bitronix</a>是一种流行的开源JTA事务管理器实现。您可以使用<code>spring-boot-starter-jta-bitronix</code>starter将适当的Bitronix依赖项添加到项目中。与Atomikos一样，Spring Boot会自动配置Bitronix并对bean进行后处理，以确保启动和关闭顺序正确。</p>
<p>默认情况下，Bitronix事务日志文件（<code>part1.btm</code>和<code>part2.btm</code>）将写入<code>transaction-logs</code>应用程序主目录中的目录。您可以通过设置<code>spring.jta.log-dir</code>属性来自定义此目录的位置。以…开头的属性<code>spring.jta.bitronix.properties</code>也绑定到 <code>bitronix.tm.Configuration</code>bean，允许完全自定义。有关详细信息，请参阅 <a href="https://github.com/bitronix/btm/wiki/Transaction-manager-configuration" target="_blank" rel="noopener">Bitronix文档</a>。</p>
<blockquote>
<p>为确保多个事务管理器可以安全地协调相同的资源管理器，必须为每个Bitronix实例配置唯一ID。默认情况下，此ID是运行Bitronix的计算机的IP地址。要确保生产中的唯一性，应<code>spring.jta.transaction-manager-id</code> 为应用程序的每个实例配置具有不同值的属性。</p>
</blockquote>
<h2 id="使用Java-EE托管事务管理器"><a href="#使用Java-EE托管事务管理器" class="headerlink" title="使用Java EE托管事务管理器"></a>使用Java EE托管事务管理器</h2><p>如果将Spring Boot应用程序打包为一个<code>war</code>或一个<code>ear</code>文件并将其部署到Java EE应用程序服务器，则可以使用应用程序服务器的内置事务管理器。Spring Boot尝试通过查看常见的JNDI位置（<code>java:comp/UserTransaction</code>，<code>java:comp/TransactionManager</code>等等）来自动配置事务管理器。如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器管理并通过JNDI公开。Spring Boot尝试通过查找<code>ConnectionFactory</code>JNDI路径（<code>java:/JmsXA</code>或<code>java:/XAConnectionFactory</code>）来自动配置JMS ，您可以使用该 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-connecting-to-a-jndi-datasource" target="_blank" rel="noopener"><code>spring.datasource.jndi-name</code>属性</a> 来配置您的<code>DataSource</code>。</p>
<h2 id="混合XA和非XA-JMS连接"><a href="#混合XA和非XA-JMS连接" class="headerlink" title="混合XA和非XA JMS连接"></a>混合XA和非XA JMS连接</h2><p>使用JTA时，主JMS <code>ConnectionFactory</code>bean可识别XA并参与分布式事务。在某些情况下，您可能希望使用非XA处理某些JMS消息<code>ConnectionFactory</code>。例如，您的JMS处理逻辑可能需要比XA超时更长的时间。</p>
<p>如果要使用非XA <code>ConnectionFactory</code>，可以注入 <code>nonXaJmsConnectionFactory</code>bean而不是<code>@Primary</code> <code>jmsConnectionFactory</code>bean。为了保持一致性，<code>jmsConnectionFactory</code>还使用bean别名提供bean <code>xaJmsConnectionFactory</code>。</p>
<p>以下示例显示了如何注入<code>ConnectionFactory</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注入主（XA感知）ConnectionFactory</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConnectionFactory defaultConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注入XA感知ConnectionFactory（使用别名并注入与上面相同的内容）</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"xaJmsConnectionFactory"</span>)</span><br><span class="line"><span class="keyword">private</span> ConnectionFactory xaConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注入非XA感知的ConnectionFactory</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"nonXaJmsConnectionFactory"</span>)</span><br><span class="line"><span class="keyword">private</span> ConnectionFactory nonXaConnectionFactory;</span><br></pre></td></tr></table></figure>
<h2 id="支持替代嵌入式事务管理器"><a href="#支持替代嵌入式事务管理器" class="headerlink" title="支持替代嵌入式事务管理器"></a>支持替代嵌入式事务管理器</h2><p>该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.java" target="_blank" rel="noopener"><code>XAConnectionFactoryWrapper</code></a> 和<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java" target="_blank" rel="noopener"><code>XADataSourceWrapper</code></a>接口可用于支持替代嵌入式事务经理。接口负责包装<code>XAConnectionFactory</code>和<code>XADataSource</code>bean，并将它们作为常规<code>ConnectionFactory</code>和<code>DataSource</code>bean 公开，它们透明地注册到分布式事务中。DataSource和JMS自动配置使用JTA变体，前提是您有一个<code>JtaTransactionManager</code>bean和在您的域中注册的相应XA包装bean <code>ApplicationContext</code>。</p>
<p>该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXAConnectionFactoryWrapper.java" target="_blank" rel="noopener">BitronixXAConnectionFactoryWrapper</a> 和<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXADataSourceWrapper.java" target="_blank" rel="noopener">BitronixXADataSourceWrapper</a> 提供了如何编写XA包装很好的例子。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-JTA的分布式事务/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-Mail/">使用SpringBoot-Mail</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/mail/">mail</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Sending-Email"><a href="#Sending-Email" class="headerlink" title="Sending Email"></a>Sending Email</h1><p>Spring Framework提供了一个使用<code>JavaMailSender</code>界面发送电子邮件的简单抽象 ，Spring Boot为它提供了自动配置以及启动器模块。</p>
<blockquote>
<p>有关如何使用<code>JavaMailSender</code>的详细说明，请参阅<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#mail" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<p>如果<code>spring.mail.host</code>和相关库（由定义的 <code>spring-boot-starter-mail</code>）可用，<code>JavaMailSender</code>则创建默认值（如果不存在）。可以通过<code>spring.mail</code>命名空间中的配置项进一步自定义发送方 。有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java" target="_blank" rel="noopener"><code>MailProperties</code></a>详细信息，请参阅</p>
<p>特别是，某些默认超时值是无限的，您可能希望更改它以避免线程被无响应的邮件服务器阻塞，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.properties.mail.smtp.connectiontimeout=5000</span><br><span class="line">spring.mail.properties.mail.smtp.timeout=3000</span><br><span class="line">spring.mail.properties.mail.smtp.writetimeout=5000</span><br></pre></td></tr></table></figure>
<p>也可以<code>JavaMailSender</code>使用<code>Session</code>JNDI中的现有配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.jndi-name=mail/Session</span><br></pre></td></tr></table></figure>
<p>当<code>jndi-name</code>设置，它优先于所有其他会话相关的设置。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-Mail/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-Validation/">使用SpringBoot-Validation</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/validation/">validation</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h1><p>只要JSR-303实现（例如Hibernate验证器）在类路径上，就会自动启用Bean Validation 1.1支持的方法验证功能。这使得bean方法可以使用<code>javax.validation</code>对其参数和/或返回值的约束进行注释。具有此类带注释方法的目标类需要使用<code>@Validated</code>类型级别的注释进行注释，以便搜索其内联约束注释的方法。</p>
<p>例如，以下服务触发第一个参数的验证，确保其大小在8到10之间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Archive <span class="title">findByCodeAndAuthor</span><span class="params">(@Size(min = <span class="number">8</span>, max = <span class="number">10</span>)</span> String code,</span></span><br><span class="line"><span class="function">			Author author) </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-Validation/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-WebClient/">使用SpringBoot-WebClient</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/rest/">rest</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/webflux/">webflux</a></div></div><div class="post-content"><div class="main-content content"><h1 id="WebClient"><a href="#WebClient" class="headerlink" title="WebClient"></a>WebClient</h1><p>如果在类路径上有Spring WebFlux，则还可以选择<code>WebClient</code>用于调用远程REST服务。相比之下<code>RestTemplate</code>，这个客户端具有更多的功能感并且完全被动。您可以<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client" target="_blank" rel="noopener">在Spring Framework文档</a><code>WebClient</code>的专用 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client" target="_blank" rel="noopener">部分中</a>了解有关该内容的更多信息。</p>
<p>Spring Boot <code>WebClient.Builder</code>为您创建并预配置一个; 强烈建议将其注入组件并使用它来创建<code>WebClient</code>实例。Spring Boot正在配置该构建器以共享HTTP资源，以与服务器相同的方式反映编解码器设置（请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webflux-httpcodecs" target="_blank" rel="noopener">WebFlux HTTP编解码器自动配置</a>）等。</p>
<p>以下代码显示了一个典型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebClient.Builder webClientBuilder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.webClient = webClientBuilder.baseUrl(<span class="string">"http://example.org"</span>).build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;Details&gt; <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.webClient.get().uri(<span class="string">"/&#123;name&#125;/details"</span>, name)</span><br><span class="line">						.retrieve().bodyToMono(Details.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WebClient运行时"><a href="#WebClient运行时" class="headerlink" title="WebClient运行时"></a>WebClient运行时</h2><p>Spring Boot将自动检测<code>ClientHttpConnector</code>用于驱动的驱动程序<code>WebClient</code>，具体取决于应用程序类路径上可用的库。目前，支持Reactor Netty和Jetty RS客户端。</p>
<p>在<code>spring-boot-starter-webflux</code>启动依赖于<code>io.projectreactor.netty:reactor-netty</code> 默认情况下，这使服务器和客户端的实现。如果您选择将Jetty用作反应式服务器，则应该在Jetty Reactive HTTP客户端库上添加依赖项<code>org.eclipse.jetty:jetty-reactive-httpclient</code>。对服务器和客户端使用相同的技术具有优势，因为它将自动在客户端和服务器之间共享HTTP资源。</p>
<p>开发人员可以通过提供自定义<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>bean 来覆盖Jetty和Reactor Netty的资源配置- 这将应用于客户端和服务器。</p>
<p>如果您希望覆盖客户端的该选项，则可以定义自己的 <code>ClientHttpConnector</code>bean并完全控制客户端配置。</p>
<p>您可以<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder" target="_blank" rel="noopener"><code>WebClient</code>在Spring Framework参考文档中</a>了解有关<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder" target="_blank" rel="noopener">配置选项的</a>更多信息 。</p>
<h2 id="WebClient自定义"><a href="#WebClient自定义" class="headerlink" title="WebClient自定义"></a>WebClient自定义</h2><p><code>WebClient</code>自定义有三种主要方法，具体取决于您希望自定义应用的广泛程度。</p>
<p>要使任何自定义的范围尽可能窄，请注入自动配置 <code>WebClient.Builder</code>，然后根据需要调用其方法。<code>WebClient.Builder</code>实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有客户端中。如果要使用相同的构建器创建多个客户端，还可以考虑使用克隆构建器<code>WebClient.Builder other = builder.clone();</code>。</p>
<p>要对所有<code>WebClient.Builder</code>实例进行应用程序范围的附加自定义，您可以声明<code>WebClientCustomizer</code>bean并<code>WebClient.Builder</code>在注入点更改本地。</p>
<p>最后，您可以回退到原始API并使用<code>WebClient.create()</code>。在这种情况下，不会自动配置或<code>WebClientCustomizer</code>应用。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-WebClient/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-RestTemplate/">使用SpringBoot-RestTemplate</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/rest/">rest</a></div></div><div class="post-content"><div class="main-content content"><h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p>如果需要从应用程序调用远程REST服务，可以使用Spring Framework的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener"><code>RestTemplate</code></a>类。由于 <code>RestTemplate</code>实例在使用之前通常需要自定义，因此Spring Boot不提供任何单个自动配置的<code>RestTemplate</code>bean。但是，它会自动配置a <code>RestTemplateBuilder</code>，可用于<code>RestTemplate</code> 在需要时创建实例。自动配置<code>RestTemplateBuilder</code>可确保将敏感 <code>HttpMessageConverters</code>应用于<code>RestTemplate</code>实例。</p>
<p>以下代码显示了一个典型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Details <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"/&#123;name&#125;/details"</span>, Details.class, name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>RestTemplateBuilder</code>包括许多可用于快速配置a的有用方法<code>RestTemplate</code>。例如，要添加BASIC auth支持，您可以使用<code>builder.basicAuthentication(&quot;user&quot;, &quot;password&quot;).build()</code>。</p>
</blockquote>
<h2 id="RestTemplate自定义"><a href="#RestTemplate自定义" class="headerlink" title="RestTemplate自定义"></a>RestTemplate自定义</h2><p><code>RestTemplate</code>自定义有三种主要方法，具体取决于您希望自定义应用的广泛程度。</p>
<p>要使任何自定义的范围尽可能窄，请注入自动配置 <code>RestTemplateBuilder</code>，然后根据需要调用其方法。每个方法调用都返回一个新<code>RestTemplateBuilder</code>实例，因此自定义只会影响构建器的这种使用。</p>
<p>要进行应用程序范围的附加定制，请使用<code>RestTemplateCustomizer</code>bean。所有这些bean都自动注册自动配置<code>RestTemplateBuilder</code> ，并应用于使用它构建的任何模板。</p>
<p>以下示例显示了一个自定义程序，它为所有主机配置代理的使用，但<code>192.168.0.5</code>以下情况除外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">		HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">"proxy.example.com"</span>);</span><br><span class="line">		HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">				.setRoutePlanner(<span class="keyword">new</span> DefaultProxyRoutePlanner(proxy) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">							HttpRequest request, HttpContext context)</span></span></span><br><span class="line"><span class="function">							<span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line">						<span class="keyword">if</span> (target.getHostName().equals(<span class="string">"192.168.0.5"</span>)) &#123;</span><br><span class="line">							<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;).build();</span><br><span class="line">		restTemplate.setRequestFactory(</span><br><span class="line">				<span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，最极端（很少使用）的选项是创建自己的 <code>RestTemplateBuilder</code>bean。这样做会关闭自动配置 的<code>RestTemplateBuilder</code>并阻止使用任何<code>RestTemplateCustomizer</code>bean。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-RestTemplate/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-消息中间件/">使用SpringBoot-消息中间件</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/jms/">jms</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/amqp/">amqp</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/rabbitmq/">rabbitmq</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/kafka/">kafka</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h1><p>Spring Framework为与消息传递系统的集成提供了广泛的支持，从简化使用JMS API <code>JmsTemplate</code>到完整的基础架构，以异步接收消息。Spring AMQP为高级消息队列协议提供了类似的功能集。Spring Boot还为<code>RabbitTemplate</code>RabbitMQ 提供了自动配置选项。Spring WebSocket本身包含对STOMP消息传递的支持，Spring Boot通过启动器和少量自动配置支持它。Spring Boot也支持Apache Kafka。</p>
<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>该<code>javax.jms.ConnectionFactory</code>接口提供了一种创建<code>javax.jms.Connection</code>与JMS代理交互的标准方法 。尽管Spring需要 <code>ConnectionFactory</code>使用JMS，但您通常不需要直接使用它，而是可以依赖于更高级别的消息传递抽象。（有关详细信息，请参阅Spring Framework参考文档的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#jms" target="_blank" rel="noopener">相关部分</a>。）Spring Boot还会自动配置发送和接收消息所需的基础结构。</p>
<h3 id="ActiveMQ支持"><a href="#ActiveMQ支持" class="headerlink" title="ActiveMQ支持"></a>ActiveMQ支持</h3><p>当<a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ</a>在类路径上可用时，Spring Boot也可以配置a <code>ConnectionFactory</code>。如果代理存在，则会自动启动并配置嵌入式代理（前提是未通过配置指定代理URL）。</p>
<blockquote>
<p>如果使用<code>spring-boot-starter-activemq</code>，则提供连接或嵌入ActiveMQ实例的必要依赖项，以及与JMS集成的Spring基础结构。</p>
</blockquote>
<p>ActiveMQ配置由外部配置属性控制 <code>spring.activemq.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.broker-url=tcp://192.168.1.210:9876</span><br><span class="line">spring.activemq.user=admin</span><br><span class="line">spring.activemq.password=secret</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用合理设置<code>CachingConnectionFactory</code>包装本机<code>ConnectionFactory</code>，您可以通过以下方式控制外部配置属性 <code>spring.jms.*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.cache.session-cache-size=5</span><br></pre></td></tr></table></figure>
<p>如果您更愿意使用本机池，则可以通过向相应位置添加依赖关系 <code>org.messaginghub:pooled-jms</code>并进行相应配置来实现<code>JmsPoolConnectionFactory</code>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.pool.enabled=true</span><br><span class="line">spring.activemq.pool.max-connections=50</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java" target="_blank" rel="noopener"><code>ActiveMQProperties</code></a> 更多支持的选项，请参阅 。您还可以注册任意数量的bean，以实现<code>ActiveMQConnectionFactoryCustomizer</code>更高级的自定义。</p>
</blockquote>
<p>默认情况下，ActiveMQ会创建一个目标（如果它尚不存在），以便根据提供的名称解析目标。</p>
<h3 id="Artemis-Support"><a href="#Artemis-Support" class="headerlink" title="Artemis Support"></a>Artemis Support</h3><p>Spring Boot可以<code>ConnectionFactory</code>在检测到<a href="http://activemq.apache.org/artemis/" target="_blank" rel="noopener">Artemis</a>在类路径上可用时 自动配置。如果代理存在，则会自动启动并配置嵌入式代理（除非已明确设置mode属性）。支持的模式是<code>embedded</code>（明确表示需要嵌入式代理，如果代理在类路径上不可用则发生错误）和<code>native</code>（使用<code>netty</code> 传输协议连接到代理）。配置后者后，Spring Boot会<code>ConnectionFactory</code>使用默认设置配置 连接到本地计算机上运行的代理的连接。</p>
<blockquote>
<p>如果使用<code>spring-boot-starter-artemis</code>，则提供连接到现有Artemis实例的必要依赖项，以及与JMS集成的Spring基础结构。添加<code>org.apache.activemq:artemis-jms-server</code>到您的应用程序可让您使用嵌入模式。</p>
</blockquote>
<p>Artemis配置由外部配置属性控制 <code>spring.artemis.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.artemis.mode=native</span><br><span class="line">spring.artemis.host=192.168.1.210</span><br><span class="line">spring.artemis.port=9876</span><br><span class="line">spring.artemis.user=admin</span><br><span class="line">spring.artemis.password=secret</span><br></pre></td></tr></table></figure>
<p>嵌入代理时，您可以选择是否要启用持久性并列出应该可用的目标。这些可以指定为以逗号分隔的列表，使用默认选项创建它们，或者您可以分别为高级队列和主题配置定义类型的bean <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code>或<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>。</p>
<p>默认情况下，使用合理设置<code>CachingConnectionFactory</code>包装本机<code>ConnectionFactory</code>，您可以通过以下方式控制外部配置属性 <code>spring.jms.*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.cache.session-cache-size=5</span><br></pre></td></tr></table></figure>
<p>如果您更愿意使用本机池，则可以通过向相应位置添加依赖关系 <code>org.messaginghub:pooled-jms</code>并进行相应配置来实现<code>JmsPoolConnectionFactory</code>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.artemis.pool.enabled=true</span><br><span class="line">spring.artemis.pool.max-connections=50</span><br></pre></td></tr></table></figure>
<p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java" target="_blank" rel="noopener"><code>ArtemisProperties</code></a> 更多支持选项，请参阅</p>
<p>不涉及JNDI查找，并使用<code>name</code>Artemis配置中的属性或通过配置提供的名称来解析目标名称。</p>
<h3 id="使用JNDI-ConnectionFactory"><a href="#使用JNDI-ConnectionFactory" class="headerlink" title="使用JNDI ConnectionFactory"></a>使用JNDI ConnectionFactory</h3><p>如果您在应用程序服务器中运行应用程序，Spring Boot会尝试<code>ConnectionFactory</code>使用JNDI 查找JMS 。默认情况下，将检查<code>java:/JmsXA</code>和<code>java:/XAConnectionFactory</code>位置。<code>spring.jms.jndi-name</code> 如果需要指定备用位置，可以使用该属性，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.jndi-name=java:/MyConnectionFactory</span><br></pre></td></tr></table></figure>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring <code>JmsTemplate</code>是自动配置的，你可以直接将它自动装入自己的bean中，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JmsTemplate jmsTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jmsTemplate = jmsTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html" target="_blank" rel="noopener"><code>JmsMessagingTemplate</code></a>可以以类似的方式注射。如果定义了一个<code>DestinationResolver</code>或一个<code>MessageConverter</code>bean，它将自动关联到自动配置<code>JmsTemplate</code>。</p>
</blockquote>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>当存在JMS基础结构时，可以使用任何bean来注释<code>@JmsListener</code>以创建侦听器端点。如果<code>JmsListenerContainerFactory</code>未定义，则自动配置默认值。如果定义了一个<code>DestinationResolver</code>或一个 <code>MessageConverter</code>bean，它将自动关联到默认工厂。</p>
<p>默认情况下，默认工厂是事务性的。如果您在<code>JtaTransactionManager</code>存在a的基础结构中运行 ，则默认情况下它与侦听器容器相关联。如果不是，<code>sessionTransacted</code>则启用该标志。在后一种情况下，您可以通过添加<code>@Transactional</code>侦听器方法（或其委托）将本地数据存储事务与传入消息的处理相关联。这确保了在本地事务完成后确认传入消息。这还包括发送已在同一JMS会话上执行的响应消息。</p>
<p>以下组件在<code>someQueue</code>目标上创建侦听器端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@JmsListener</span>(destination = <span class="string">"someQueue"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关 更多详细信息，请参阅<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/jms/annotation/EnableJms.html" target="_blank" rel="noopener">Javadoc<code>@EnableJms</code></a>。</p>
</blockquote>
<p>如果您需要创建更多<code>JmsListenerContainerFactory</code>实例，或者如果要覆盖默认实例，则Spring Boot提供了一个<code>DefaultJmsListenerContainerFactoryConfigurer</code>可用于初始化a <code>DefaultJmsListenerContainerFactory</code>的设置，其设置与自动配置的设置相同。</p>
<p>例如，以下示例公开了另一个使用特定工厂的工厂 <code>MessageConverter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">		DefaultJmsListenerContainerFactory factory =</span><br><span class="line">				<span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">		configurer.configure(factory, connectionFactory());</span><br><span class="line">		factory.setMessageConverter(myMessageConverter());</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后您可以在任何<code>@JmsListener</code>注释方法中使用工厂，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@JmsListener</span>(destination = <span class="string">"someQueue"</span>, containerFactory=<span class="string">"myFactory"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>高级消息队列协议（AMQP）是面向消息的中间件的平台中立的线级协议。Spring AMQP项目将核心Spring概念应用于基于AMQP的消息传递解决方案的开发。Spring Boot提供了几种通过RabbitMQ使用AMQP的便利，包括<code>spring-boot-starter-amqp</code> “Starter”。</p>
<h3 id="RabbitMQ支持"><a href="#RabbitMQ支持" class="headerlink" title="RabbitMQ支持"></a>RabbitMQ支持</h3><p><a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>是一个基于AMQP协议的轻量级，可靠，可扩展且可移植的消息代理。Spring用于<code>RabbitMQ</code>通过AMQP协议进行通信。</p>
<p>RabbitMQ配置由外部配置属性控制 <code>spring.rabbitmq.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=secret</span><br></pre></td></tr></table></figure>
<p>如果<code>ConnectionNameStrategy</code>上下文中存在bean，则它将自动用于命名由自动配置创建的连接<code>ConnectionFactory</code>。有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java" target="_blank" rel="noopener"><code>RabbitProperties</code></a>更多支持的选项，请参阅 。</p>
<blockquote>
<p>有关详细信息<a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/" target="_blank" rel="noopener">，</a>请参阅 <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/" target="_blank" rel="noopener">了解RabbitQQ使用的协议AMQP</a>。</p>
</blockquote>
<h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring的<code>AmqpTemplate</code>和<code>AmqpAdmin</code>被自动配置，您可以直接自动装配它们变成自己的豆类，如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AmqpAdmin amqpAdmin;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.amqpAdmin = amqpAdmin;</span><br><span class="line">		<span class="keyword">this</span>.amqpTemplate = amqpTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html" target="_blank" rel="noopener"><code>RabbitMessagingTemplate</code></a> 可以以类似的方式注射。如果<code>MessageConverter</code>定义了bean，它将自动关联到自动配置<code>AmqpTemplate</code>。</p>
</blockquote>
<p>如有必要，任何<code>org.springframework.amqp.core.Queue</code>定义为bean的都会自动用于在RabbitMQ实例上声明相应的队列。</p>
<p>要重试操作，可以启用重试<code>AmqpTemplate</code>（例如，在代理连接丢失的情况下）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.template.retry.enabled=true</span><br><span class="line">spring.rabbitmq.template.retry.initial-interval=2s</span><br></pre></td></tr></table></figure>
<p>默认情况下禁用重试。您还可以<code>RetryTemplate</code> 通过声明<code>RabbitRetryTemplateCustomizer</code>bean来以编程方式自定义。</p>
<h3 id="接收消息-1"><a href="#接收消息-1" class="headerlink" title="接收消息"></a>接收消息</h3><p>当Rabbit基础结构存在时，可以使用任何bean来注释 <code>@RabbitListener</code>以创建侦听器端点。如果<code>RabbitListenerContainerFactory</code> 未定义，<code>SimpleRabbitListenerContainerFactory</code>则会自动配置默认值，您可以使用该<code>spring.rabbitmq.listener.type</code>属性切换到直接容器 。如果 定义了a <code>MessageConverter</code>或<code>MessageRecoverer</code>bean，它将自动与默认工厂关联。</p>
<p>以下示例组件在<code>someQueue</code>队列上创建侦听器端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RabbitListener</span>(queues = <span class="string">"someQueue"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html" target="_blank" rel="noopener">Javadoc <code>@EnableRabbit</code></a>。</p>
</blockquote>
<p>如果您需要创建更多<code>RabbitListenerContainerFactory</code>实例，或者如果要覆盖默认实例，Spring Boot提供了一个<code>SimpleRabbitListenerContainerFactoryConfigurer</code>和一个 <code>DirectRabbitListenerContainerFactoryConfigurer</code>可用于初始化a<code>SimpleRabbitListenerContainerFactory</code>和a <code>DirectRabbitListenerContainerFactory</code>的设置，其设置与自动配置使用的工厂相同。</p>
<blockquote>
<p>您选择的容器类型无关紧要。这两个bean通过自动配置公开。</p>
</blockquote>
<p>例如，以下配置类公开了另一个使用特定的工厂<code>MessageConverter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">		SimpleRabbitListenerContainerFactory factory =</span><br><span class="line">				<span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">		configurer.configure(factory, connectionFactory);</span><br><span class="line">		factory.setMessageConverter(myMessageConverter());</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后您可以在任何<code>@RabbitListener</code>注释方法中使用工厂，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RabbitListener</span>(queues = <span class="string">"someQueue"</span>, containerFactory=<span class="string">"myFactory"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以启用重试来处理侦听器抛出异常的情况。默认<code>RejectAndDontRequeueRecoverer</code>使用，但您可以定义<code>MessageRecoverer</code> 自己的。当重试耗尽时，如果代理配置了这样做，则拒绝该消息并将其丢弃或路由到死信交换。默认情况下，禁用重试。您还可以<code>RetryTemplate</code>通过声明<code>RabbitRetryTemplateCustomizer</code>bean来以编程方式自定义。</p>
<blockquote>
<p><strong>重要:</strong></p>
<p>默认情况下，如果禁用重试并且侦听器抛出异常，则会无限期地重试传递。您可以通过两种方式修改此行为：将<code>defaultRequeueRejected</code>属性设置为<code>false</code>以便尝试零重新传递，或者抛出一个<code>AmqpRejectAndDontRequeueException</code>信号来表示应该拒绝该消息。后者是启用重试并且达到最大传递尝试次数时使用的机制。</p>
</blockquote>
<h2 id="Apache-Kafka支持"><a href="#Apache-Kafka支持" class="headerlink" title="Apache Kafka支持"></a>Apache Kafka支持</h2><p>通过提供<code>spring-kafka</code>项目的自动配置来支持<a href="https://kafka.apache.org/" target="_blank" rel="noopener">Apache Kafka</a>。</p>
<p>Kafka配置由外部配置属性控制 <code>spring.kafka.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.bootstrap-servers=localhost:9092</span><br><span class="line">spring.kafka.consumer.group-id=myGroup</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要在启动时创建主题，请添加类型的bean <code>NewTopic</code>。如果主题已存在，则忽略该bean。</p>
</blockquote>
<p>有关更多支持选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java" target="_blank" rel="noopener"><code>KafkaProperties</code></a> </p>
<h3 id="发送消息-2"><a href="#发送消息-2" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring <code>KafkaTemplate</code>是自动配置的，您可以直接在自己的bean中自动装配它，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(KafkaTemplate kafkaTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果<code>spring.kafka.producer.transaction-id-prefix</code>定义了属性， <code>KafkaTransactionManager</code>则会自动配置a。此外，如果<code>RecordMessageConverter</code> 定义了bean，它将自动与自动配置相关联<code>KafkaTemplate</code>。</p>
</blockquote>
<h3 id="接收消息-2"><a href="#接收消息-2" class="headerlink" title="接收消息"></a>接收消息</h3><p>当存在Apache Kafka基础结构时，可以使用任何bean来注释 <code>@KafkaListener</code>以创建侦听器端点。如果<code>KafkaListenerContainerFactory</code>未定义，则使用定义的键自动配置默认值 <code>spring.kafka.listener.*</code>。</p>
<p>以下组件在<code>someTopic</code>主题上创建侦听器端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@KafkaListener</span>(topics = <span class="string">"someTopic"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>KafkaTransactionManager</code>定义了bean，它将自动关联到容器工厂。类似地，如果一个<code>RecordMessageConverter</code>，<code>ErrorHandler</code>或<code>AfterRollbackProcessor</code>豆被定义，它被自动关联为出厂默认。</p>
<blockquote>
<p><code>ChainedKafkaTransactionManager</code>必须标记自定义，<code>@Primary</code>因为它通常引用自动配置的<code>KafkaTransactionManager</code>bean。</p>
</blockquote>
<h3 id="Kafka-Streams"><a href="#Kafka-Streams" class="headerlink" title="Kafka Streams"></a>Kafka Streams</h3><p>Spring for Apache Kafka提供了一个工厂bean来创建一个<code>StreamsBuilder</code>对象并管理其流的生命周期。Spring Boot会自动配置所需的<code>KafkaStreamsConfiguration</code>bean，只要<code>kafka-streams</code>在类路径上，并通过<code>@EnableKafkaStreams</code>注释启用Kafka Streams 。</p>
<p>启用Kafka Streams意味着必须设置应用程序ID和引导服务器。前者可以使用配置<code>spring.kafka.streams.application-id</code>，<code>spring.application.name</code>如果没有设置则默认为默认 值。后者可以全局设置或专门为流而重写。</p>
<p>使用专用属性可以使用其他几个属性; 可以使用<code>spring.kafka.streams.properties</code>命名空间设置其他任意Kafka属性。有关更多信息<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-kafka-extra-props" target="_blank" rel="noopener">，</a>另请参见<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-kafka-extra-props" target="_blank" rel="noopener">第34.3.4节“其他Kafka属性”</a>。</p>
<p>要使用工厂bean，只需连接<code>StreamsBuilder</code>到您的bean，<code>@Bean</code>如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableKafkaStreams</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaStreamsExampleConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> KStream&lt;Integer, String&gt; <span class="title">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span> </span>&#123;</span><br><span class="line">		KStream&lt;Integer, String&gt; stream = streamsBuilder.stream(<span class="string">"ks1In"</span>);</span><br><span class="line">		stream.map((k, v) -&gt; <span class="keyword">new</span> KeyValue&lt;&gt;(k, v.toUpperCase())).to(<span class="string">"ks1Out"</span>,</span><br><span class="line">				Produced.with(Serdes.Integer(), <span class="keyword">new</span> JsonSerde&lt;&gt;()));</span><br><span class="line">		<span class="keyword">return</span> stream;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，由其<code>StreamBuilder</code>创建的对象管理的流将自动启动。您可以使用该<code>spring.kafka.streams.auto-startup</code>属性自定义此行为 。</p>
<h3 id="附加Kafka属性"><a href="#附加Kafka属性" class="headerlink" title="附加Kafka属性"></a>附加Kafka属性</h3><p>自动配置支持的属性显示在 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">附录A，<em>常见应用程序属性中</em></a>。请注意，在大多数情况下，这些属性（连字符或camelCase）直接映射到Apache Kafka点状属性。有关详细信息，请参阅Apache Kafka文档。</p>
<p>这些属性中的前几个适用于所有组件（生产者，使用者，管理员和流），但如果您希望使用不同的值，则可以在组件级别指定。Apache Kafka指定重要性为HIGH，MEDIUM或LOW的属性。Spring Boot自动配置支持所有HIGH重要性属性，一些选定的MEDIUM和LOW属性，以及任何没有默认值的属性。</p>
<p>只有Kafka支持的属性的一部分可以直接通过 <code>KafkaProperties</code>该类获得。如果您希望使用不直接支持的其他属性配置生产者或使用者，请使用以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.properties.prop.one=first</span><br><span class="line">spring.kafka.admin.properties.prop.two=second</span><br><span class="line">spring.kafka.consumer.properties.prop.three=third</span><br><span class="line">spring.kafka.producer.properties.prop.four=fourth</span><br><span class="line">spring.kafka.streams.properties.prop.five=fifth</span><br></pre></td></tr></table></figure>
<p>这将常见的<code>prop.one</code>Kafka属性设置为<code>first</code>（适用于生产者，使用者和管理员），<code>prop.two</code>admin属性<code>second</code>，<code>prop.three</code> 使用者属性<code>third</code>，<code>prop.four</code>生产者属性<code>fourth</code>和 <code>prop.five</code>streams属性<code>fifth</code>。</p>
<p>您还可以<code>JsonDeserializer</code>按如下方式配置Spring Kafka ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer</span><br><span class="line">spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice</span><br><span class="line">spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme</span><br></pre></td></tr></table></figure>
<p>同样，您可以禁用<code>JsonSerializer</code>在标头中发送类型信息的默认行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer</span><br><span class="line">spring.kafka.producer.properties.spring.json.add.type.headers=false</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>重要</strong>：</p>
<p>以这种方式设置的属性将覆盖Spring Boot明确支持的任何配置项。</p>
</blockquote>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-消息中间件/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-cache/">使用SpringBoot-cache</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/cache/">cache</a></div></div><div class="post-content"><div class="main-content content"><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>Spring Framework支持透明地向应用程序添加缓存。从本质上讲，抽象将缓存应用于方法，从而根据缓存中可用的信息减少执行次数。缓存逻辑是透明应用的，不会对调用者造成任何干扰。只要通过<code>@EnableCaching</code> 注释启用了缓存支持，Spring Boot就会自动配置缓存基础结构。</p>
<blockquote>
<p><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache" target="_blank" rel="noopener">有关</a>更多详细信息，请查看Spring Framework参考的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache" target="_blank" rel="noopener">相关部分</a>。</p>
</blockquote>
<p>简而言之，将缓存添加到服务操作就像在其方法中添加相关注释一样简单，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Cacheable</span>(<span class="string">"piDecimals"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computePiDecimal</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例演示了如何在可能代价高昂的操作上使用缓存。在调用之前<code>computePiDecimal</code>，抽象会在<code>piDecimals</code>缓存中查找与<code>i</code>参数匹配的条目。如果找到条目，则缓存中的内容会立即返回给调用者，并且不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。</p>
<blockquote>
<p>您还可以<code>@CacheResult</code>透明地使用标准JSR-107（JCache）注释（例如 ）。但是，我们强烈建议您不要混淆和匹配Spring Cache和JCache注释。</p>
</blockquote>
<p>如果您不添加任何特定的缓存库，Spring Boot会自动配置一个在内存中使用并发映射的 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-simple" target="_blank" rel="noopener">简单提供程序</a>。当需要缓存时（例如<code>piDecimals</code>在前面的示例中），此提供程序会为您创建缓存。简单的提供程序并不是真正推荐用于生产用途，但它非常适合入门并确保您了解这些功能。当您决定使用缓存提供程序时，请务必阅读其文档以了解如何配置应用程序使用的缓存。几乎所有提供程序都要求您显式配置在应用程序中使用的每个缓存。有些提供了一种自定义<code>spring.cache.cache-names</code>属性定义的默认缓存的方法。</p>
<blockquote>
<p>还可以透明地 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache-annotations-put" target="_blank" rel="noopener">更新</a>或 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/integration.html#cache-annotations-evict" target="_blank" rel="noopener">逐出</a>缓存中的数据。</p>
</blockquote>
<h2 id="支持的缓存提供程序"><a href="#支持的缓存提供程序" class="headerlink" title="支持的缓存提供程序"></a>支持的缓存提供程序</h2><p>缓存抽象不提供实际存储，而是依赖于<code>org.springframework.cache.Cache</code>和 <code>org.springframework.cache.CacheManager</code>接口实现的抽象。</p>
<p>如果尚未定义类型的bean <code>CacheManager</code>或<code>CacheResolver</code>命名 的bean <code>cacheResolver</code>（请参阅参考资料 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html" target="_blank" rel="noopener"><code>CachingConfigurer</code></a>），Spring Boot会尝试检测以下提供程序（按指示的顺序）：</p>
<ol>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-generic" target="_blank" rel="noopener">Generic</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-jcache" target="_blank" rel="noopener">JCache（JSR-107）</a>（EhCache 3，Hazelcast，Infinispan等）</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-ehcache2" target="_blank" rel="noopener">EhCache 2.x</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-hazelcast" target="_blank" rel="noopener">Hazelcast</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-infinispan" target="_blank" rel="noopener">Infinispan</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-couchbase" target="_blank" rel="noopener">Couchbase</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-redis" target="_blank" rel="noopener">Redis</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-caffeine" target="_blank" rel="noopener">Caffeine</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-simple" target="_blank" rel="noopener">Simple</a></li>
</ol>
<blockquote>
<p>也可以通过设置属性来<em>强制</em>特定的缓存提供程序 <code>spring.cache.type</code>。如果您需要在某些环境（例如测试）中<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-caching-provider-none" target="_blank" rel="noopener">完全禁用缓存，</a>请使用此属性 。</p>
</blockquote>
<blockquote>
<p>使用<code>spring-boot-starter-cache</code>“Starter”快速添加基本缓存依赖项。首发引入<code>spring-context-support</code>。如果手动添加依赖项，则必须包括<code>spring-context-support</code>才能使用JCache，EhCache 2.x或Guava支持。</p>
</blockquote>
<p>如果<code>CacheManager</code>由Spring Boot自动配置，则可以通过公开实现该<code>CacheManagerCustomizer</code>接口的bean完全初始化之前进一步调整其配置 。以下示例设置一个标志，表示应将null值传递给底层映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConcurrentMapCacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">			cacheManager.setAllowNullValues(<span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在前面的示例中，<code>ConcurrentMapCacheManager</code>预期会自动配置。如果不是这种情况（您提供了自己的配置或自动配置了不同的缓存提供程序），则根本不会调用自定义程序。您可以拥有任意数量的自定义程序，也可以使用<code>@Order</code>或订购它们<code>Ordered</code>。</p>
</blockquote>
<h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><p>如果上下文定义<em>至少</em>一个 <code>org.springframework.cache.Cache</code>bean，则使用通用高速缓存。将<code>CacheManager</code>创建包装该类型的所有bean。</p>
<h3 id="JCache（JSR-107）"><a href="#JCache（JSR-107）" class="headerlink" title="JCache（JSR-107）"></a>JCache（JSR-107）</h3><p><a href="https://jcp.org/en/jsr/detail?id=107" target="_blank" rel="noopener">JCache</a>通过<code>javax.cache.spi.CachingProvider</code>类路径上的存在（即类路径上存在符合JSR-107的缓存库）进行引导 ，<code>JCacheCacheManager</code>并由<code>spring-boot-starter-cache</code>“Starter”提供。可以使用各种兼容库，Spring Boot为Ehcache 3，Hazelcast和Infinispan提供依赖管理。还可以添加任何其他兼容库。</p>
<p>可能会出现多个提供程序，在这种情况下，必须明确指定提供程序。即使JSR-107标准没有强制执行定义配置文件位置的标准化方法，Spring Boot也会尽力满足设置缓存的实现细节，如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   #仅在存在多个提供程序时才需要</span><br><span class="line">spring.cache.jcache.provider=com.acme.MyCachingProvider</span><br><span class="line">spring.cache.jcache.config=classpath:acme.xml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当缓存库同时提供本机实现和JSR-107支持时，Spring Boot更喜欢JSR-107支持，因此如果切换到不同的JSR-107实现，则可以使用相同的功能。</p>
</blockquote>
<blockquote>
<p>Spring Boot <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">对Hazelcast</a>有<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">一般支持</a>。如果单个<code>HazelcastInstance</code>可用，则<code>CacheManager</code>除非<code>spring.cache.jcache.config</code>指定了属性，否则它也会自动重复使用 。</p>
</blockquote>
<p>有两种方法可以自定义底层<code>javax.cache.cacheManager</code>：</p>
<ul>
<li>可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存。如果定义了自定义<code>javax.cache.configuration.Configuration</code>bean，则会使用它来自定义它们。</li>
<li><code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code>使用<code>CacheManager</code>for完全自定义的引用调用bean 。</li>
</ul>
<blockquote>
<p>如果<code>javax.cache.CacheManager</code>定义了标准bean，它将自动包装在<code>org.springframework.cache.CacheManager</code>抽象所期望的实现中。没有进一步的自定义。</p>
</blockquote>
<h3 id="EhCache-2-x"><a href="#EhCache-2-x" class="headerlink" title="EhCache 2.x"></a>EhCache 2.x</h3><p>如果<code>ehcache.xml</code>可以在类路径的根目录中找到名为的文件，则使用<a href="http://www.ehcache.org/" target="_blank" rel="noopener">EhCache 2.x. </a>如果找到EhCache 2.x，则使用“Starter” <code>EhCacheCacheManager</code>提供的<code>spring-boot-starter-cache</code>引导缓存管理器。还可以提供备用配置文件，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.ehcache.config=classpath:config/another-config.xml</span><br></pre></td></tr></table></figure>
<h3 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h3><p>Spring Boot <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">对Hazelcast</a>有<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-hazelcast" target="_blank" rel="noopener">一般支持</a>。如果a <code>HazelcastInstance</code>已自动配置，则会自动包装在a中 <code>CacheManager</code>。</p>
<h3 id="Infinispan"><a href="#Infinispan" class="headerlink" title="Infinispan"></a>Infinispan</h3><p><a href="http://infinispan.org/" target="_blank" rel="noopener">Infinispan</a>没有默认配置文件位置，因此必须明确指定。否则，使用默认引导程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.infinispan.config=infinispan.xml</span><br></pre></td></tr></table></figure>
<p>可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存。如果定义了自定义<code>ConfigurationBuilder</code>bean，则它用于自定义缓存。</p>
<blockquote>
<p>Infinispan在Spring Boot中的支持仅限于嵌入式模式，非常基础。如果你想要更多选项，你应该使用官方的Infinispan Spring Boot启动器。有关更多详细信息，请参阅 <a href="https://github.com/infinispan/infinispan-spring-boot" target="_blank" rel="noopener">Infinispan的文档</a>。</p>
</blockquote>
<h3 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h3><p>如果<a href="https://www.couchbase.com/" target="_blank" rel="noopener">Couchbase</a> Java客户端和<code>couchbase-spring-cache</code> 实现可用且<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-couchbase" target="_blank" rel="noopener">配置</a>了Couchbase ， <code>CouchbaseCacheManager</code>则会自动配置a。也可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存。这些缓存在<code>Bucket</code>自动配置的情况下运行。您可以<em>还</em>创建另一个附加缓存中<code>Bucket</code>，通过使用定制。假设在“main” 和one（）缓存上需要两个缓存（<code>cache1</code>和 <code>cache2</code>），<code>Bucket</code>并且<code>cache3</code>“另一个”上的自定义时间为2秒<code>Bucket</code>。您可以通过配置创建前两个缓存，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br></pre></td></tr></table></figure>
<p>然后，您可以定义一个<code>@Configuration</code>类来配置额外<code>Bucket</code>和 <code>cache3</code>缓存，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouchbaseCacheConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Cluster cluster;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CouchbaseCacheConfiguration</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Bucket <span class="title">anotherBucket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.cluster.openBucket(<span class="string">"another"</span>, <span class="string">"secret"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;CouchbaseCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c -&gt; &#123;</span><br><span class="line">			c.prepareCache(<span class="string">"cache3"</span>, CacheBuilder.newInstance(anotherBucket())</span><br><span class="line">					.withExpiration(<span class="number">2</span>));</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例配置重用<code>Cluster</code>通过自动配置创建的配置。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>如果<a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>可用且已配置，<code>RedisCacheManager</code>则会自动配置。可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存， 并可以使用<code>spring.cache.redis.*</code>属性配置缓存默认值 。例如，以下配置创建 <code>cache1</code>并<code>cache2</code>缓存10分钟的<em>生存</em>时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br><span class="line">spring.cache.redis.time-to-live=600000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，会添加一个键前缀，这样，如果两个单独的缓存使用相同的键，则Redis没有重叠键，也不能返回无效值。如果您创建自己的设置，我们强烈建议您启用此设置<code>RedisCacheManager</code>。</p>
</blockquote>
<blockquote>
<p>您可以通过添加<code>RedisCacheConfiguration</code> <code>@Bean</code>自己的配置来完全控制配置。如果您正在寻找自定义序列化策略，这可能很有用。</p>
</blockquote>
<h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><p><a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">Caffeine</a>是Java 8重写的Guava缓存，取代了对Guava的支持。如果存在Caffeine，则自动配置一个 <code>CaffeineCacheManager</code>（由<code>spring-boot-starter-cache</code>启动器提供）。可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建缓存，并且可以通过以下之一（按指示的顺序）自定义缓存：</p>
<ol>
<li>由…定义的缓存规范 <code>spring.cache.caffeine.spec</code></li>
<li><code>com.github.benmanes.caffeine.cache.CaffeineSpec</code>定义了一个bean</li>
<li><code>com.github.benmanes.caffeine.cache.Caffeine</code>定义了一个bean</li>
</ol>
<p>例如，以下配置创建<code>cache1</code>和<code>cache2</code>缓存，最大大小为500，<em>生存时间为</em> 10分钟</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br><span class="line">spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s</span><br></pre></td></tr></table></figure>
<p>如果<code>com.github.benmanes.caffeine.cache.CacheLoader</code>定义了bean，它将自动关联到<code>CaffeineCacheManager</code>。由于<code>CacheLoader</code>它将与缓存管理器管理的<em>所有</em>缓存相关联，因此必须将其定义为 <code>CacheLoader&lt;Object, Object&gt;</code>。自动配置忽略任何其他泛型类型。</p>
<h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>如果找不到其他提供程序，<code>ConcurrentHashMap</code>则配置使用一个作为缓存存储的简单实现 。如果应用程序中不存在缓存库，则这是默认值。默认情况下，会根据需要创建缓存，但您可以通过设置<code>cache-names</code>属性来限制可用缓存列表。例如，如果只需要<code>cache1</code>和<code>cache2</code>缓存，请<code>cache-names</code>按如下方式设置属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.cache-names=cache1,cache2</span><br></pre></td></tr></table></figure>
<p>如果这样做并且您的应用程序使用未列出的缓存，则在需要缓存时它会在运行时失败，但在启动时则不会。这类似于“真实”缓存提供程序在使用未声明的缓存时的行为方式。</p>
<h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>如果<code>@EnableCaching</code>配置中存在，则还需要合适的缓存配置。如果需要在某些环境中完全禁用缓存，请强制缓存类型<code>none</code>使用no-op实现，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cache.type=none</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-cache/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-NoSQL数据库/">使用SpringBoot-NoSQL数据库</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/database/">database</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/nosql/">nosql</a></div></div><div class="post-content"><div class="main-content content"><h1 id="NoSQL-Technologies"><a href="#NoSQL-Technologies" class="headerlink" title="NoSQL Technologies"></a>NoSQL Technologies</h1><p>Spring Data提供了其他项目，可帮助您访问各种NoSQL技术，包括： <a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">MongoDB</a>， <a href="https://projects.spring.io/spring-data-neo4j/" target="_blank" rel="noopener">Neo4J</a>， <a href="https://github.com/spring-projects/spring-data-elasticsearch/" target="_blank" rel="noopener">Elasticsearch</a>， <a href="https://projects.spring.io/spring-data-solr/" target="_blank" rel="noopener">Solr</a>， <a href="https://projects.spring.io/spring-data-redis/" target="_blank" rel="noopener">Redis</a>， <a href="https://projects.spring.io/spring-data-gemfire/" target="_blank" rel="noopener">Gemfire</a>， <a href="https://projects.spring.io/spring-data-cassandra/" target="_blank" rel="noopener">Cassandra</a>， <a href="https://projects.spring.io/spring-data-couchbase/" target="_blank" rel="noopener">Couchbase</a>和<a href="https://projects.spring.io/spring-data-ldap/" target="_blank" rel="noopener">LDAP</a>。Spring Boot为Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase和LDAP提供自动配置。您可以使用其他项目，但必须自己配置它们。请参阅<a href="https://projects.spring.io/spring-data" target="_blank" rel="noopener">projects.spring.io/spring-data</a>上的相应参考文档 。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a href="http://redis.io/" target="_blank" rel="noopener">Redis</a>是一个缓存，消息代理和功能丰富的键值存储。Spring Boot为<a href="https://github.com/lettuce-io/lettuce-core/" target="_blank" rel="noopener">Lettuce</a>和 <a href="https://github.com/xetorthio/jedis/" target="_blank" rel="noopener">Jedis</a>客户端库提供了基本的自动配置， 并为<a href="https://github.com/spring-projects/spring-data-redis" target="_blank" rel="noopener">Spring Data Redis</a>提供了它们之外的抽象。</p>
<p>有一个<code>spring-boot-starter-data-redis</code>“Starter”用于以方便的方式收集依赖项。默认情况下，它使用 <a href="https://github.com/lettuce-io/lettuce-core/" target="_blank" rel="noopener">Lettuce</a>。该启动器处理传统和反应应用程序。</p>
<blockquote>
<p>我们还提供一个<code>spring-boot-starter-data-redis-reactive</code>启动器，以便与其他具有反应支持的商店保持一致。</p>
</blockquote>
<h3 id="连接到Redis"><a href="#连接到Redis" class="headerlink" title="连接到Redis"></a>连接到Redis</h3><p>你可以注入的自动配置<code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code>或香草<code>RedisTemplate</code>，就像任何其他的Spring Bean实例。默认情况下，实例尝试连接到Redis服务器<code>localhost:6379</code>。以下清单显示了这样一个bean的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您还可以注册任意数量的bean，以实现 <code>LettuceClientConfigurationBuilderCustomizer</code>更高级的自定义。如果您使用Jedis，<code>JedisClientConfigurationBuilderCustomizer</code>也可以使用。</p>
</blockquote>
<p>如果您添加自己<code>@Bean</code>的任何自动配置类型，它将替换默认值（除非在<code>RedisTemplate</code>排除基于bean名称时 <code>redisTemplate</code>，而不是其类型）。默认情况下，如果<code>commons-pool2</code>在类路径上，则会获得池化连接工厂。</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p><a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB</a>是一个开源的NoSQL文档数据库，它使用类似JSON的模式而不是传统的基于表的关系数据。Spring Boot提供了一些使用MongoDB的便利，包括<code>spring-boot-starter-data-mongodb</code>和<code>spring-boot-starter-data-mongodb-reactive</code> 启动器。</p>
<h3 id="连接到MongoDB数据库"><a href="#连接到MongoDB数据库" class="headerlink" title="连接到MongoDB数据库"></a>连接到MongoDB数据库</h3><p>要访问Mongo数据库，可以注入自动配置 <code>org.springframework.data.mongodb.MongoDbFactory</code>。默认情况下，实例尝试连接到MongoDB服务器<code>mongodb://localhost/test</code>。以下示例显示如何连接到MongoDB数据库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.MongoDbFactory;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.DB;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MongoDbFactory mongo;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoDbFactory mongo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mongo = mongo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		DB db = mongo.getDb();</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以设置该<code>spring.data.mongodb.uri</code>属性以更改URL并配置其他设置，例如<em>副本集</em>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</span><br></pre></td></tr></table></figure>
<p>或者，只要您使用Mongo 2.x，就可以指定<code>host</code>/ <code>port</code>。例如，您可以在以下内容中声明以下设置<code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.host=mongoserver</span><br><span class="line">spring.data.mongodb.port=27017</span><br></pre></td></tr></table></figure>
<p>如果您已经定义了自己的<code>MongoClient</code>，它将用于自动配置合适的 <code>MongoDbFactory</code>。这两个<code>com.mongodb.MongoClient</code>和<code>com.mongodb.client.MongoClient</code> 支持。</p>
<blockquote>
<p>如果使用蒙戈3.0 Java驱动程序，<code>spring.data.mongodb.host</code>并且 <code>spring.data.mongodb.port</code>不支持。在这种情况下，<code>spring.data.mongodb.uri</code> 应该用于提供所有配置。</p>
</blockquote>
<blockquote>
<p>如果<code>spring.data.mongodb.port</code>未指定，<code>27017</code>则使用默认值。您可以从前面显示的示例中删除此行。</p>
</blockquote>
<blockquote>
<p>如果您不使用Spring Data Mongo，则可以注入<code>com.mongodb.MongoClient</code>bean而不是使用<code>MongoDbFactory</code>。如果要完全控制建立MongoDB连接，还可以声明自己的 bean <code>MongoDbFactory</code>或<code>MongoClient</code>bean。</p>
</blockquote>
<blockquote>
<p>如果您使用的是反应式驱动程序，则SSL需要Netty。如果Netty可用并且尚未自定义要使用的工厂，则自动配置会自动配置此工厂。</p>
</blockquote>
<h3 id="MongoTemplate"><a href="#MongoTemplate" class="headerlink" title="MongoTemplate"></a>MongoTemplate</h3><p><a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">Spring Data MongoDB</a>提供了一个<a href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoTemplate.html" target="_blank" rel="noopener"><code>MongoTemplate</code></a>与Spring的设计非常相似的 类<code>JdbcTemplate</code>。与此同时<code>JdbcTemplate</code>，Spring Boot会自动为您配置一个bean来注入模板，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoTemplate mongoTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mongoTemplate = mongoTemplate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关完整的详细信息，请参阅 <a href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoOperations.html" target="_blank" rel="noopener"><code>MongoOperations</code> Javadoc</a>。</p>
<h3 id="Spring-Data-MongoDB存储库"><a href="#Spring-Data-MongoDB存储库" class="headerlink" title="Spring Data MongoDB存储库"></a>Spring Data MongoDB存储库</h3><p>Spring Data包括MongoDB的存储库支持。与前面讨论的JPA存储库一样，基本原则是基于方法名称自动构造查询。</p>
<p>事实上，Spring Data JPA和Spring Data MongoDB共享相同的通用基础架构。您可以从之前获取JPA示例，并假设它<code>City</code>现在是Mongo数据类而不是JPA <code>@Entity</code>，它的工作方式相同，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您可以使用<code>@EntityScan</code>注释自定义文档扫描位置。</p>
</blockquote>
<blockquote>
<p>有关Spring Data MongoDB的完整详细信息，包括其丰富的对象映射技术，请参阅其<a href="https://projects.spring.io/spring-data-mongodb/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h3 id="嵌入式Mongo"><a href="#嵌入式Mongo" class="headerlink" title="嵌入式Mongo"></a>嵌入式Mongo</h3><p>Spring Boot为<a href="https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo" target="_blank" rel="noopener">Embedded Mongo</a>提供自动配置 。要在Spring Boot应用程序中使用它，请添加依赖项 <code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code>。</p>
<p>可以通过设置<code>spring.data.mongodb.port</code> 属性来配置Mongo侦听的端口。要使用随机分配的空闲端口，请使用值0. <code>MongoClient</code> 创建者<code>MongoAutoConfiguration</code>自动配置为使用随机分配的端口。</p>
<blockquote>
<p>如果未配置自定义端口，则默认情况下，嵌入式支持使用随机端口（而不是27017）。</p>
</blockquote>
<p>如果类路径上有SLF4J，则Mongo生成的输出会自动路由到名为的记录器<code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code>。</p>
<p>您可以声明自己的bean <code>IMongodConfig</code>和<code>IRuntimeConfig</code>bean来控制Mongo实例的配置和日志记录路由。</p>
<h2 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h2><p><a href="http://neo4j.com/" target="_blank" rel="noopener">Neo4j</a>是一个开源的NoSQL图形数据库，它使用由一级关系连接的节点的丰富数据模型，与传统的RDBMS方法相比，它更适合于连接的大数据。Spring Boot为使用Neo4j提供了一些便利，包括<code>spring-boot-starter-data-neo4j</code> 启动器。</p>
<h3 id="连接到Neo4j数据库"><a href="#连接到Neo4j数据库" class="headerlink" title="连接到Neo4j数据库"></a>连接到Neo4j数据库</h3><p>要访问Neo4j服务器，您可以注入自动配置 <code>org.neo4j.ogm.session.Session</code>。默认情况下，实例尝试<code>localhost:7687</code>使用Bolt协议连接到Neo4j服务器。以下示例显示了如何注入Neo4j <code>Session</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Session session;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.session = session;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以通过设置<code>spring.data.neo4j.*</code> 属性来配置要使用的URI和凭据，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.data.neo4j.uri=bolt://my-server:7687</span><br><span class="line">spring.data.neo4j.username=neo4j</span><br><span class="line">spring.data.neo4j.password=secret</span><br></pre></td></tr></table></figure>
<p>您可以通过添加a来完全控制会话创建 <code>org.neo4j.ogm.config.Configuration</code> <code>@Bean</code>。此外，添加一个<code>@Bean</code>类型 <code>SessionFactory</code>会禁用自动配置并为您提供完全控制。</p>
<h3 id="使用嵌入模式"><a href="#使用嵌入模式" class="headerlink" title="使用嵌入模式"></a>使用嵌入模式</h3><p>如果添加<code>org.neo4j:neo4j-ogm-embedded-driver</code>到应用程序的依赖项，Spring Boot会自动配置Neo4j的进程内嵌入式实例，该应用程序在应用程序关闭时不会保留任何数据。</p>
<blockquote>
<p>由于嵌入式Neo4j OGM驱动程序本身不提供Neo4j内核，因此您必须自己声明<code>org.neo4j:neo4j</code>为依赖项。有关兼容版本的列表，请参阅 <a href="https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started" target="_blank" rel="noopener">Neo4j OGM文档</a>。</p>
</blockquote>
<p>当类路径上有多个驱动程序时，嵌入式驱动程序优先于其他驱动程序。您可以通过设置明确禁用嵌入模式 <code>spring.data.neo4j.embedded.enabled=false</code>。</p>
<p>如果嵌入式驱动程序和Neo4j内核如上所述位于类路径上，则<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test" target="_blank" rel="noopener">数据Neo4j测试会</a>自动使用嵌入式Neo4j实例。</p>
<blockquote>
<p>您可以通过在配置中提供数据库文件的路径来为嵌入模式启用持久性，例如<code>spring.data.neo4j.uri=file://var/tmp/graph.db</code>。</p>
</blockquote>
<h3 id="Neo4jSession"><a href="#Neo4jSession" class="headerlink" title="Neo4jSession"></a>Neo4jSession</h3><p>默认情况下，如果您正在运行Web应用程序，则会话将绑定到线程以进行整个请求处理（即，它使用“在视图中打开会话”模式）。如果您不想要此行为，请将以下行添加到您的 <code>application.properties</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.neo4j.embedded.enabled=false</span><br></pre></td></tr></table></figure>
<h3 id="Spring-Data-Neo4j存储库"><a href="#Spring-Data-Neo4j存储库" class="headerlink" title="Spring Data Neo4j存储库"></a>Spring Data Neo4j存储库</h3><p>Spring Data包含对Neo4j的存储库支持。</p>
<p>Spring Data Neo4j与Spring Data JPA共享通用基础架构，就像许多其他Spring Data模块一样。您可以从之前的JPA示例中获取并定义 <code>City</code>为Neo4j OGM <code>@NodeEntity</code>而不是JPA <code>@Entity</code>，并且存储库抽象以相同的方式工作，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Neo4jRepository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">Optional&lt;City&gt; <span class="title">findOneByNameAndState</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>spring-boot-starter-data-neo4j</code>“入门”使仓库的支持以及事务管理。您可以自定义的位置通过查找资料库和实体<code>@EnableNeo4jRepositories</code>，并<code>@EntityScan</code>分别在 <code>@Configuration</code>-bean。</p>
<blockquote>
<p>有关Spring Data Neo4j的完整详细信息，包括其对象映射技术，请参阅<a href="https://projects.spring.io/spring-data-neo4j/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="Gemfire"><a href="#Gemfire" class="headerlink" title="Gemfire"></a>Gemfire</h2><p><a href="https://github.com/spring-projects/spring-data-gemfire" target="_blank" rel="noopener">Spring Data Gemfire</a>为访问<a href="https://pivotal.io/big-data/pivotal-gemfire#details" target="_blank" rel="noopener">Pivotal Gemfire</a>数据管理平台提供了方便的Spring友好工具 。有一个<code>spring-boot-starter-data-gemfire</code>启动器用于以方便的方式收集依赖项。目前没有对Gemfire的自动配置支持，但您可以使用单个注释<a href="https://github.com/spring-projects/spring-data-gemfire/blob/master/src/main/java/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.java" target="_blank" rel="noopener"><code>@EnableGemfireRepositories</code></a>启用Spring Data Repositories <a href="https://github.com/spring-projects/spring-data-gemfire/blob/master/src/main/java/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.java" target="_blank" rel="noopener">:</a> .</p>
<h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p><a href="https://lucene.apache.org/solr/" target="_blank" rel="noopener">Apache Solr</a>是一个搜索引擎。Spring Boot为Solr 5客户端库提供了基本的自动配置，并为<a href="https://github.com/spring-projects/spring-data-solr" target="_blank" rel="noopener">Spring Data Solr</a>提供了它的抽象。有一个<code>spring-boot-starter-data-solr</code>启动器用于以方便的方式收集依赖项。</p>
<h3 id="连接到Solr"><a href="#连接到Solr" class="headerlink" title="连接到Solr"></a>连接到Solr</h3><p>您可以<code>SolrClient</code>像任何其他Spring bean一样注入自动配置的实例。默认情况下，实例尝试连接到服务器 <code>localhost:8983/solr</code>。以下示例显示如何注入Solr bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> SolrClient solr;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(SolrClient solr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.solr = solr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加自己<code>@Bean</code>的类型<code>SolrClient</code>，则会替换默认值。</p>
<h3 id="Spring-Data-Solr存储库"><a href="#Spring-Data-Solr存储库" class="headerlink" title="Spring Data Solr存储库"></a>Spring Data Solr存储库</h3><p>Spring Data包括Apache Solr的存储库支持。与前面讨论的JPA存储库一样，基本原则是根据方法名称自动构造查询。</p>
<p>事实上，Spring Data JPA和Spring Data Solr共享相同的通用基础架构。您可以从之前获取JPA示例，并假设它<code>City</code>现在是一个 <code>@SolrDocument</code>类而不是JPA <code>@Entity</code>，它以相同的方式工作。</p>
<blockquote>
<p>有关Spring Data Solr的完整详细信息，请参阅 <a href="https://projects.spring.io/spring-data-solr/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p><a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a>是一个开源，分布式，RESTful搜索和分析引擎。Spring Boot为Elasticsearch提供基本的自动配置。</p>
<p>Spring Boot支持多个HTTP客户端：</p>
<ul>
<li>官方Java“低级”和“高级”REST客户端</li>
<li><a href="https://github.com/searchbox-io/Jest" target="_blank" rel="noopener">笑话</a></li>
</ul>
<p><a href="https://github.com/spring-projects/spring-data-elasticsearch" target="_blank" rel="noopener">Spring Data Elasticsearch</a>仍在使用传输客户端 ，您可以使用<code>spring-boot-starter-data-elasticsearch</code>启动器开始使用它。</p>
<h3 id="REST客户端连接到Elasticsearch"><a href="#REST客户端连接到Elasticsearch" class="headerlink" title="REST客户端连接到Elasticsearch"></a>REST客户端连接到Elasticsearch</h3><p>Elasticsearch提供了 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html" target="_blank" rel="noopener">两个</a> 可用于查询集群的<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html" target="_blank" rel="noopener">REST客户端</a>：“低级”客户端和“高级”客户端。</p>
<p>如果您<code>org.elasticsearch.client:elasticsearch-rest-client</code>依赖于类路径，Spring Boot将自动配置并注册<code>RestClient</code>默认目标的bean <code>localhost:9200</code>。您可以进一步调整<code>RestClient</code>配置方式，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.elasticsearch.rest.uris=http://search.example.com:9200</span><br><span class="line">spring.elasticsearch.rest.username=user</span><br><span class="line">spring.elasticsearch.rest.password=secret</span><br></pre></td></tr></table></figure>
<p>您还可以注册任意数量的bean，以实现 <code>RestClientBuilderCustomizer</code>更高级的自定义。要完全控制注册，请定义<code>RestClient</code>bean。</p>
<p>如果您<code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code>对类路径有依赖性，Spring Boot将自动配置a <code>RestHighLevelClient</code>，它包装任何现有的<code>RestClient</code>bean，重用其HTTP配置。</p>
<h3 id="使用Jest连接到Elasticsearch"><a href="#使用Jest连接到Elasticsearch" class="headerlink" title="使用Jest连接到Elasticsearch"></a>使用Jest连接到Elasticsearch</h3><p>如果您具有<code>Jest</code>类路径，则可以注入<code>JestClient</code>默认目标的自动配置<code>localhost:9200</code>。您可以进一步调整客户端的配置方式，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.elasticsearch.jest.uris=http://search.example.com:9200</span><br><span class="line">spring.elasticsearch.jest.read-timeout=10000</span><br><span class="line">spring.elasticsearch.jest.username=user</span><br><span class="line">spring.elasticsearch.jest.password=secret</span><br></pre></td></tr></table></figure>
<p>您还可以注册任意数量的bean，以实现 <code>HttpClientConfigBuilderCustomizer</code>更高级的自定义。以下示例调整其他HTTP设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSettingsCustomizer</span> <span class="keyword">implements</span> <span class="title">HttpClientConfigBuilderCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(HttpClientConfig.Builder builder)</span> </span>&#123;</span><br><span class="line">		builder.maxTotalConnection(<span class="number">100</span>).defaultMaxTotalConnectionPerRoute(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要完全控制注册，请定义<code>JestClient</code>bean。</p>
<h3 id="使用Spring数据连接Elasticsearch"><a href="#使用Spring数据连接Elasticsearch" class="headerlink" title="使用Spring数据连接Elasticsearch"></a>使用Spring数据连接Elasticsearch</h3><p>要连接到Elasticsearch，您必须提供一个或多个群集节点的地址。可以通过将<code>spring.data.elasticsearch.cluster-nodes</code> 属性设置为逗号分隔<code>host:port</code>列表来指定地址。使用此配置， 可以像任何其他Spring bean一样注入<code>ElasticsearchTemplate</code>或<code>TransportClient</code>注入，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.elasticsearch.cluster-nodes=localhost:9300</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ElasticsearchTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您添加自己的<code>ElasticsearchTemplate</code>或<code>TransportClient</code> <code>@Bean</code>，它将替换默认值。</p>
<h3 id="Spring-Data-Elasticsearch存储库"><a href="#Spring-Data-Elasticsearch存储库" class="headerlink" title="Spring Data Elasticsearch存储库"></a>Spring Data Elasticsearch存储库</h3><p>Spring Data包括对Elasticsearch的存储库支持。与前面讨论的JPA存储库一样，基本原则是根据方法名称自动为您构建查询。</p>
<p>事实上，Spring Data JPA和Spring Data Elasticsearch共享相同的通用基础架构。您可以从之前的JPA示例中获取，假设它<code>City</code>现在是Elasticsearch <code>@Document</code>类而不是JPA <code>@Entity</code>，它的工作方式相同。</p>
<blockquote>
<p>有关Spring Data Elasticsearch的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/elasticsearch/docs/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p><a href="https://cassandra.apache.org/" target="_blank" rel="noopener">Cassandra</a>是一个开源的分布式数据库管理系统，旨在处理许多商用服务器上的大量数据。Spring Boot提供了Cassandra的自动配置以及<a href="https://github.com/spring-projects/spring-data-cassandra" target="_blank" rel="noopener">Spring Data Cassandra</a>提供的抽象。有一个<code>spring-boot-starter-data-cassandra</code>启动器用于以方便的方式收集依赖项。</p>
<h3 id="连接到Cassandra"><a href="#连接到Cassandra" class="headerlink" title="连接到Cassandra"></a>连接到Cassandra</h3><p>您可以像使用任何其他Spring Bean一样注入自动配置<code>CassandraTemplate</code>或Cassandra <code>Session</code>实例。这些<code>spring.data.cassandra.*</code>属性可用于自定义连接。通常，您提供<code>keyspace-name</code>和 <code>contact-points</code>属性，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.data.cassandra.keyspace-name=mykeyspace</span><br><span class="line">spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2</span><br></pre></td></tr></table></figure>
<p>您还可以注册任意数量的bean，以实现 <code>ClusterBuilderCustomizer</code>更高级的自定义。</p>
<p>以下代码清单显示了如何注入Cassandra bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> CassandraTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CassandraTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加自己<code>@Bean</code>的类型<code>CassandraTemplate</code>，则会替换默认值。</p>
<h3 id="Spring-Data-Cassandra存储库"><a href="#Spring-Data-Cassandra存储库" class="headerlink" title="Spring Data Cassandra存储库"></a>Spring Data Cassandra存储库</h3><p>Spring Data包含对Cassandra的基本存储库支持。目前，这比前面讨论的JPA存储库更有限，需要使用注释查找器方法<code>@Query</code>。</p>
<blockquote>
<p>有关Spring Data Cassandra的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/cassandra/docs/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h2><p><a href="https://www.couchbase.com/" target="_blank" rel="noopener">Couchbase</a>是一个开源的，分布式的，多模型的NoSQL面向文档的数据库，针对交互式应用程序进行了优化。Spring Boot提供了Couchbase的自动配置以及<a href="https://github.com/spring-projects/spring-data-couchbase" target="_blank" rel="noopener">Spring Data Couchbase</a>提供的抽象 。有一个 <code>spring-boot-starter-data-couchbase</code>和<code>spring-boot-starter-data-couchbase-reactive</code> 启动器方便的方法收集的依赖关系。</p>
<h3 id="连接到Couchbase"><a href="#连接到Couchbase" class="headerlink" title="连接到Couchbase"></a>连接到Couchbase</h3><p>你可以得到一个<code>Bucket</code>和<code>Cluster</code>通过添加Couchbase SDK和一些配置。这些<code>spring.couchbase.*</code>属性可用于自定义连接。通常，您提供引导主机，存储桶名称和密码，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123</span><br><span class="line">spring.couchbase.bucket.name=my-bucket</span><br><span class="line">spring.couchbase.bucket.password=secret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您需要<em>至少</em>提供引导主机，在这种情况下，存储桶名称为 <code>default</code>，密码为空字符串。或者，您可以定义自己的<code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code> <code>@Bean</code>控件来控制整个配置。</p>
</blockquote>
<p>也可以自定义一些<code>CouchbaseEnvironment</code>设置。例如，以下配置更改用于打开新的超时<code>Bucket</code> 并启用SSL支持的超时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.couchbase.env.timeouts.connect=3000</span><br><span class="line">spring.couchbase.env.ssl.key-store=/location/of/keystore.jks</span><br><span class="line">spring.couchbase.env.ssl.key-store-password=secret</span><br></pre></td></tr></table></figure>
<p>检查<code>spring.couchbase.env.*</code>属性以获取更多详细信息。</p>
<h3 id="Spring-Data-Couchbase存储库"><a href="#Spring-Data-Couchbase存储库" class="headerlink" title="Spring Data Couchbase存储库"></a>Spring Data Couchbase存储库</h3><p>Spring Data包括对Couchbase的存储库支持。有关Spring Data Couchbase的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/" target="_blank" rel="noopener">参考文档</a>。</p>
<p>您可以<code>CouchbaseTemplate</code>像使用任何其他Spring Bean一样注入自动配置的实例，只要有<em>默认值</em> <code>CouchbaseConfigurer</code>（当您启用Couchbase支持时会发生这种情况，如前所述）。</p>
<p>以下示例显示了如何注入Couchbase bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> CouchbaseTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CouchbaseTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在自己的配置中定义一些bean来覆盖自动配置提供的bean：</p>
<ul>
<li><code>CouchbaseTemplate</code> <code>@Bean</code>的名字是<code>couchbaseTemplate</code>。</li>
<li><code>IndexManager</code> <code>@Bean</code>用的名称<code>couchbaseIndexManager</code>。</li>
<li><code>CustomConversions</code> <code>@Bean</code>的名字是<code>couchbaseCustomConversions</code>。</li>
</ul>
<p>为避免在您自己的配置中对这些名称进行硬编码，您可以重复使用<code>BeanNames</code>Spring Data Couchbase。例如，您可以自定义要使用的转换器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span>(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> CustomConversions <span class="title">myCustomConversions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CustomConversions(...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要完全绕过Spring Data Couchbase的自动配置，请提供自己的实现<code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code>。</p>
</blockquote>
<h2 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h2><p><a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" target="_blank" rel="noopener">LDAP</a>（轻量级目录访问协议）是一种开放的，与供应商无关的行业标准应用程序协议，用于通过IP网络访问和维护分布式目录信息服务。Spring Boot为任何兼容的LDAP服务器提供自动配置，并为<a href="https://www.ldap.com/unboundid-ldap-sdk-for-java" target="_blank" rel="noopener">UnboundID</a>支持嵌入式内存中LDAP服务器 。</p>
<p>LDAP抽象由 <a href="https://github.com/spring-projects/spring-data-ldap" target="_blank" rel="noopener">Spring Data LDAP提供</a>。有一个<code>spring-boot-starter-data-ldap</code>启动器用于以方便的方式收集依赖项。</p>
<h3 id="连接LDAP服务器"><a href="#连接LDAP服务器" class="headerlink" title="连接LDAP服务器"></a>连接LDAP服务器</h3><p>要连接到LDAP服务器，请确保声明对<code>spring-boot-starter-data-ldap</code>启动器 的依赖关系 <code>spring-ldap-core</code>，然后在application.properties中声明服务器的URL，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.urls=ldap://myserver:1235</span><br><span class="line">spring.ldap.username=admin</span><br><span class="line">spring.ldap.password=secret</span><br></pre></td></tr></table></figure>
<p>如果需要自定义连接设置，可以使用<code>spring.ldap.base</code>和 <code>spring.ldap.base-environment</code>属性。</p>
<p>一种<code>LdapContextSource</code>是自动配置基于这些设置。如果您需要自定义它，例如使用a <code>PooledContextSource</code>，您仍然可以注入自动配置<code>LdapContextSource</code>。确保将自定义标记<code>ContextSource</code>为<code>@Primary</code>自动配置<code>LdapTemplate</code>使用它。</p>
<h3 id="Spring-Data-LDAP存储库"><a href="#Spring-Data-LDAP存储库" class="headerlink" title="Spring Data LDAP存储库"></a>Spring Data LDAP存储库</h3><p>Spring Data包括对LDAP的存储库支持。有关Spring Data LDAP的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/" target="_blank" rel="noopener">参考文档</a>。</p>
<p>您也可以<code>LdapTemplate</code>像使用任何其他Spring Bean一样注入自动配置的实例，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LdapTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(LdapTemplate template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌入式内存LDAP服务器"><a href="#嵌入式内存LDAP服务器" class="headerlink" title="嵌入式内存LDAP服务器"></a>嵌入式内存LDAP服务器</h3><p>出于测试目的，Spring Boot支持从<a href="https://www.ldap.com/unboundid-ldap-sdk-for-java" target="_blank" rel="noopener">UnboundID</a>自动配置内存中的LDAP服务器。要配置服务器，请向依赖项添加依赖项<code>com.unboundid:unboundid-ldapsdk</code>并声明<code>base-dn</code>属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.embedded.base-dn=dc=spring,dc=io</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以定义多个base-dn值，但是，由于可分辨名称通常包含逗号，因此必须使用正确的表示法定义它们。</p>
<p>在yaml文件中，您可以使用yaml列表表示法：</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.ldap.embedded.base-dn:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dc=spring,dc=io</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dc=pivotal,dc=io</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在属性文件中，必须包含索引作为属性名称的一部分：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.ldap.embedded.base-dn[0]=dc=spring,dc=io</span><br><span class="line">spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io</span><br></pre></td></tr></table></figure>
<p>默认情况下，服务器在随机端口上启动并触发常规LDAP支持。无需指定<code>spring.ldap.urls</code>属性。</p>
<p>如果<code>schema.ldif</code>类路径中有文件，则用于初始化服务器。如果要从其他资源加载初始化脚本，还可以使用该<code>spring.ldap.embedded.ldif</code>属性。</p>
<p>默认情况下，标准模式用于验证<code>LDIF</code>文件。您可以通过设置<code>spring.ldap.embedded.validation.enabled</code>属性完全关闭验证。如果您有自定义属性，则可以使用它<code>spring.ldap.embedded.validation.schema</code>来定义自定义属性类型或对象类。</p>
<h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><p><a href="https://www.influxdata.com/" target="_blank" rel="noopener">InfluxDB</a>是一个开源时间序列数据库，针对运营监控，应用程序指标，物联网传感器数据和实时分析等领域中的时间序列数据的快速，高可用性存储和检索进行了优化。</p>
<h3 id="连接到InfluxDB"><a href="#连接到InfluxDB" class="headerlink" title="连接到InfluxDB"></a>连接到InfluxDB</h3><p><code>InfluxDB</code>如果<code>influxdb-java</code>客户端在类路径上并且设置了数据库的URL，则Spring Boot会自动配置实例，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.influx.url=http://172.0.0.1:8086</span><br></pre></td></tr></table></figure>
<p>如果与InfluxDB的连接需要用户和密码，则可以相应地设置 <code>spring.influx.user</code>和<code>spring.influx.password</code>属性。</p>
<p>InfluxDB依赖于OkHttp。如果需要调整http客户端<code>InfluxDB</code>在幕后使用，可以注册一个<code>InfluxDbOkHttpClientBuilderProvider</code>bean。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-NoSQL数据库/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/20/使用SpringBoot-SQL数据库/">使用SpringBoot-SQL数据库</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/sql/">sql</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/database/">database</a></div></div><div class="post-content"><div class="main-content content"><h1 id="SQL数据库"><a href="#SQL数据库" class="headerlink" title="SQL数据库"></a>SQL数据库</h1><p>在<a href="https://projects.spring.io/spring-framework/" target="_blank" rel="noopener">Spring框架</a>提供了广泛的支持使用使用SQL数据库，直接JDBC访问<code>JdbcTemplate</code>来完成“对象关系映射”技术，比如Hibernate。<a href="https://projects.spring.io/spring-data/" target="_blank" rel="noopener">Spring Data</a>提供了更多级别的功能：<code>Repository</code>直接从接口创建实现，并使用约定从方法名称生成查询。</p>
<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>Java的<code>javax.sql.DataSource</code>接口提供了一种使用数据库连接的标准方法。传统上，’DataSource’使用<code>URL</code>一些凭证来建立数据库连接。</p>
<blockquote>
<p>有关更多高级示例，请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-a-datasource" target="_blank" rel="noopener">“操作方法”</a>，通常可以完全控制DataSource的配置。</p>
</blockquote>
<h3 id="嵌入式数据库支持"><a href="#嵌入式数据库支持" class="headerlink" title="嵌入式数据库支持"></a>嵌入式数据库支持</h3><p>通过使用内存中的嵌入式数据库来开发应用程序通常很方便。显然，内存数据库不提供持久存储。您需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。</p>
<blockquote>
<p>“操作方法”部分包含<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-database-initialization" target="_blank" rel="noopener">有关如何初始化数据库的部分</a>。</p>
</blockquote>
<p>Spring Boot可以自动配置嵌入式<a href="http://www.h2database.com/" target="_blank" rel="noopener">H2</a>， <a href="http://hsqldb.org/" target="_blank" rel="noopener">HSQL</a>和<a href="https://db.apache.org/derby/" target="_blank" rel="noopener">Derby</a>数据库。您无需提供任何连接URL。您只需要包含要使用的嵌入式数据库的构建依赖项。</p>
<blockquote>
<p>如果您在测试中使用此功能，您可能会注意到整个测试套件都会重复使用相同的数据库，而不管您使用的应用程序上下文的数量。如果要确保每个上下文都有一个单独的嵌入式数据库，则应设置<code>spring.datasource.generate-unique-name</code>为<code>true</code>。</p>
</blockquote>
<p>例如，典型的POM依赖关系如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>您需要依赖于<code>spring-jdbc</code>自动配置嵌入式数据库。在这个例子中，它被传递过来 <code>spring-boot-starter-data-jpa</code>。</p>
</blockquote>
<blockquote>
<p>如果由于某种原因，您确实为嵌入式数据库配置了连接URL，请注意确保禁用数据库的自动关闭。如果你使用H2，你应该<code>DB_CLOSE_ON_EXIT=FALSE</code>这样做。如果使用HSQLDB，则应确保<code>shutdown=true</code>未使用HSQLDB 。禁用数据库的自动关闭可以在数据库关闭时进行Spring Boot控制，从而确保在不再需要访问数据库时发生。</p>
</blockquote>
<h3 id="连接到生产数据库"><a href="#连接到生产数据库" class="headerlink" title="连接到生产数据库"></a>连接到生产数据库</h3><p>也可以使用池自动配置生产数据库连接 <code>DataSource</code>。Spring Boot使用以下算法来选择特定的实现：</p>
<ol>
<li>我们更喜欢<a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">HikariCP</a>的性能和并发性。如果HikariCP可用，我们总是选择它。</li>
<li>否则，如果Tomcat池<code>DataSource</code>可用，我们将使用它。</li>
<li>如果HikariCP和Tomcat池化数据源都不可用，并且 <a href="https://commons.apache.org/proper/commons-dbcp/" target="_blank" rel="noopener">Commons DBCP2</a>可用，我们就会使用它。</li>
</ol>
<p>如果您使用<code>spring-boot-starter-jdbc</code>或<code>spring-boot-starter-data-jpa</code>启动器，您将自动获得依赖<code>HikariCP</code>。</p>
<blockquote>
<p>您可以完全绕过该算法，并通过设置<code>spring.datasource.type</code>属性指定要使用的连接池。如果您在Tomcat容器中运行应用程序<code>tomcat-jdbc</code>（默认情况下提供），这一点尤为重要。</p>
</blockquote>
<blockquote>
<p>始终可以手动配置其他连接池。如果您定义自己的<code>DataSource</code>bean，则不会进行自动配置。</p>
</blockquote>
<p>DataSource配置由外部配置属性控制 <code>spring.datasource.*</code>。例如，您可以在以下部分声明以下部分 <code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost/test</span><br><span class="line">spring.datasource.username=dbuser</span><br><span class="line">spring.datasource.password=dbpass</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您至少应该通过设置<code>spring.datasource.url</code> 属性来指定URL 。否则，Spring Boot会尝试自动配置嵌入式数据库。</p>
</blockquote>
<blockquote>
<p>您通常不需要指定<code>driver-class-name</code>，因为Spring Boot可以从大多数数据库推断它<code>url</code>。</p>
</blockquote>
<blockquote>
<p>对于<code>DataSource</code>要创建的池，我们需要能够验证有效的 <code>Driver</code>类是否可用，因此我们在执行任何操作之前检查它。换句话说，如果你设置<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>，那么该类必须是可加载的。</p>
</blockquote>
<p>有关<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java" target="_blank" rel="noopener"><code>DataSourceProperties</code></a> 更多支持的选项，请参阅 。无论实际实施如何，这些都是标准选项。也可以微调实现特定的设置，使用各自的前缀（<code>spring.datasource.hikari.*</code>， <code>spring.datasource.tomcat.*</code>，和<code>spring.datasource.dbcp2.*</code>）。有关更多详细信息，请参阅您正在使用的连接池实现的文档。</p>
<p>例如，如果使用 <a href="https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes" target="_blank" rel="noopener">Tomcat连接池</a>，则可以自定义许多其他设置，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">＃如果没有可用连接，则在抛出异常之前要等待的ms数。</span><br><span class="line">spring.datasource.tomcat.max-wait = 10000</span><br><span class="line"></span><br><span class="line">＃可以同时从该池分配的最大活动连接数。</span><br><span class="line">spring.datasource.tomcat.max-active = 50</span><br><span class="line"></span><br><span class="line">＃在从池中借用连接之前验证连接。</span><br><span class="line">spring.datasource.tomcat.test-on-borrow = true</span><br></pre></td></tr></table></figure>
<h3 id="连接到JNDI数据源"><a href="#连接到JNDI数据源" class="headerlink" title="连接到JNDI数据源"></a>连接到JNDI数据源</h3><p>如果将Spring Boot应用程序部署到Application Server，则可能需要使用Application Server的内置功能配置和管理DataSource，并使用JNDI访问它。</p>
<p>该<code>spring.datasource.jndi-name</code>属性可以被用作一个替代 <code>spring.datasource.url</code>，<code>spring.datasource.username</code>和<code>spring.datasource.password</code>属性来访问<code>DataSource</code>从一个特定的JNDI位置。例如，以下部分<code>application.properties</code>显示了如何访问定义的JBoss AS <code>DataSource</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.jndi-name=java:jboss/datasources/customers</span><br></pre></td></tr></table></figure>
<h2 id="使用JdbcTemplate"><a href="#使用JdbcTemplate" class="headerlink" title="使用JdbcTemplate"></a>使用JdbcTemplate</h2><p>Spring <code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>类是自动配置的，您可以<code>@Autowire</code>直接将它们放入自己的bean中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>spring.jdbc.template.*</code> 属性自定义模板的某些属性，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jdbc.template.max-rows=500</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>NamedParameterJdbcTemplate</code>重复使用相同的<code>JdbcTemplate</code>幕后情况。如果<code>JdbcTemplate</code>定义了多个且没有主要候选项，<code>NamedParameterJdbcTemplate</code>则不会自动配置。</p>
</blockquote>
<h2 id="JPA和Spring-Data-JPA"><a href="#JPA和Spring-Data-JPA" class="headerlink" title="JPA和Spring Data JPA"></a>JPA和Spring Data JPA</h2><p>Java Persistence API是一种标准技术，可让您将对象“映射”到关系数据库。该<code>spring-boot-starter-data-jpa</code>POM提供了上手的快捷方式。它提供以下关键依赖项：</p>
<ul>
<li>Hibernate：最受欢迎的JPA实现之一。</li>
<li>Spring Data JPA：使实现基于JPA的存储库变得容易。</li>
<li>Spring ORMs：Spring Framework的核心ORM支持。</li>
</ul>
<blockquote>
<p>我们不会在这里详细介绍JPA或<a href="https://projects.spring.io/spring-data/" target="_blank" rel="noopener">Spring Data</a>。您可以按照<a href="https://spring.io/guides/gs/accessing-data-jpa/" target="_blank" rel="noopener">“访问数据与JPA”</a> 从指导<a href="https://spring.io/" target="_blank" rel="noopener">spring.io</a>并宣读了<a href="https://projects.spring.io/spring-data-jpa/" target="_blank" rel="noopener">春天的数据JPA</a>和 <a href="https://hibernate.org/orm/documentation/" target="_blank" rel="noopener">Hibernate的</a>参考文档。</p>
</blockquote>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>传统上，JPA“实体”类在<code>persistence.xml</code>文件中指定。使用Spring Boot，此文件不是必需的，而是使用“实体扫描”。默认情况下，将搜索主配置类（注释为<code>@EnableAutoConfiguration</code>或者<code>@SpringBootApplication</code>）下的所有包 。</p>
<p>任何类别标注了<code>@Entity</code>，<code>@Embeddable</code>或者<code>@MappedSuperclass</code>被认为是。典型的实体类类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue</span></span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...其他成员，通常包括@OneToMany映射</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//JPA规范要求的no-args构造函数</span></span><br><span class="line">		<span class="comment">//这个是受保护的，因为它不应该直接使用</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ... etc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您可以使用<code>@EntityScan</code>注释自定义实体扫描位置。请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration" target="_blank" rel="noopener">第84.4节</a> ” <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration" target="_blank" rel="noopener">，“从Spring配置中分离@Entity定义”</a> “ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration" target="_blank" rel="noopener">操作方法”</a>。</p>
</blockquote>
<h3 id="Spring-Data-JPA存储库"><a href="#Spring-Data-JPA存储库" class="headerlink" title="Spring Data JPA存储库"></a>Spring Data JPA存储库</h3><p><a href="https://projects.spring.io/spring-data-jpa/" target="_blank" rel="noopener">Spring Data JPA</a>存储库是您可以定义以访问数据的接口。JPA查询是从您的方法名称自动创建的。例如， <code>CityRepository</code>接口可能会声明一种<code>findAllByState(String state)</code>方法来查找给定状态中的所有城市。</p>
<p>对于更复杂的查询，您可以使用Spring Data的<a href="https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/Query.html" target="_blank" rel="noopener"><code>Query</code></a>注释来注释您的方法 。</p>
<p>Spring Data存储库通常从<a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/Repository.html" target="_blank" rel="noopener"><code>Repository</code></a>或 <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html" target="_blank" rel="noopener"><code>CrudRepository</code></a> 接口扩展 。如果使用自动配置，则会从包含主配置类（带有<code>@EnableAutoConfiguration</code>或标注的<code>@SpringBootApplication</code>）的包中搜索存储库 。</p>
<p>以下示例显示了典型的Spring Data存储库接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">	<span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data JPA存储库支持三种不同的引导模式：default，deferred和lazy。要启用延迟或延迟引导，请分别设置<code>spring.data.jpa.repositories.bootstrap-mode</code>为<code>deferred</code>或<code>lazy</code>。使用延迟或延迟引导时，自动配置<code>EntityManagerFactoryBuilder</code> 将使用上下文（<code>AsyncTaskExecutor</code>如果有）作为引导程序执行程序。如果存在多个，则使用命名的那个<code>applicationTaskExecutor</code>。</p>
<blockquote>
<p>我们几乎没有涉及Spring Data JPA的表面。有关完整的详细信息，请参阅<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" target="_blank" rel="noopener">Spring Data JPA参考文档</a>。</p>
</blockquote>
<h3 id="创建和删除JPA数据库"><a href="#创建和删除JPA数据库" class="headerlink" title="创建和删除JPA数据库"></a>创建和删除JPA数据库</h3><p>默认情况下，<strong>仅</strong>当您使用嵌入式数据库（H2，HSQL或Derby）时，<strong>才会</strong>自动创建JPA数据库。您可以使用<code>spring.jpa.*</code>属性显式配置JPA设置 。例如，要创建和删除表，您可以将以下行添加到<code>application.properties</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.ddl-auto=create-drop</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Hibernate自己的内部属性名称（如果你碰巧记得更好）是<code>hibernate.hbm2ddl.auto</code>。您可以使用<code>spring.jpa.properties.*</code>（在将它们添加到实体管理器之前剥离前缀）来设置它以及其他Hibernate本机属性。以下行显示了为Hibernate设置JPA属性的示例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.globally_quoted_identifiers=true</span><br></pre></td></tr></table></figure>
<p>在前面的示例中的线穿过的一个值<code>true</code>的 <code>hibernate.globally_quoted_identifiers</code>属性设置为休眠实体管理器。</p>
<p>默认情况下，DDL执行（或验证）将延迟到<code>ApplicationContext</code> 启动。还有一个<code>spring.jpa.generate-ddl</code>标志，但如果Hibernate自动配置处于活动状态，则不会使用该标志，因为<code>ddl-auto</code>设置更精细。</p>
<h3 id="在View中打开EntityManager"><a href="#在View中打开EntityManager" class="headerlink" title="在View中打开EntityManager"></a>在View中打开EntityManager</h3><p>如果您正在运行Web应用程序，则默认情况下Spring Boot会注册 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html" target="_blank" rel="noopener"><code>OpenEntityManagerInViewInterceptor</code></a> 以应用“在视图中打开EntityManager”模式，以允许在Web视图中进行延迟加载。如果你不希望这种行为，你应该设置<code>spring.jpa.open-in-view</code>到 <code>false</code>你<code>application.properties</code>。</p>
<h2 id="Spring-Data-JDBC"><a href="#Spring-Data-JDBC" class="headerlink" title="Spring Data JDBC"></a>Spring Data JDBC</h2><p>Spring Data包含对JDBC的存储库支持，并将自动为方法生成SQL <code>CrudRepository</code>。对于更高级的查询，<code>@Query</code>提供了注释。</p>
<p>当必要的依赖项在类路径上时，Spring Boot将自动配置Spring Data的JDBC存储库。它们可以通过单个依赖项添加到项目中<code>spring-boot-starter-data-jdbc</code>。如有必要，您可以通过向应用程序添加<code>@EnableJdbcRepositories</code>注释或 <code>JdbcConfiguration</code>子类来控制Spring Data JDBC的配置。</p>
<blockquote>
<p>有关Spring Data JDBC的完整详细信息，请参阅 <a href="https://projects.spring.io/spring-data-jdbc/" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<h2 id="使用H2的Web控制台"><a href="#使用H2的Web控制台" class="headerlink" title="使用H2的Web控制台"></a>使用H2的Web控制台</h2><p>该<a href="http://www.h2database.com/" target="_blank" rel="noopener">H2数据库</a>提供了一个 <a href="http://www.h2database.com/html/quickstart.html#h2_console" target="_blank" rel="noopener">基于浏览器的控制台</a>,Spring启动即可自动配置。满足以下条件时，将自动配置控制台：</p>
<ul>
<li>您正在开发基于servlet的Web应用程序。</li>
<li><code>com.h2database:h2</code> 在类路径上。</li>
<li>您正在使用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#using-boot-devtools" target="_blank" rel="noopener">Spring Boot的开发人员工具</a>。</li>
</ul>
<blockquote>
<p>如果您没有使用Spring Boot的开发人员工具但仍希望使用H2的控制台，则可以<code>spring.h2.console.enabled</code>使用值配置属性<code>true</code>。</p>
</blockquote>
<blockquote>
<p>H2控制台仅用于开发期间，因此您应该注意确保<code>spring.h2.console.enabled</code>在生产中不要设置为<code>true</code>。</p>
</blockquote>
<h3 id="更改H2控制台的路径"><a href="#更改H2控制台的路径" class="headerlink" title="更改H2控制台的路径"></a>更改H2控制台的路径</h3><p>默认情况下，控制台可用于<code>/h2-console</code>。您可以使用该<code>spring.h2.console.path</code>属性自定义控制台的路径。</p>
<h2 id="使用jOOQ"><a href="#使用jOOQ" class="headerlink" title="使用jOOQ"></a>使用jOOQ</h2><p>Java面向对象查询（<a href="http://www.jooq.org/" target="_blank" rel="noopener">jOOQ</a>）是<a href="http://www.datageekery.com/" target="_blank" rel="noopener">Data Geekery的</a>一个流行产品， 它从您的数据库生成Java代码，并允许您通过其流畅的API构建类型安全的SQL查询。商业版和开源版都可以与Spring Boot一起使用。</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>为了使用jOOQ类型安全查询，您需要从数据库模式生成Java类。您可以按照<a href="https://www.jooq.org/doc/3.11.9/manual-single-page/#jooq-in-7-steps-step3" target="_blank" rel="noopener">jOOQ用户手册中</a>的说明进行 <a href="https://www.jooq.org/doc/3.11.9/manual-single-page/#jooq-in-7-steps-step3" target="_blank" rel="noopener">操作</a>。如果您使用该 <code>jooq-codegen-maven</code>插件并且还使用<code>spring-boot-starter-parent</code> “父POM”，则可以安全地省略插件的<code>&lt;version&gt;</code>标签。您还可以使用Spring Boot定义的版本变量（例如<code>h2.version</code>）来声明插件的数据库依赖性。以下清单显示了一个示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jooq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">		...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;h2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jdbc</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">driver</span>&gt;</span>org.h2.Driver<span class="tag">&lt;/<span class="name">driver</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:h2:~/yourdatabase<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">jdbc</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">generator</span>&gt;</span></span><br><span class="line">			...</span><br><span class="line">		<span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用DSLContext"><a href="#使用DSLContext" class="headerlink" title="使用DSLContext"></a>使用DSLContext</h3><p>jOOQ提供的流畅API通过<code>org.jooq.DSLContext</code>界面启动。Spring Boot自动配置<code>DSLContext</code>为Spring Bean并将其连接到您的应用程序<code>DataSource</code>。要使用<code>DSLContext</code>，您可以使用<code>@Autowire</code>它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JooqExample</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> DSLContext create;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JooqExample</span><span class="params">(DSLContext dslContext)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.create = dslContext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>jOOQ手册倾向于使用一个名为<code>create</code>hold的变量<code>DSLContext</code>。</p>
</blockquote>
<p>然后，您可以使用它<code>DSLContext</code>来构建查询，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;GregorianCalendar&gt; <span class="title">authorsBornAfter1980</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.create.selectFrom(AUTHOR)</span><br><span class="line">		.where(AUTHOR.DATE_OF_BIRTH.greaterThan(<span class="keyword">new</span> GregorianCalendar(<span class="number">1980</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">		.fetch(AUTHOR.DATE_OF_BIRTH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jOOQ-SQL方言"><a href="#jOOQ-SQL方言" class="headerlink" title="jOOQ SQL方言"></a>jOOQ SQL方言</h3><p>除非<code>spring.jooq.sql-dialect</code>已配置该属性，否则Spring Boot会确定用于数据源的SQL方言。如果Spring Boot无法检测到方言，则使用<code>DEFAULT</code>。</p>
<blockquote>
<p>Spring Boot只能自动配置开源版本的jOOQ支持的方言。</p>
</blockquote>
<h3 id="自定义jOOQ"><a href="#自定义jOOQ" class="headerlink" title="自定义jOOQ"></a>自定义jOOQ</h3><p>通过定义自己的<code>@Bean</code>定义可以实现更高级的自定义，这些定义在<code>Configuration</code>创建jOOQ时使用。您可以为以下jOOQ类型定义bean：</p>
<ul>
<li><code>ConnectionProvider</code></li>
<li><code>ExecutorProvider</code></li>
<li><code>TransactionProvider</code></li>
<li><code>RecordMapperProvider</code></li>
<li><code>RecordUnmapperProvider</code></li>
<li><code>RecordListenerProvider</code></li>
<li><code>ExecuteListenerProvider</code></li>
<li><code>VisitListenerProvider</code></li>
<li><code>TransactionListenerProvider</code></li>
</ul>
<p><code>org.jooq.Configuration</code> <code>@Bean</code>如果要完全控制jOOQ配置，也可以创建自己的。</p>
</div></div><a class="button-hover more" href="/2019/03/20/使用SpringBoot-SQL数据库/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/20/使用SpringBoot-Security/">使用SpringBoot-Security</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-20</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/security/">security</a></div></div><div class="post-content"><div class="main-content content"><h2 id="Security-安全"><a href="#Security-安全" class="headerlink" title="Security(安全)"></a>Security(安全)</h2><p>如果<a href="https://projects.spring.io/spring-security/" target="_blank" rel="noopener">Spring Security</a>位于类路径上，则默认情况下Web应用程序是安全的。Spring Boot依赖于Spring Security的内容协商策略来确定是否使用<code>httpBasic</code>或<code>formLogin</code>。要向Web应用程序添加方法级安全性，您还可以<code>@EnableGlobalMethodSecurity</code>使用所需的设置进行添加。其他信息可以在 <a href="https://docs.spring.io/spring-security/site/docs/5.1.4.RELEASE/reference/htmlsingle#jc-method" target="_blank" rel="noopener">Spring Security Reference Guide中找到</a>。</p>
<p>默认设置<code>UserDetailsService</code>只有一个用户。用户名是<code>user</code>，密码是随机的，在应用程序启动时以INFO级别打印，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用生成的安全密码：78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您对日志记录配置进行微调，请确保将 <code>org.springframework.boot.autoconfigure.security</code>类别设置为log <code>INFO</code>-level messages。否则，不会打印默认密码。</p>
</blockquote>
<p>您可以通过提供<code>spring.security.user.name</code>和 更改用户名和密码<code>spring.security.user.password</code>。</p>
<p>您在Web应用程序中默认获得的基本功能包括：</p>
<ul>
<li>A <code>UserDetailsService</code>（或<code>ReactiveUserDetailsService</code>WebFlux应用程序的情况）bean具有内存存储，单个用户具有生成的密码（请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html" target="_blank" rel="noopener"><code>SecurityProperties.User</code></a> 用户的属性）。</li>
<li>基于表单的登录或HTTP基本安全性（取决于Content-Type）用于整个应用程序（如果执行器在类路径上，则包括执行器端点）。</li>
<li>一个<code>DefaultAuthenticationEventPublisher</code>用于发布身份验证事件。</li>
</ul>
<p>你可以<code>AuthenticationEventPublisher</code>通过为它添加一个bean 来提供不同的东西。</p>
<h3 id="MVC安全性"><a href="#MVC安全性" class="headerlink" title="MVC安全性"></a>MVC安全性</h3><p>默认安全配置在<code>SecurityAutoConfiguration</code>和中 实现<code>UserDetailsServiceAutoConfiguration</code>。<code>SecurityAutoConfiguration</code>导入<code>SpringBootWebSecurityConfiguration</code>Web安全性并 <code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这也与非Web应用程序相关。要完全关闭默认Web应用程序安全配置，您可以添加类型的bean <code>WebSecurityConfigurerAdapter</code>（这样做不会禁用<code>UserDetailsService</code>配置或Actuator的安全性）。</p>
<p>为了还关闭<code>UserDetailsService</code>的配置，您可以添加类型的豆 <code>UserDetailsService</code>，<code>AuthenticationProvider</code>或<code>AuthenticationManager</code>。<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/" target="_blank" rel="noopener">Spring Boot示例中</a>有几个安全的应用程序可以帮助您开始使用常见的用例。</p>
<p>可以通过添加自定义来覆盖访问规则<code>WebSecurityConfigurerAdapter</code>。Spring Boot提供了便捷方法，可用于覆盖执行器端点和静态资源的访问规则。<code>EndpointRequest</code>可用于创建<code>RequestMatcher</code> 基于<code>management.endpoints.web.base-path</code>属性的。 <code>PathRequest</code>可用于<code>RequestMatcher</code>在常用位置创建资源。</p>
<h3 id="WebFlux安全性"><a href="#WebFlux安全性" class="headerlink" title="WebFlux安全性"></a>WebFlux安全性</h3><p>与Spring MVC应用程序类似，您可以通过添加<code>spring-boot-starter-security</code>依赖项来保护WebFlux应用程序。默认安全配置在<code>ReactiveSecurityAutoConfiguration</code>和中 实现<code>UserDetailsServiceAutoConfiguration</code>。<code>ReactiveSecurityAutoConfiguration</code>导入<code>WebFluxSecurityConfiguration</code>Web安全性并<code>UserDetailsServiceAutoConfiguration</code> 配置身份验证，这也与非Web应用程序相关。要完全关闭默认Web应用程序安全配置，您可以添加类型的bean <code>WebFilterChainProxy</code>（这样做不会禁用<code>UserDetailsService</code>配置或Actuator的安全性）。</p>
<p>要关闭<code>UserDetailsService</code>配置，可以添加类型为<code>ReactiveUserDetailsService</code>或的bean <code>ReactiveAuthenticationManager</code>。</p>
<p>可以通过添加自定义来配置访问规则<code>SecurityWebFilterChain</code>。Spring Boot提供了便捷方法，可用于覆盖执行器端点和静态资源的访问规则。<code>EndpointRequest</code>可用于创建 <code>ServerWebExchangeMatcher</code>基于<code>management.endpoints.web.base-path</code> 属性的。</p>
<p><code>PathRequest</code>可用于<code>ServerWebExchangeMatcher</code>在常用位置创建资源。</p>
<p>例如，您可以通过添加以下内容来自定义安全配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityWebFilterChain <span class="title">springSecurityFilterChain</span><span class="params">(ServerHttpSecurity http)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> http.authorizeExchange()</span><br><span class="line">			.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()</span><br><span class="line">			.pathMatchers(<span class="string">"/foo"</span>, <span class="string">"/bar"</span>)</span><br><span class="line">			.authenticated().and()</span><br><span class="line">			.formLogin().and()</span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><p><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth2</a>是Spring支持的一种广泛使用的授权框架。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>如果您具有<code>spring-security-oauth2-client</code>类路径，则可以利用某些自动配置来轻松设置OAuth2 / Open ID Connect客户端。此配置使用下的属性<code>OAuth2ClientProperties</code>。相同的属性适用于servlet和反应式应用程序。</p>
<p>您可以在<code>spring.security.oauth2.client</code>前缀下注册多个OAuth2客户端和提供程序 ，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.registration.my-client-1.client-id=abcd</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.client-secret=password</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.scope=user</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.redirect-uri-template=http://my-redirect-uri.com</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic</span><br><span class="line">spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code</span><br><span class="line"></span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-id=abcd</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-secret=password</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.scope=email</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.redirect-uri-template=http://my-redirect-uri.com</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic</span><br><span class="line">spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code</span><br><span class="line"></span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=http://my-auth-server/oauth/authorize</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.token-uri=http://my-auth-server/oauth/token</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=http://my-auth-server/userinfo</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=http://my-auth-server/token_keys</span><br><span class="line">spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</span><br></pre></td></tr></table></figure>
<p>对于支持<a href="https://openid.net/specs/openid-connect-discovery-1_0.html" target="_blank" rel="noopener">OpenID Connect发现的</a> OpenID Connect提供程序，可以进一步简化配置。需要为提供程序配置一个<code>issuer-uri</code>URI，它将其声明为其颁发者标识符。例如，如果 <code>issuer-uri</code>提供的是“<a href="https://example.com”，`OpenID" target="_blank" rel="noopener">https://example.com”，`OpenID</a> Provider Configuration Request<code>则会进行“https://example.com/.well-known/openid-configuration”。结果预计是一个</code>OpenID Provider Configuration Response<code>。以下示例显示如何使用以下命令配置OpenID Connect Provider</code>issuer-uri`：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.provider.oidc-provider.issuer-uri = https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></td></tr></table></figure>
<p>默认情况下，Spring Security <code>OAuth2LoginAuthenticationFilter</code>仅处理URL匹配<code>/login/oauth2/code/*</code>。如果要自定义<code>redirect-uri</code>以使用其他模式，则需要提供配置以处理该自定义模式。例如，对于servlet应用程序，您可以添加<code>WebSecurityConfigurerAdapter</code>类似于以下内容的应用程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuth2LoginSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		http</span><br><span class="line">			.authorizeRequests()</span><br><span class="line">				.anyRequest().authenticated()</span><br><span class="line">				.and()</span><br><span class="line">			.oauth2Login()</span><br><span class="line">				.redirectionEndpoint()</span><br><span class="line">					.baseUri(<span class="string">"/custom-callback"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>OAuth2客户端注册常见providers</strong></p>
<p>对于常见的OAuth2和OpenID提供商，包括谷歌，Github上，Facebook和1563，我们提供了一组供应商默认的（<code>google</code>，<code>github</code>，<code>facebook</code>，和<code>okta</code>，分别）。</p>
<p>如果您不需要自定义这些提供程序，则可以将<code>provider</code>属性设置为需要推断默认值的属性。此外，如果客户端注册的密钥与默认支持的提供程序匹配，则Spring Boot也会推断出。</p>
<p>换句话说，以下示例中的两个配置使用Google提供程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.client.registration.my-client.client-id = abcd</span><br><span class="line">spring.security.oauth2.client.registration.my-client.client-secret = password</span><br><span class="line">spring.security.oauth2.client.registration.my- client.provider = google</span><br><span class="line"></span><br><span class="line">spring.security.oauth2.client.registration.google.client-id = abcd</span><br><span class="line">spring.security.oauth2.client.registration.google.client-secret = password</span><br></pre></td></tr></table></figure>
<h4 id="Resource-Server-资源服务器"><a href="#Resource-Server-资源服务器" class="headerlink" title="Resource Server(资源服务器)"></a>Resource Server(资源服务器)</h4><p>如果您具有<code>spring-security-oauth2-resource-server</code>类路径，则只要指定了JWK Set URI或OIDC Issuer URI，Spring Boot就可以设置OAuth2资源服务器，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.resourceserver.jwt.jwk-set-uri = https://example.com/oauth2/default/v1/keys</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.security.oauth2.resourceserver.jwt.issuer-uri = https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></td></tr></table></figure>
<p>相同的属性适用于servlet和反应应用程序。</p>
<p>或者，您可以<code>JwtDecoder</code>为servlet应用程序或<code>ReactiveJwtDecoder</code>响应应用程序定义自己的bean 。</p>
<h4 id="Authorization-Server-授权服务器"><a href="#Authorization-Server-授权服务器" class="headerlink" title="Authorization Server(授权服务器)"></a>Authorization Server(授权服务器)</h4><p>目前，Spring Security不支持实施OAuth 2.0授权服务器。但是，此功能可从<a href="https://projects.spring.io/spring-security-oauth/" target="_blank" rel="noopener">Spring Security OAuth</a>项目获得，该项目最终将完全被Spring Security取代。在此之前，您可以使用该<code>spring-security-oauth2-autoconfigure</code>模块轻松设置OAuth 2.0授权服务器; 请参阅其<a href="https://docs.spring.io/spring-security-oauth2-boot" target="_blank" rel="noopener">文档</a>以获取说明</p>
<h3 id="Actuator-Security-执行器安全性"><a href="#Actuator-Security-执行器安全性" class="headerlink" title="Actuator Security(执行器安全性)"></a>Actuator Security(执行器安全性)</h3><p>出于安全考虑，默认情况下除了<code>/health</code>和<code>/info</code>禁用所有执行器。该<code>management.endpoints.web.exposure.include</code>属性可用于启用执行器。</p>
<p>如果春季安全是在类路径上，并没有其他WebSecurityConfigurerAdapter存在，比其他所有的驱动器<code>/health</code>，并<code>/info</code>通过春天开机自动配置安全。如果您定义自定义<code>WebSecurityConfigurerAdapter</code>，Spring Boot自动配置将退回，您将完全控制执行器访问规则。</p>
<blockquote>
<p>在设置之前<code>management.endpoints.web.exposure.include</code>，请确保暴露的执行器不包含敏感信息和/或通过将它们放在防火墙后面或通过Spring Security等方式进行保护。</p>
</blockquote>
<h4 id="跨站点请求伪造保护"><a href="#跨站点请求伪造保护" class="headerlink" title="跨站点请求伪造保护"></a>跨站点请求伪造保护</h4><p>由于Spring Boot依赖于Spring Security的默认值，因此默认情况下会启用CSRF保护。这意味着执行器端点需要<code>POST</code>（关闭和记录器端点），<code>PUT</code>或者<code>DELETE</code>在使用默认安全配置时将获得403禁止错误。</p>
<blockquote>
<p>我们建议仅在创建非浏览器客户端使用的服务时才完全禁用CSRF保护。</p>
</blockquote>
<p>有关CSRF保护的其他信息，请参阅“ <a href="https://docs.spring.io/spring-security/site/docs/5.1.4.RELEASE/reference/htmlsingle#csrf" target="_blank" rel="noopener">Spring Security参考指南”</a>。</p>
</div></div><a class="button-hover more" href="/2019/03/20/使用SpringBoot-Security/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2019 By YoungDream</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/clicklove.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>