<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="使用SpringBoot-开发Web应用程序"><meta name="keywords" content="web"><meta name="author" content="YoungDream,undefined"><meta name="copyright" content="YoungDream"><title>使用SpringBoot-开发Web应用程序【YD Blog】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!--link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!--link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!--script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"0BGAOITLJQ","apiKey":"2c864a8b4720c83c2ddfc7e53d4c1711","indexName":"article_NAME","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#开发Web应用程序"><span class="toc-number">1.</span> <span class="toc-text">开发Web应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Web-MVC框架"><span class="toc-number">1.1.</span> <span class="toc-text">Spring Web MVC框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC自动配置"><span class="toc-number">1.1.1.</span> <span class="toc-text">Spring MVC自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpMessageConverters"><span class="toc-number">1.1.2.</span> <span class="toc-text">HttpMessageConverters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义JSON序列化程序和反序列化程序"><span class="toc-number">1.1.3.</span> <span class="toc-text">自定义JSON序列化程序和反序列化程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MessageCodesResolver"><span class="toc-number">1.1.4.</span> <span class="toc-text">MessageCodesResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态内容"><span class="toc-number">1.1.5.</span> <span class="toc-text">静态内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#欢迎页面"><span class="toc-number">1.1.6.</span> <span class="toc-text">欢迎页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义Favicon"><span class="toc-number">1.1.7.</span> <span class="toc-text">自定义Favicon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路径匹配和内容协商"><span class="toc-number">1.1.8.</span> <span class="toc-text">路径匹配和内容协商</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConfigurableWebBindingInitializer"><span class="toc-number">1.1.9.</span> <span class="toc-text">ConfigurableWebBindingInitializer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板引擎"><span class="toc-number">1.1.10.</span> <span class="toc-text">模板引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#错误处理"><span class="toc-number">1.1.11.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-HATEOAS"><span class="toc-number">1.1.12.</span> <span class="toc-text">Spring HATEOAS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS支持"><span class="toc-number">1.1.13.</span> <span class="toc-text">CORS支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-WebFlux框架"><span class="toc-number">1.2.</span> <span class="toc-text">Spring WebFlux框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-WebFlux自动配置"><span class="toc-number">1.2.1.</span> <span class="toc-text">Spring WebFlux自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器"><span class="toc-number">1.2.2.</span> <span class="toc-text">带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态内容-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">静态内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板引擎-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">模板引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#错误处理-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web过滤器"><span class="toc-number">1.2.6.</span> <span class="toc-text">Web过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAX-RS-and-Jersey"><span class="toc-number">1.3.</span> <span class="toc-text">JAX-RS and Jersey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌入式Servlet容器支持"><span class="toc-number">1.4.</span> <span class="toc-text">嵌入式Servlet容器支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet，Filter和Listeners"><span class="toc-number">1.4.1.</span> <span class="toc-text">Servlet，Filter和Listeners</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet上下文初始化"><span class="toc-number">1.4.2.</span> <span class="toc-text">Servlet上下文初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServletWebServerApplicationContext"><span class="toc-number">1.4.3.</span> <span class="toc-text">ServletWebServerApplicationContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义嵌入式Servlet容器"><span class="toc-number">1.4.4.</span> <span class="toc-text">自定义嵌入式Servlet容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSP限制"><span class="toc-number">1.4.5.</span> <span class="toc-text">JSP限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌入式Reactive-Server支持"><span class="toc-number">1.5.</span> <span class="toc-text">嵌入式Reactive Server支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactive-Server资源配置"><span class="toc-number">1.6.</span> <span class="toc-text">Reactive Server资源配置</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">YoungDream</div><div class="author-info-description">正忙着优秀~~~</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/qq994300880" target="_blank">GitHub<i class="icon-dot bg-color4"></i></a><a class="links-button button-hover" href="http://wpa.qq.com/msgrd?v=3&amp;uin=994300880&amp;site=qq&amp;menu=yes" target="_blank">QQ<i class="icon-dot bg-color6"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">98</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">73</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">15</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">YD Blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">使用SpringBoot-开发Web应用程序</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-03-20 | 更新于 2019-03-30</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/web/">web</a></div></div></div><div class="main-content"><h2 id="开发Web应用程序"><a href="#开发Web应用程序" class="headerlink" title="开发Web应用程序"></a>开发Web应用程序</h2><p>Spring Boot非常适合Web应用程序开发。您可以使用嵌入式Tomcat，Jetty，Undertow或Netty创建自包含的HTTP服务器。大多数Web应用程序使用该<code>spring-boot-starter-web</code>模块快速启动和运行。您还可以选择使用该<code>spring-boot-starter-webflux</code>模块构建响应式Web应用程序 。</p>
<p>如果您还没有开发Spring Boot Web应用程序，可以按照“Hello World！”进行操作。“ <em>入门”</em>部分中的示例 。</p>
<a id="more"></a>
<h3 id="Spring-Web-MVC框架"><a href="#Spring-Web-MVC框架" class="headerlink" title="Spring Web MVC框架"></a>Spring Web MVC框架</h3><p>在<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">SpringWeb MVC框架</a>（通常简称为“SpringMVC”）是一个丰富的“模型视图控制器” Web框架。Spring MVC允许您创建特殊<code>@Controller</code>或<code>@RestController</code>bean来处理传入的HTTP请求。控制器中的方法通过使用<code>@RequestMapping</code>注释映射到HTTP 。</p>
<p>以下代码显示了<code>@RestController</code>为JSON数据提供服务的典型代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="meta">@RequestMapping</span>（value =“/ users”）</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RequestMapping</span>（value =“/ &#123;user&#125;”，method = RequestMethod.GET）</span><br><span class="line">	 <span class="keyword">public</span> User getUser（ <span class="meta">@PathVariable</span> Long user）&#123;</span><br><span class="line">		 <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>（value =“/ &#123;user&#125; / customers”，method = RequestMethod.GET） </span><br><span class="line">	List &lt;Customer&gt; getUserCustomers（ <span class="meta">@PathVariable</span> Long user）&#123;</span><br><span class="line">		 <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>（value =“/ &#123;user&#125;”，method = RequestMethod.DELETE）</span><br><span class="line">	 <span class="keyword">public</span> User deleteUser（ <span class="meta">@PathVariable</span> Long user）&#123;</span><br><span class="line">		 <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring MVC是核心Spring Framework的一部分，详细信息可在<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">参考文档中找到</a>。也有涵盖Spring MVC中提供一些指南<a href="https://spring.io/guides" target="_blank" rel="noopener">spring.io/guides</a>。</p>
<h4 id="Spring-MVC自动配置"><a href="#Spring-MVC自动配置" class="headerlink" title="Spring MVC自动配置"></a>Spring MVC自动配置</h4><p>Spring Boot为Spring MVC提供自动配置，适用于大多数应用程序。</p>
<p>自动配置在Spring的默认值之上添加了以下功能：</p>
<ul>
<li>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>豆类。</li>
<li>支持提供静态资源，包括对WebJars的支持（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">本文档稍后介绍</a>））。</li>
<li>自动注册<code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code>豆类。</li>
<li>支持<code>HttpMessageConverters</code>（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-message-converters" target="_blank" rel="noopener">本文档后面部分</a>）。</li>
<li>自动注册<code>MessageCodesResolver</code>（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-message-codes" target="_blank" rel="noopener">本文档后面部分</a>）。</li>
<li>静态<code>index.html</code>支持。</li>
<li>自定义<code>Favicon</code>支持（<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-favicon" target="_blank" rel="noopener">本文档稍后介绍</a>）。</li>
<li>自动使用<code>ConfigurableWebBindingInitializer</code>bean（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-web-binding-initializer" target="_blank" rel="noopener">本文档稍后介绍</a>）。</li>
</ul>
<p>如果您想保留Spring Boot MVC功能并且想要添加其他 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC配置</a>（拦截器，格式化程序，视图控制器和其他功能），您可以添加自己的<code>@Configuration</code>类类型<code>WebMvcConfigurer</code>但<strong>不需要</strong> <code>@EnableWebMvc</code>。如果您希望提供，或的 自定义实例<code>RequestMappingHandlerMapping</code>，则可以声明 实例以提供此类组件。<code>RequestMappingHandlerAdapter`</code>ExceptionHandlerExceptionResolver<code></code>WebMvcRegistrationsAdapter`</p>
<p>如果您想完全控制Spring MVC，可以添加自己的<code>@Configuration</code> 注释<code>@EnableWebMvc</code>。</p>
<h4 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h4><p>Spring MVC使用该<code>HttpMessageConverter</code>接口来转换HTTP请求和响应。明智的默认设置包含在开箱即用中。例如，对象可以自动转换为JSON（通过使用Jackson库）或XML（如果可用，则使用Jackson XML扩展，或者如果Jackson XML扩展不可用，则使用JAXB）。默认情况下，字符串是以编码的<code>UTF-8</code>。</p>
<p>如果需要添加或自定义转换器，可以使用Spring Boot的 <code>HttpMessageConverters</code>类，如下面的清单所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">		HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HttpMessageConverter</code>上下文中存在的任何bean都将添加到转换器列表中。您也可以以相同的方式覆盖默认转换器。</p>
<h4 id="自定义JSON序列化程序和反序列化程序"><a href="#自定义JSON序列化程序和反序列化程序" class="headerlink" title="自定义JSON序列化程序和反序列化程序"></a>自定义JSON序列化程序和反序列化程序</h4><p>如果您使用Jackson序列化和反序列化JSON数据，您可能希望编写自己的类<code>JsonSerializer</code>和<code>JsonDeserializer</code>类。自定义序列化程序通常 <a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers" target="_blank" rel="noopener">通过模块向Jackson注册</a>，但Spring Boot提供了另一种<code>@JsonComponent</code>注释，可以更容易地直接注册Spring Beans。</p>
<p>您可以<code>@JsonComponent</code>直接使用注释<code>JsonSerializer</code>或 <code>JsonDeserializer</code>实现。您还可以在包含序列化程序/反序列化程序作为内部类的类上使用它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.jackson.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的所有<code>@JsonComponent</code>豆子都会<code>ApplicationContext</code>自动在杰克逊注册。因为<code>@JsonComponent</code>是元注释<code>@Component</code>，所以通常的组件扫描规则适用。</p>
<p>春季启动也提供 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java" target="_blank" rel="noopener"><code>JsonObjectSerializer</code></a>和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java" target="_blank" rel="noopener"><code>JsonObjectDeserializer</code></a>基础类，序列化对象时提供标准版本的杰克逊有用的替代。见 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html" target="_blank" rel="noopener"><code>JsonObjectSerializer</code></a>和<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html" target="_blank" rel="noopener"><code>JsonObjectDeserializer</code></a>在Javadoc了解详情。</p>
<h4 id="MessageCodesResolver"><a href="#MessageCodesResolver" class="headerlink" title="MessageCodesResolver"></a>MessageCodesResolver</h4><p>Spring MVC有一个生成错误代码的策略，用于从绑定错误中呈现错误消息：<code>MessageCodesResolver</code>。如果设置了<code>spring.mvc.message-codes-resolver.format</code>财产<code>PREFIX_ERROR_CODE</code>或 <code>POSTFIX_ERROR_CODE</code>春季启动为您创建一个（见枚举<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html" target="_blank" rel="noopener"><code>DefaultMessageCodesResolver.Format</code></a>）。</p>
<h4 id="静态内容"><a href="#静态内容" class="headerlink" title="静态内容"></a>静态内容</h4><p>默认情况下，Spring Boot从类路径中的<code>/static</code>（ <code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>）目录或者根目录中提供静态内容<code>ServletContext</code>。它使用<code>ResourceHttpRequestHandler</code>Spring MVC，以便您可以通过添加自己<code>WebMvcConfigurer</code>的<code>addResourceHandlers</code>方法来修改该行为并覆盖该 方法。</p>
<p>在独立的Web应用程序中，容器中的默认servlet也会启用，并作为后备，从<code>ServletContext</code>if 的根目录提供内容，决定不处理它。大多数情况下，这不会发生（除非你修改默认的MVC配置），因为Spring总是可以通过它来处理请求 <code>DispatcherServlet</code>。</p>
<p>默认情况下，会映射资源<code>/**</code>，但您可以使用该<code>spring.mvc.static-path-pattern</code>属性对其进行调整 。例如，重新定位所有资源 <code>/resources/**</code>可以实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.static-path-pattern = /resources/**</span><br></pre></td></tr></table></figure>
<p>您还可以使用该<code>spring.resources.static-locations</code>属性自定义静态资源位置 （将默认值替换为目录位置列表）。根Servlet上下文路径<code>&quot;/&quot;</code>也会自动添加为位置。</p>
<p>除了前面提到的“标准”静态资源位置之外，还为<a href="https://www.webjars.org/" target="_blank" rel="noopener">Webjars内容</a>制作了一个特例。具有路径的任何资源 <code>/webjars/**</code>都是从jar文件提供的，如果它们以Webjars格式打包的话。</p>
<blockquote>
<p><code>src/main/webapp</code>如果您的应用程序打包为jar，请不要使用该目录。虽然这个目录是一个通用的标准，它的工作原理<strong>只是</strong>war的包装，它是默默大多数构建工具忽略，如果你生成一个jar。</p>
</blockquote>
<p>Spring Boot还支持Spring MVC提供的高级资源处理功能，允许使用缓存破坏静态资源或使用与Webjars无关的URL。</p>
<p>要为Webjars使用版本无关的URL，请添加<code>webjars-locator-core</code>依赖项。然后声明你的Webjar。以jQuery为例，添加 <code>&quot;/webjars/jquery/jquery.min.js&quot;</code>结果 <code>&quot;/webjars/jquery/x.y.z/jquery.min.js&quot;</code>。<code>x.y.z</code>Webjar版本在哪里。</p>
<blockquote>
<p>如果你使用JBoss，你需要声明<code>webjars-locator-jboss-vfs</code> 依赖而不是<code>webjars-locator-core</code>。否则，所有Webjars都会解析为 <code>404</code>。</p>
</blockquote>
<p>要使用缓存清除，以下配置会为所有静态资源配置缓存清除解决方案，从而有效地<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>在URL中添加内容哈希，例如 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled = true</span><br><span class="line">spring.resources.chain.strategy.content.paths = /**</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于<code>ResourceUrlEncodingFilter</code>为Thymeleaf和FreeMarker自动配置了资源链接，因此在运行时会在模板中重写 。您应该在使用JSP时手动声明此过滤器。目前不支持其他模板引擎，但可以使用自定义模板宏/帮助程序和使用 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html" target="_blank" rel="noopener"><code>ResourceUrlProvider</code></a>。</p>
</blockquote>
<p>使用（例如）JavaScript模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也得到支持并可以合并的原因。“固定”策略在URL中添加静态版本字符串而不更改文件名，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.chain.strategy.content.enabled = true</span><br><span class="line">spring.resources.chain.strategy.content.paths = / **</span><br><span class="line">spring.resources.chain.strategy.fixed.enabled = true</span><br><span class="line">spring.resources.chain.strategy.fixed .paths = / js / lib /</span><br><span class="line">spring.resources.chain.strategy.fixed.version = v12</span><br></pre></td></tr></table></figure>
<p>使用此配置，JavaScript模块位于<code>&quot;/js/lib/&quot;</code>使用固定版本控制策略（<code>&quot;/v12/js/lib/mymodule.js&quot;</code>），而其他资源仍使用内容one（<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>）。</p>
<p>有关更多支持选项，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java" target="_blank" rel="noopener"><code>ResourceProperties</code></a> </p>
<blockquote>
<p>此功能已在专门的<a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources" target="_blank" rel="noopener">博客文章</a>和Spring Framework的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources" target="_blank" rel="noopener">参考文档中</a>进行了详细描述 。</p>
</blockquote>
<h4 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h4><p>Spring Boot支持静态和模板化欢迎页面。它首先<code>index.html</code>在配置的静态内容位置中查找 文件。如果找不到，则查找<code>index</code>模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。</p>
<h4 id="自定义Favicon"><a href="#自定义Favicon" class="headerlink" title="自定义Favicon"></a>自定义Favicon</h4><p>Spring Boot <code>favicon.ico</code>在配置的静态内容位置和类路径的根（按此顺序）中查找a 。如果存在这样的文件，它将自动用作应用程序的favicon。</p>
<h4 id="路径匹配和内容协商"><a href="#路径匹配和内容协商" class="headerlink" title="路径匹配和内容协商"></a>路径匹配和内容协商</h4><p>Spring MVC可以通过查看请求路径并将其与应用程序中定义的映射（例如，<code>@GetMapping</code> Controller方法上的注释）相匹配，将传入的HTTP请求映射到处理程序。</p>
<p>Spring Boot默认选择禁用后缀模式匹配，这意味着请求<code>&quot;GET /projects/spring-boot.json&quot;</code>不会与<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>映射匹配 。这被认为是<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match" target="_blank" rel="noopener">Spring MVC应用程序</a>的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match" target="_blank" rel="noopener">最佳实践</a>。对于没有发送正确“接受”请求标头的HTTP客户端，此功能在过去主要有用; 我们需要确保将正确的内容类型发送给客户端。如今，内容协商更加可靠。</p>
<p>还有其他方法可以处理不一致发送正确“接受”请求标头的HTTP客户端。我们可以使用查询参数来确保将请求<code>&quot;GET /projects/spring-boot?format=json&quot;</code> 映射到<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>以下内容，而不是使用后缀匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-parameter = true</span><br><span class="line"></span><br><span class="line">＃我们可以更改参数名称，默认为“format”：</span><br><span class="line">＃spring.mvc.contentnegotiation.parameter-name = myparam</span><br><span class="line"></span><br><span class="line">＃我们还可以注册其他文件扩展名/媒体类型：</span><br><span class="line">spring.mvc.contentnegotiation.media-types.markdown = text/markdown</span><br></pre></td></tr></table></figure>
<p>如果您了解警告并仍希望您的应用程序使用后缀模式匹配，则需要以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-path-extension = true</span><br><span class="line">spring.mvc.pathmatch.use-suffix-pattern = true</span><br></pre></td></tr></table></figure>
<p>或者，不是打开所有后缀模式，而是仅支持已注册的后缀模式更安全：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-path-extension = true</span><br><span class="line">spring.mvc.pathmatch.use-registered-suffix-pattern = true</span><br><span class="line"></span><br><span class="line">＃您还可以注册其他文件扩展名/媒体类型：</span><br><span class="line">＃spring.mvc.contentnegotiation.media-types.adoc = text/asciidoc</span><br></pre></td></tr></table></figure>
<h4 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h4><p>Spring MVC使用一个 <code>WebBindingInitializer</code>来初始化<code>WebDataBinder</code>特定请求。如果你自己创建<code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot会自动配置Spring MVC来使用它。</p>
<h4 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>除REST Web服务外，您还可以使用Spring MVC来提供动态HTML内容。Spring MVC支持各种模板技术，包括Thymeleaf，FreeMarker和JSP。此外，许多其他模板引擎包括他们自己的Spring MVC集成。</p>
<p>Spring Boot包括对以下模板引擎的自动配置支持：</p>
<ul>
<li><a href="https://freemarker.apache.org/docs/" target="_blank" rel="noopener">FreeMarker</a></li>
<li><a href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine" target="_blank" rel="noopener">Groovy</a></li>
<li><a href="http://www.thymeleaf.org/" target="_blank" rel="noopener">Thymeleaf</a></li>
<li><a href="https://mustache.github.io/" target="_blank" rel="noopener">Mustache</a></li>
</ul>
<blockquote>
<p>如果可能，应该避免使用JSP。将它们与嵌入式servlet容器一起使用时有几个 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-jsp-limitations" target="_blank" rel="noopener">已知的限制</a>。</p>
</blockquote>
<p>当您使用其中一个模板引擎和默认配置时，您的模板将自动从中获取<code>src/main/resources/templates</code>。</p>
<blockquote>
<p>根据您运行应用程序的方式，IntelliJ IDEA以不同方式对类路径进行排序。从主方法在IDE中运行应用程序会导致与使用Maven或Gradle或其打包的jar运行应用程序时的顺序不同。这可能导致Spring Boot无法在类路径中找到模板。如果遇到此问题，可以在IDE中重新排序类路径，以便首先放置模块的类和资源。或者，您可以配置模板前缀以搜索<code>templates</code>类路径上的每个目录，如下所示： <code>classpath*:/templates/</code>。</p>
</blockquote>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>默认情况下，Spring Boot提供了一个<code>/error</code>以合理方式处理所有错误的映射，并将其注册为servlet容器中的“全局”错误页面。对于计算机客户端，它会生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，有一个“whitelabel”错误视图，它以HTML格式呈现相同的数据（以自定义它，添加<code>View</code>解析后的数据<code>error</code>）。要完全替换默认行为，您可以实现 <code>ErrorController</code>并注册该类型的bean定义，或者添加类型的bean <code>ErrorAttributes</code>以使用现有机制但替换内容。</p>
<blockquote>
<p>在<code>BasicErrorController</code>可以用作自定义基类 <code>ErrorController</code>。如果要为新内容类型添加处理程序（默认情况下是<code>text/html</code>专门处理并为其他所有内容提供后备），这将特别有用。为此，请扩展<code>BasicErrorController</code>，添加<code>@RequestMapping</code>具有<code>produces</code>属性的公共方法 ，并创建新类型的bean。</p>
</blockquote>
<p>您还可以定义一个带注释的类，<code>@ControllerAdvice</code>以自定义要为特定控制器和/或异常类型返回的JSON文档，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(basePackageClasses = AcmeController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeControllerAdvice</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(YourException.class)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> CustomErrorType(status.value(), ex.getMessage()), status);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> HttpStatus <span class="title">getStatus</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Integer statusCode = (Integer) request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>);</span><br><span class="line">		<span class="keyword">if</span> (statusCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，如果<code>YourException</code>由在同一个包中定义的控制器抛出，则使用POJO <code>AcmeController</code>的JSON表示<code>CustomErrorType</code>而不是<code>ErrorAttributes</code>表示。</p>
<p><strong>自定义错误页面</strong></p>
<p>如果要显示给定状态代码的自定义HTML错误页面，可以将文件添加到文件<code>/error</code>夹。错误页面可以是静态HTML（即，添加到任何静态资源文件夹下），也可以使用模板构建。文件名应该是确切的状态代码或系列掩码。</p>
<p>例如，要映射<code>404</code>到静态HTML文件，您的文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
<p>要<code>5xx</code>使用FreeMarker模板映射所有错误，您的文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.ftl</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure>
<p>对于更复杂的映射，您还可以添加实现该<code>ErrorViewResolver</code> 接口的bean ，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorViewResolver</span> <span class="keyword">implements</span> <span class="title">ErrorViewResolver</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Use the request or status to optionally return a ModelAndView</span></span><br><span class="line">		<span class="keyword">return</span> ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以使用常规的Spring MVC功能，例如 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers" target="_blank" rel="noopener"><code>@ExceptionHandler</code>方法</a>和 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice" target="_blank" rel="noopener"><code>@ControllerAdvice</code></a>。在 <code>ErrorController</code>随后拿起任何未处理的异常。</p>
<p><strong>映射Spring MVC之外的错误页面</strong></p>
<p>对于不使用Spring MVC的应用程序，可以使用该<code>ErrorPageRegistrar</code> 接口直接注册<code>ErrorPages</code>。这种抽象直接与底层嵌入式servlet容器一起工作，即使你没有Spring MVC也可以工作 <code>DispatcherServlet</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ErrorPageRegistrar <span class="title">errorPageRegistrar</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MyErrorPageRegistrar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorPageRegistrar</span> <span class="keyword">implements</span> <span class="title">ErrorPageRegistrar</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</span><br><span class="line">		registry.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">"/400"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您注册的<code>ErrorPage</code>路径最终由a处理<code>Filter</code> （与一些非Spring Web框架（如Jersey和Wicket）一样），那么 <code>Filter</code>必须将其显式注册为<code>ERROR</code>调度程序，如以下示例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">	registration.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">	...</span><br><span class="line">	registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class="line">	<span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，默认值<code>FilterRegistrationBean</code>不包括<code>ERROR</code>调度程序类型。</p>
<p>小心：当部署到servlet容器时，Spring Boot使用其错误页面过滤器将具有错误状态的请求转发到相应的错误页面。如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0及更高版本在成功完成servlet的服务方法后提交响应。您应该通过设置<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>为禁用此行为 <code>false</code>。</p>
<h4 id="Spring-HATEOAS"><a href="#Spring-HATEOAS" class="headerlink" title="Spring HATEOAS"></a>Spring HATEOAS</h4><p>如果您开发使用超媒体的RESTful API，Spring Boot为Spring HATEOAS提供自动配置，适用于大多数应用程序。自动配置取代了使用<code>@EnableHypermediaSupport</code>和注册多个bean 的需要，以便于构建基于超媒体的应用程序，包括 <code>LinkDiscoverers</code>（用于客户端支持）和<code>ObjectMapper</code>配置为正确编组响应到所需表示的响应。的<code>ObjectMapper</code>是通过设置各种定制的<code>spring.jackson.*</code>属性，或者，如果存在的话，通过一个<code>Jackson2ObjectMapperBuilder</code>豆。</p>
<p>您可以使用控制Spring HATEOAS的配置 <code>@EnableHypermediaSupport</code>。请注意，这样做会禁用<code>ObjectMapper</code>前面描述的自定义。</p>
<h4 id="CORS支持"><a href="#CORS支持" class="headerlink" title="CORS支持"></a>CORS支持</h4><p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank" rel="noopener">跨源资源共享</a> （CORS）是<a href="https://caniuse.com/#feat=cors" target="_blank" rel="noopener">大多数浏览器</a>实现 的<a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener">W3C规范</a>，允许您以灵活的方式指定授权何种跨域请求，而不是使用一些安全性较低且功能较弱的方法，如IFRAME或JSONP。</p>
<p>从版本4.2开始，Spring MVC <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#cors" target="_blank" rel="noopener">支持CORS</a>。 在Spring Boot应用程序中使用带有 注释的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#controller-method-cors-configuration" target="_blank" rel="noopener">控制器方法CORS配置</a><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html" target="_blank" rel="noopener"><code>@CrossOrigin</code></a>不需要任何特定配置。 可以通过使用自定义方法注册bean 来定义<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#global-cors-configuration" target="_blank" rel="noopener">全局CORS配置</a>，如以下示例所示：<code>WebMvcConfigurer</code>. <code>addCorsMappings(CorsRegistry)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">				registry.addMapping(<span class="string">"/api/**"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring-WebFlux框架"><a href="#Spring-WebFlux框架" class="headerlink" title="Spring WebFlux框架"></a>Spring WebFlux框架</h3><p>Spring WebFlux是Spring Framework 5.0中引入的新的响应式Web框架。与Spring MVC不同，它不需要Servlet API，完全异步且无阻塞，并 通过<a href="https://projectreactor.io/" target="_blank" rel="noopener">Reactor项目</a>实现<a href="http://www.reactive-streams.org/" target="_blank" rel="noopener">Reactive Streams</a>规范。</p>
<p>Spring WebFlux有两种版本：基于功能和注释。基于注释的注释非常接近Spring MVC模型，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/&#123;user&#125;/customers"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Flux&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">deleteUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“WebFlux.fn”是功能变体，它将路由配置与请求的实际处理分开，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">monoRouterFunction</span><span class="params">(UserHandler userHandler)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> route(GET(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">                .and(accept(APPLICATION_JSON)), userHandler::getUser)</span><br><span class="line">				.andRoute(GET(<span class="string">"/&#123;user&#125;/customers"</span>)</span><br><span class="line">                .and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)</span><br><span class="line">				.andRoute(DELETE(<span class="string">"/&#123;user&#125;"</span>)</span><br><span class="line">                .and(accept(APPLICATION_JSON)), userHandler::deleteUser);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHandler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUserCustomers</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">deleteUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WebFlux是Spring Framework的一部分，详细信息可在其 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn" target="_blank" rel="noopener">参考文档中找到</a>。</p>
<blockquote>
<p>您可以根据需要定义任意数量的<code>RouterFunction</code>bean来模块化路由器的定义。如果需要应用优先级，可以订购Bean。</p>
</blockquote>
<p>要开始，请将<code>spring-boot-starter-webflux</code>模块添加到您的应用程序中。</p>
<blockquote>
<p>在应用程序中添加两个<code>spring-boot-starter-web</code>和<code>spring-boot-starter-webflux</code>模块会导致Spring Boot自动配置Spring MVC，而不是WebFlux。选择此行为是因为许多Spring开发人员<code>spring-boot-starter-webflux</code> 在其Spring MVC应用程序中添加了使用被动的<code>WebClient</code>。您仍然可以通过将所选应用程序类型设置为来强制执行您的选择<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code>。</p>
</blockquote>
<h4 id="Spring-WebFlux自动配置"><a href="#Spring-WebFlux自动配置" class="headerlink" title="Spring WebFlux自动配置"></a>Spring WebFlux自动配置</h4><p>Spring Boot为Spring WebFlux提供自动配置，适用于大多数应用程序。</p>
<p>自动配置在Spring的默认值之上添加了以下功能：</p>
<ul>
<li>为for <code>HttpMessageReader</code>和<code>HttpMessageWriter</code>实例配置编解码器（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webflux-httpcodecs" target="_blank" rel="noopener">在本文档后面介绍</a>）。</li>
<li>支持提供静态资源，包括对WebJars的支持（ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">在本文档后面介绍</a>）。</li>
</ul>
<p>如果你想保留Spring Boot WebFlux功能，并且想要添加额外的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#web-reactive" target="_blank" rel="noopener">WebFlux配置</a>，你可以添加自己的 <code>@Configuration</code>类类<code>WebFluxConfigurer</code>但<strong>不需要</strong><code>@EnableWebFlux</code>。</p>
<p>如果您想完全控制Spring WebFlux，可以添加自己的 <code>@Configuration</code>注释<code>@EnableWebFlux</code>。</p>
<h4 id="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器"><a href="#带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器" class="headerlink" title="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器"></a>带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</h4><p>Spring WebFlux使用<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>接口转换HTTP请求和响应。<code>CodecConfigurer</code>通过查看类路径中可用的库，它们被配置为具有合理的默认值。</p>
<p>Spring Boot通过使用<code>CodecCustomizer</code>实例进一步自定义。例如，<code>spring.jackson.*</code>配置密钥应用于Jackson编解码器。</p>
<p>如果需要添加或自定义编解码器，可以创建自定义<code>CodecCustomizer</code> 组件，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.codec.CodecCustomizer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CodecCustomizer <span class="title">myCodecCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> codecConfigurer -&gt; &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以利用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-json-components" target="_blank" rel="noopener">Boot的自定义JSON序列化程序和反序列化程序</a>。</p>
<h4 id="静态内容-1"><a href="#静态内容-1" class="headerlink" title="静态内容"></a>静态内容</h4><p>默认情况下，Spring Boot从类路径中名为<code>/static</code>（ <code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>）的目录中提供静态内容。它使用<code>ResourceWebHandler</code>Spring WebFlux，以便您可以通过添加自己<code>WebFluxConfigurer</code>的<code>addResourceHandlers</code>方法来修改该行为并覆盖该方法。</p>
<p>默认情况下，映射资源<code>/**</code>，但您可以通过设置<code>spring.webflux.static-path-pattern</code>属性来调整它 。例如，重新定位所有资源 <code>/resources/**</code>可以实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.webflux.static-path-pattern = /resources/**</span><br></pre></td></tr></table></figure>
<p>您还可以使用自定义静态资源位置 <code>spring.resources.static-locations</code>。这样做会将默认值替换为目录位置列表。如果这样做，默认的欢迎页面检测将切换到您的自定义位置。因此，如果<code>index.html</code>您的任何位置在启动时存在，则它是应用程序的主页。</p>
<p>除了前面列出的“标准”静态资源位置之外，还为<a href="https://www.webjars.org/" target="_blank" rel="noopener">Webjars内容</a>制作了一个特例。具有路径的任何资源 <code>/webjars/**</code>都是从jar文件提供的，如果它们以Webjars格式打包的话。</p>
<blockquote>
<p>Spring WebFlux应用程序并不严格依赖于Servlet API，因此它们不能作为war文件部署，也不能使用该<code>src/main/webapp</code>目录。</p>
</blockquote>
<h4 id="模板引擎-1"><a href="#模板引擎-1" class="headerlink" title="模板引擎"></a>模板引擎</h4><p>除REST Web服务外，您还可以使用Spring WebFlux来提供动态HTML内容。Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker和Mustache。</p>
<p>Spring Boot包括对以下模板引擎的自动配置支持：</p>
<ul>
<li><a href="https://freemarker.apache.org/docs/" target="_blank" rel="noopener">FreeMarker</a></li>
<li><a href="http://www.thymeleaf.org/" target="_blank" rel="noopener">Thymeleaf</a></li>
<li><a href="https://mustache.github.io/" target="_blank" rel="noopener">Mustache</a></li>
</ul>
<p>当您使用其中一个模板引擎和默认配置时，您的模板将自动从中获取<code>src/main/resources/templates</code>。</p>
<h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>Spring Boot提供了<code>WebExceptionHandler</code>一种以合理的方式处理所有错误的方法。它在处理顺序中的位置紧接在WebFlux提供的处理程序之前，这些处理程序被认为是最后一个。对于计算机客户端，它会生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，有一个“whitelabel”错误处理程序，它以HTML格式呈现相同的数据。您还可以提供自己的HTML模板来显示错误（请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webflux-error-handling-custom-error-pages" target="_blank" rel="noopener">下一节</a>）。</p>
<p>自定义此功能的第一步通常涉及使用现有机制，但替换或扩充错误内容。为此，您可以添加类型的bean <code>ErrorAttributes</code>。</p>
<p>要更改错误处理行为，可以实现<code>ErrorWebExceptionHandler</code>并注册该类型的bean定义。由于a <code>WebExceptionHandler</code>是一个非常低级的，Spring Boot还提供了一个方便<code>AbstractErrorWebExceptionHandler</code>的让你以WebFlux功能方式处理错误，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomErrorWebExceptionHandler</span> <span class="keyword">extends</span> <span class="title">AbstractErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在这里定义构造函数</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> RouterFunctions</span><br><span class="line">				.route(aPredicate, aHandler)</span><br><span class="line">				.andRoute(anotherPredicate, anotherHandler);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获得更完整的图片，您还可以<code>DefaultErrorWebExceptionHandler</code> 直接子类化并覆盖特定方法。</p>
<p><strong>自定义错误页面</strong></p>
<p>如果要显示给定状态代码的自定义HTML错误页面，可以将文件添加到文件<code>/error</code>夹。错误页面可以是静态HTML（即，添加到任何静态资源文件夹下）或使用模板构建。文件名应该是确切的状态代码或系列掩码。</p>
<p>例如，要映射<code>404</code>到静态HTML文件，您的文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
<p>要<code>5xx</code>使用<code>Mustache</code>模板映射所有错误，您的文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.mustache</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Web过滤器"><a href="#Web过滤器" class="headerlink" title="Web过滤器"></a>Web过滤器</h4><p>Spring WebFlux提供了一个<code>WebFilter</code>可以实现过滤HTTP请求 - 响应交换的接口。<code>WebFilter</code>在应用程序上下文中找到的bean将自动用于过滤每个交换。</p>
<p>如果过滤器的顺序很重要，则可以实现<code>Ordered</code>或注释<code>@Order</code>。Spring Boot自动配置可以为您配置Web过滤器。执行此操作时，将使用下表中显示的订单：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Web Filter</th>
<th style="text-align:center">Order</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>MetricsWebFilter</code></td>
<td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>WebFilterChainProxy</code> （spring Security）</td>
<td style="text-align:center"><code>-100</code></td>
</tr>
<tr>
<td style="text-align:center"><code>HttpTraceWebFilter</code></td>
<td style="text-align:center"><code>Ordered.LOWEST_PRECEDENCE - 10</code></td>
</tr>
</tbody>
</table>
<h3 id="JAX-RS-and-Jersey"><a href="#JAX-RS-and-Jersey" class="headerlink" title="JAX-RS and Jersey"></a>JAX-RS and Jersey</h3><p>如果您更喜欢REST端点的JAX-RS编程模型，则可以使用其中一个可用的实现而不是Spring MVC。<a href="https://jersey.github.io/" target="_blank" rel="noopener">Jersey</a>和 <a href="https://cxf.apache.org/" target="_blank" rel="noopener">Apache CXF</a>开箱即用。CXF要求您在应用程序上下文中注册<code>Servlet</code>或<code>Filter</code>作为其注册<code>@Bean</code>。Jersey有一些原生的Spring支持，因此我们还在Spring Boot中为它提供了自动配置支持以及启动器。</p>
<p>要开始使用Jersey，请将其<code>spring-boot-starter-jersey</code>作为依赖项包含在内，然后您需要一个注册所有端点<code>@Bean</code>的类型<code>ResourceConfig</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyConfig</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JerseyConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		register(Endpoint.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Jersey对扫描可执行档案的支持相当有限。例如，它无法扫描<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#deployment-install" target="_blank" rel="noopener">完全可执行jar文件</a>中的包中或<code>WEB-INF/classes</code>运行可执行war文件时的端点。为避免此限制，<code>packages</code>不应使用该方法，并且应使用该<code>register</code>方法单独注册端点，如上例所示。</p>
</blockquote>
<p>对于更高级的自定义，您还可以注册实现的任意数量的bean <code>ResourceConfigCustomizer</code>。</p>
<p>所有已注册的端点都应<code>@Components</code>使用HTTP资源注释（<code>@GET</code>和其他），如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GET</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Endpoint</code>是Spring <code>@Component</code>，它的生命周期由Spring管理，您可以使用<code>@Autowired</code>注释注入依赖项并使用<code>@Value</code> 注释注入外部配置。默认情况下，Jersey servlet已注册并映射到<code>/*</code>。您可以通过添加<code>@ApplicationPath</code>到您 的地图来更改映射<code>ResourceConfig</code>。</p>
<p>默认情况下，Jersey被设置为 名为<code>@Bean</code>的类型的Servlet 。默认情况下，servlet是懒惰地初始化的，但您可以通过设置来自定义该行为。您可以通过创建具有相同名称的bean来禁用或覆盖该bean。您还可以通过设置（在这种情况下，替换或覆盖是）来使用过滤器而不是servlet 。过滤器有一个，您可以设置。通过使用指定属性的映射，可以为servlet和过滤器注册提供init参数。<code>ServletRegistrationBean</code> <code>jerseyServletRegistration</code> <code>spring.jersey.servlet.load-on-startup</code> <code>spring.jersey.type=filter</code> <code>@Bean</code> <code>jerseyFilterRegistration</code> <code>@Order</code> <code>spring.jersey.filter.order</code> <code>spring.jersey.init.*</code></p>
<p>有一个<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/spring-boot-sample-jersey" target="_blank" rel="noopener">Jersey sample</a>以便您可以看到如何设置。</p>
<h3 id="嵌入式Servlet容器支持"><a href="#嵌入式Servlet容器支持" class="headerlink" title="嵌入式Servlet容器支持"></a>嵌入式Servlet容器支持</h3><p>Spring Boot包括对嵌入式<a href="https://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat</a>， <a href="https://www.eclipse.org/jetty/" target="_blank" rel="noopener">Jetty</a>和<a href="http://undertow.io/" target="_blank" rel="noopener">Undertow</a>服务器的支持。大多数开发人员使用适当的“Starter”来获取完全配置的实例。默认情况下，嵌入式服务器侦听端口上的HTTP请求<code>8080</code>。</p>
<blockquote>
<p>如果您选择在<a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a>上使用Tomcat ，请注意，默认情况下，临时目录用于存储已编译的JSP，文件上载等。<code>tmpwatch</code>应用程序运行时可能会删除此目录，从而导致失败。要避免此行为，您可能希望自定义<code>tmpwatch</code>配置，以便<code>tomcat.*</code>不删除或配置目录以<code>server.tomcat.basedir</code>使嵌入式Tomcat使用其他位置。</p>
</blockquote>
<h4 id="Servlet，Filter和Listeners"><a href="#Servlet，Filter和Listeners" class="headerlink" title="Servlet，Filter和Listeners"></a>Servlet，Filter和Listeners</h4><p>使用嵌入式servlet容器时，可以<code>HttpSessionListener</code>通过使用Spring bean或扫描Servlet组件，从Servlet规范中注册servlet，过滤器和所有侦听器（如HttpSessionListener）。</p>
<p><strong>将Servlet，过滤器和监听器注册为Spring Bean</strong></p>
<p>作为Spring bean的任何<code>Servlet</code>，<code>Filter</code>或者servlet <code>*Listener</code>实例都是在嵌入式容器中注册的。如果要从<code>application.properties</code>配置期间引用值，这可能特别方便。</p>
<p>默认情况下，如果上下文仅包含一个Servlet，则将其映射到<code>/</code>。在多个servlet bean的情况下，bean名称用作路径前缀。过滤器映射到 <code>/*</code>。</p>
<p>如果以公约为基础测绘不够灵活，你可以使用 <code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>以及 <code>ServletListenerRegistrationBean</code>类的完全控制。</p>
<p>Spring Boot附带了许多可以定义Filter bean的自动配置。以下是过滤器及其各自顺序的一些示例（较低的顺序值表示较高的优先级）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ServletFilter</th>
<th style="text-align:center">Order</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>OrderedCharacterEncodingFilter</code></td>
<td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE</code></td>
</tr>
<tr>
<td style="text-align:center"><code>WebMvcMetricsFilter</code></td>
<td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ErrorPageFilter</code></td>
<td style="text-align:center"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td>
</tr>
<tr>
<td style="text-align:center"><code>HttpTraceFilter</code></td>
<td style="text-align:center"><code>Ordered.LOWEST_PRECEDENCE - 10</code></td>
</tr>
</tbody>
</table>
<p>将Filter beans无序放置通常是安全的。</p>
<p>如果需要特定的顺序，则应避免配置读取请求主体的过滤器<code>Ordered.HIGHEST_PRECEDENCE</code>，因为它可能违反应用程序的字符编码配置。如果Servlet过滤器包装请求，则应使用小于或等于的顺序进行配置 <code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>。</p>
<h4 id="Servlet上下文初始化"><a href="#Servlet上下文初始化" class="headerlink" title="Servlet上下文初始化"></a>Servlet上下文初始化</h4><p>嵌入式servlet容器不直接执行Servlet 3.0+ <code>javax.servlet.ServletContainerInitializer</code>接口或Spring<code>org.springframework.web.WebApplicationInitializer</code>接口。这是一个有意的设计决策，旨在降低设计在战争中运行的第三方库可能会破坏Spring Boot应用程序的风险。</p>
<p>如果需要在Spring Boot应用程序中执行servlet上下文初始化，则应注册实现该<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的bean 。单一<code>onStartup</code>方法提供对s的访问，<code>ServletContext</code>并且如果需要，可以轻松地用作现有的适配器<code>WebApplicationInitializer</code>。</p>
<p><strong>扫描Servlet，过滤器和侦听器</strong></p>
<p>当使用嵌入式容器中，类自动登记注释有 <code>@WebServlet</code>，<code>@WebFilter</code>和<code>@WebListener</code>可以通过使用被使能 <code>@ServletComponentScan</code>。</p>
<blockquote>
<p><code>@ServletComponentScan</code> 在独立容器中没有任何效果，而是使用容器的内置发现机制。</p>
</blockquote>
<h4 id="ServletWebServerApplicationContext"><a href="#ServletWebServerApplicationContext" class="headerlink" title="ServletWebServerApplicationContext"></a>ServletWebServerApplicationContext</h4><p>在引擎盖下，Spring Boot使用不同类型的<code>ApplicationContext</code>嵌入式servlet容器支持。该<code>ServletWebServerApplicationContext</code>是一种特殊类型的<code>WebApplicationContext</code>通过搜索单说引导自身 <code>ServletWebServerFactory</code>豆。通常是<code>TomcatServletWebServerFactory</code>,,<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code> 已经自动配置。</p>
<blockquote>
<p>您通常不需要了解这些实现类。大多数应用程序都自动配置，并适当的<code>ApplicationContext</code>和 <code>ServletWebServerFactory</code>以您的名义创建。</p>
</blockquote>
<h4 id="自定义嵌入式Servlet容器"><a href="#自定义嵌入式Servlet容器" class="headerlink" title="自定义嵌入式Servlet容器"></a>自定义嵌入式Servlet容器</h4><p>可以使用Spring <code>Environment</code> 属性配置公共servlet容器设置。通常，您将在<code>application.properties</code> 文件中定义属性。</p>
<p>常用服务器设置包括：</p>
<ul>
<li>网络设置：侦听传入HTTP请求的端口（<code>server.port</code>），要绑定的接口地址<code>server.address</code>等等。</li>
<li>会话设置：会话是持久性（<code>server.servlet.session.persistence</code>），会话超时（<code>server.servlet.session.timeout</code>），会话数据（<code>server.servlet.session.store-dir</code>）的位置以及会话cookie配置（<code>server.servlet.session.cookie.*</code>）。</li>
<li>错误管理：错误页面的位置（<code>server.error.path</code>）等。</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-ssl" target="_blank" rel="noopener">SSL</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#how-to-enable-http-response-compression" target="_blank" rel="noopener">HTTP compression</a></li>
</ul>
<p>Spring Boot尽可能尝试公开常见设置，但这并不总是可行。对于这些情况，专用命名空间提供特定于服务器的自定义（请参阅 <code>server.tomcat</code>和<code>server.undertow</code>）。例如， 可以使用嵌入式servlet容器的特定功能配置<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-configure-accesslogs" target="_blank" rel="noopener">访问日志</a>。</p>
<blockquote>
<p>请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java" target="_blank" rel="noopener"><code>ServerProperties</code></a>课程以获取完整列表。</p>
</blockquote>
<p><strong>程序化定制</strong></p>
<p>如果需要以编程方式配置嵌入式servlet容器，可以注册实现该<code>WebServerFactoryCustomizer</code>接口的Spring bean 。 <code>WebServerFactoryCustomizer</code>提供对其的访问 <code>ConfigurableServletWebServerFactory</code>，其中包括许多自定义setter方法。以下示例以编程方式设置端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationBean</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">		server.setPort(<span class="number">9000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>并且<code>UndertowServletWebServerFactory</code> 是专用变体，<code>ConfigurableServletWebServerFactory</code>分别为Tomcat，Jetty和Undertow提供了额外的自定义setter方法。</p>
</blockquote>
<p><strong>直接自定义ConfigurableServletWebServerFactory</strong></p>
<p>如果前面的定制技术太有限，你可以注册 <code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或 <code>UndertowServletWebServerFactory</code> bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableServletWebServerFactory <span class="title">webServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">	factory.setPort(<span class="number">9000</span>);</span><br><span class="line">	factory.setSessionTimeout(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">	factory.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">"/notfound.html"</span>));</span><br><span class="line">	<span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为许多配置选项提供了Setter。如果您需要做一些更具异国情调的事情，还会提供一些受保护的方法“挂钩”。有关详细信息，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html" target="_blank" rel="noopener">源代码文档</a>。</p>
<h4 id="JSP限制"><a href="#JSP限制" class="headerlink" title="JSP限制"></a>JSP限制</h4><p>运行使用嵌入式servlet容器的Spring Boot应用程序（并打包为可执行存档）时，JSP支持存在一些限制。</p>
<ul>
<li>使用Jetty和Tomcat，如果使用war包装，它应该可以工作。可执行的war将在启动时运行<code>java -jar</code>，并且也可以部署到任何标准容器。使用可执行jar时不支持JSP。</li>
<li>Undertow不支持JSP。</li>
<li>创建自定义<code>error.jsp</code>页面不会覆盖<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-error-handling" target="_blank" rel="noopener">错误处理</a>的默认视图 。 应该使用<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-error-handling-custom-error-pages" target="_blank" rel="noopener">自定义错误页面</a>。</li>
</ul>
<p>有一个<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp" target="_blank" rel="noopener">JSP示例</a>以便您可以看到如何设置。</p>
<h3 id="嵌入式Reactive-Server支持"><a href="#嵌入式Reactive-Server支持" class="headerlink" title="嵌入式Reactive Server支持"></a>嵌入式Reactive Server支持</h3><p>Spring Boot包括对以下嵌入式响应式Web服务器的支持：Reactor Netty，Tomcat，Jetty和Undertow。大多数开发人员使用适当的“Starter”来获取完全配置的实例。默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p>
<h3 id="Reactive-Server资源配置"><a href="#Reactive-Server资源配置" class="headerlink" title="Reactive Server资源配置"></a>Reactive Server资源配置</h3><p>在自动配置Reactor Netty或Jetty服务器时，Spring Boot将创建特定的bean，为服务器实例提供HTTP资源：<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>。</p>
<p>默认情况下，这些资源也将与Reactor Netty和Jetty客户端共享，以获得最佳性能，具体如下：</p>
<ul>
<li>相同的技术用于服务器和客户端</li>
<li>客户端实例是使用<code>WebClient.Builder</code>Spring Boot自动配置的bean 构建的</li>
</ul>
<p>开发人员可以通过提供自定义<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>bean 来覆盖Jetty和Reactor Netty的资源配置- 这将应用于客户端和服务器。</p>
<p>您可以在<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-webclient-runtime" target="_blank" rel="noopener">WebClient Runtime</a>部分中了解有关客户端资源配置的更多信息 。</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YoungDream</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="http://qq994300880.github.io/2019/03/20/使用SpringBoot-开发Web应用程序/">http://qq994300880.github.io/2019/03/20/使用SpringBoot-开发Web应用程序/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://qq994300880.github.io">YD Blog</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/03/20/使用SpringBoot-Security/"><i class="fas fa-angle-left">&nbsp;</i><span>使用SpringBoot-Security</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/03/20/使用SpringBoot-JSON/"><span>使用SpringBoot-JSON</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script><div id="gitalk-container"></div><script src="/js/gitalk.js"></script></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2019 By YoungDream</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/clicklove.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>