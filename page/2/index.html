<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="正忙着优秀~~~"><meta name="keywords" content><meta name="author" content="YoungDream,undefined"><meta name="copyright" content="YoungDream"><title>小小搬砖工【YD Blog】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon-16x16-user.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!--link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!--link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!--script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"0BGAOITLJQ","apiKey":"2c864a8b4720c83c2ddfc7e53d4c1711","indexName":"article_NAME","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/user.jpg"></div><div class="author-info-name">YoungDream</div><div class="author-info-description">正忙着优秀~~~</div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/qq994300880" target="_blank">GitHub<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="http://wpa.qq.com/msgrd?v=3&amp;uin=994300880&amp;site=qq&amp;menu=yes" target="_blank">QQ<i class="icon-dot bg-color9"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">51</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">63</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">8</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">YD Blog</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-通过HTTP进行监控和管理/">使用SpringBoot-通过HTTP进行监控和管理</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/http/">http</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/management/">management</a></div></div><div class="post-content"><div class="main-content content"><h1 id="通过HTTP进行监控和管理"><a href="#通过HTTP进行监控和管理" class="headerlink" title="通过HTTP进行监控和管理"></a>通过HTTP进行监控和管理</h1><p>如果您正在开发Web应用程序，则Spring Boot Actuator会自动配置所有已启用的端点以通过HTTP公开。默认约定是使用<code>id</code>前缀<code>/actuator</code>为URL路径的端点。例如，<code>health</code>暴露为<code>/actuator/health</code>。提示：Spring MVC，Spring WebFlux和Jersey本身支持Actuator。</p>
<h2 id="自定义管理端点路径"><a href="#自定义管理端点路径" class="headerlink" title="自定义管理端点路径"></a>自定义管理端点路径</h2><p>有时，定制管理端点的前缀很有用。例如，您的应用程序可能已<code>/actuator</code>用于其他目的。您可以使用该<code>management.endpoints.web.base-path</code>属性更改管理端点的前缀，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.base-path=/manage</span><br></pre></td></tr></table></figure>
<p>上面的<code>application.properties</code>示例将端点更改 <code>/actuator/{id}</code>为<code>/manage/{id}</code>（例如<code>/manage/info</code>）。</p>
<blockquote>
<p>除非管理端口已经被配置为 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-customizing-management-server-port" target="_blank" rel="noopener">通过使用不同的HTTP端口暴露端点</a>，<code>management.endpoints.web.base-path</code>相对于<code>server.servlet.context-path</code>。如果<code>management.server.port</code>配置， <code>management.endpoints.web.base-path</code>则相对于<code>management.server.servlet.context-path</code>。</p>
</blockquote>
<p>如果要将端点映射到其他路径，可以使用该 <code>management.endpoints.web.path-mapping</code>属性。</p>
<p>以下示例重新映射<code>/actuator/health</code>到<code>/healthcheck</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.base-path=/</span><br><span class="line">management.endpoints.web.path-mapping.health=healthcheck</span><br></pre></td></tr></table></figure>
<h2 id="自定义Management-Server端口"><a href="#自定义Management-Server端口" class="headerlink" title="自定义Management Server端口"></a>自定义Management Server端口</h2><p>使用默认HTTP端口公开管理端点是基于云的部署的明智选择。但是，如果您的应用程序在您自己的数据中心内运行，您可能更喜欢使用不同的HTTP端口公开端点。</p>
<p>您可以设置该<code>management.server.port</code>属性以更改HTTP端口，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.server.port=8081</span><br></pre></td></tr></table></figure>
<h2 id="配置管理特定的SSL"><a href="#配置管理特定的SSL" class="headerlink" title="配置管理特定的SSL"></a>配置管理特定的SSL</h2><p>配置为使用自定义端口时，还可以使用各种<code>management.server.ssl.*</code>属性为管理服务器配置自己的SSL 。例如，这样做可以在主应用程序使用HTTPS时通过HTTP使管理服务器可用，如以下属性设置所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8443</span><br><span class="line">server.ssl.enabled=true</span><br><span class="line">server.ssl.key-store=classpath:store.jks</span><br><span class="line">server.ssl.key-password=secret</span><br><span class="line">management.server.port=8080</span><br><span class="line">management.server.ssl.enabled=false</span><br></pre></td></tr></table></figure>
<p>或者，主服务器和管理服务器都可以使用SSL但具有不同的密钥库，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.port=8443</span><br><span class="line">server.ssl.enabled=true</span><br><span class="line">server.ssl.key-store=classpath:main.jks</span><br><span class="line">server.ssl.key-password=secret</span><br><span class="line">management.server.port=8080</span><br><span class="line">management.server.ssl.enabled=true</span><br><span class="line">management.server.ssl.key-store=classpath:management.jks</span><br><span class="line">management.server.ssl.key-password=secret</span><br></pre></td></tr></table></figure>
<h2 id="自定义管理服务器地址"><a href="#自定义管理服务器地址" class="headerlink" title="自定义管理服务器地址"></a>自定义管理服务器地址</h2><p>您可以通过设置<code>management.server.address</code>属性来自定义管理端点可用的地址。如果您只想在内部或面向操作的网络上侦听或仅侦听来自的连接，那么这样做会非常有用 <code>localhost</code>。</p>
<blockquote>
<p>仅当端口与主服务器端口不同时，才能侦听不同的地址。</p>
</blockquote>
<p>以下示例<code>application.properties</code>不允许远程管理连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.server.port=8081</span><br><span class="line">management.server.address=127.0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="禁用HTTP端点"><a href="#禁用HTTP端点" class="headerlink" title="禁用HTTP端点"></a>禁用HTTP端点</h2><p>如果您不想通过HTTP公开端点，可以将管理端口设置为 <code>-1</code>，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.server.port=-1</span><br></pre></td></tr></table></figure>
<p>这也可以使用<code>management.endpoints.web.exposure.exclude</code>属性来实现，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.exclude=*</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-通过HTTP进行监控和管理/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-endpoints/">使用SpringBoot-endpoints</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/endpoint/">endpoint</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h1><p>通过执行器端点，您可以监控应用程序并与之交互。Spring Boot包含许多内置端点，允许您添加自己的端点。例如， <code>health</code>端点提供基本的应用程序健康信息。</p>
<p>可以<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-enabling-endpoints" target="_blank" rel="noopener">启用或禁用</a>每个端点。它控制是否创建端点并且其bean存在于应用程序上下文中。要进行远程访问，还必须<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints" target="_blank" rel="noopener">通过JMX或HTTP公开</a>端点 。大多数应用程序选择HTTP，其中端点的ID以及前缀<code>/actuator</code> 映射到URL。例如，默认情况下，<code>health</code>端点映射到 <code>/actuator/health</code>。</p>
<p>可以使用以下与技术无关的端点：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认情况下启用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>auditevents</code></td>
<td style="text-align:center">公开当前应用程序的审核事件信息。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>beans</code></td>
<td style="text-align:center">显示应用程序中所有Spring bean的完整列表。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>caches</code></td>
<td style="text-align:center">暴露可用的缓存。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>conditions</code></td>
<td style="text-align:center">显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>configprops</code></td>
<td style="text-align:center">显示所有的整理列表<code>@ConfigurationProperties</code>。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>env</code></td>
<td style="text-align:center">露出Spring的属性<code>ConfigurableEnvironment</code>。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>flyway</code></td>
<td style="text-align:center">显示已应用的任何Flyway数据库迁移。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>health</code></td>
<td style="text-align:center">显示应用健康信息。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>httptrace</code></td>
<td style="text-align:center">显示HTTP跟踪信息（默认情况下，最后100个HTTP请求 - 响应交换）。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>info</code></td>
<td style="text-align:center">显示任意应用信息。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>integrationgraph</code></td>
<td style="text-align:center">显示Spring Integration图。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>loggers</code></td>
<td style="text-align:center">显示和修改应用程序中记录器的配置。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>liquibase</code></td>
<td style="text-align:center">显示已应用的任何Liquibase数据库迁移。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>metrics</code></td>
<td style="text-align:center">显示当前应用程序的“指标”信息。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>mappings</code></td>
<td style="text-align:center">显示所有<code>@RequestMapping</code>路径的整理列表。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>scheduledtasks</code></td>
<td style="text-align:center">显示应用程序中的计划任务。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>sessions</code></td>
<td style="text-align:center">允许从Spring Session支持的会话存储中检索和删除用户会话。使用Spring Session对响应式Web应用程序的支持时不可用。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>shutdown</code></td>
<td style="text-align:center">允许应用程序正常关闭。</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>threaddump</code></td>
<td style="text-align:center">执行线程转储。</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<p>如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">默认情况下启用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>heapdump</code></td>
<td style="text-align:center">返回<code>hprof</code>堆转储文件。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>jolokia</code></td>
<td style="text-align:center">通过HTTP公开JMX bean（当Jolokia在类路径上时，不适用于WebFlux）。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>logfile</code></td>
<td style="text-align:center">返回日志文件的内容（如果已设置<code>logging.file</code>或<code>logging.path</code>属性）。支持使用HTTP <code>Range</code>标头检索部分日志文件的内容。</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>prometheus</code></td>
<td style="text-align:center">以可以由Prometheus服务器抓取的格式公开指标。</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<p>要了解有关Actuator端点及其请求和响应格式的更多信息，请参阅单独的API文档（<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//html" target="_blank" rel="noopener">HTML</a>或 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf" target="_blank" rel="noopener">PDF</a>）。</p>
<h2 id="启用端点"><a href="#启用端点" class="headerlink" title="启用端点"></a>启用端点</h2><p>默认情况下，<code>shutdown</code>启用除除以外的所有端点。要配置端点的启用，请使用其<code>management.endpoint.&lt;id&gt;.enabled</code>属性。以下示例启用<code>shutdown</code>端点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoint.shutdown.enabled=true</span><br></pre></td></tr></table></figure>
<p>如果您希望端点启用是选择加入而不是选择退出，请将该<code>management.endpoints.enabled-by-default</code>属性设置 为<code>false</code>并使用各个端点 <code>enabled</code>属性重新加入。以下示例启用<code>info</code>端点并禁用所有其他端点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.enabled-by-default=false</span><br><span class="line">management.endpoint.info.enabled=true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>已完全从应用程序上下文中删除已禁用的端点。如果只想更改端点所暴露的技术，请改用 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints" target="_blank" rel="noopener"><code>include</code>和<code>exclude</code>属性</a> 。</p>
</blockquote>
<h2 id="公开端点"><a href="#公开端点" class="headerlink" title="公开端点"></a>公开端点</h2><p>由于端点可能包含敏感信息，因此应仔细考虑何时公开它们。下表显示了内置端点的默认曝光：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">JMX</th>
<th style="text-align:center">WEB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>auditevents</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>beans</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>caches</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>conditions</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>configprops</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>env</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>flyway</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>health</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>heapdump</code></td>
<td style="text-align:center">N / A</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>httptrace</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>info</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center"><code>integrationgraph</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>jolokia</code></td>
<td style="text-align:center">N / A</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>logfile</code></td>
<td style="text-align:center">N / A</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>loggers</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>liquibase</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>metrics</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>mappings</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>prometheus</code></td>
<td style="text-align:center">N / A</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>scheduledtasks</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>sessions</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>shutdown</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center"><code>threaddump</code></td>
<td style="text-align:center">是</td>
<td style="text-align:center">没有</td>
</tr>
</tbody>
</table>
<p>要更改端点暴露，使用下面的特定技术<code>include</code>和 <code>exclude</code>特性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">默认</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>management.endpoints.jmx.exposure.exclude</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>management.endpoints.jmx.exposure.include</code></td>
<td style="text-align:center"><code>*</code></td>
</tr>
<tr>
<td style="text-align:center"><code>management.endpoints.web.exposure.exclude</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>management.endpoints.web.exposure.include</code></td>
<td style="text-align:center"><code>info, health</code></td>
</tr>
</tbody>
</table>
<p>该<code>include</code>属性列出了公开的端点的ID。该<code>exclude</code> 属性列出了不应公开的端点的ID。该<code>exclude</code> 属性优先于该<code>include</code>属性。无论<code>include</code>和<code>exclude</code> 性能可与端点ID列表进行配置。</p>
<p>例如，要停止通过JMX公开所有端点并仅显示端点<code>health</code>和 <code>info</code>端点，请使用以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.jmx.exposure.include=health,info</span><br></pre></td></tr></table></figure>
<p><code>*</code>可用于选择所有端点。例如，要通过HTTP公开除了<code>env</code>和<code>beans</code>端点之外的所有内容，请使用以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoints.web.exposure.exclude=env,beans</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>*</code> 在YAML中有特殊含义，因此如果要包含（或排除）所有端点，请务必添加引号，如以下示例所示：</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您的申请是公开的，我们强烈建议您也 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#production-ready-endpoints-security" target="_blank" rel="noopener">保护您的终端</a>。</p>
</blockquote>
<blockquote>
<p>如果要在公开端点时实现自己的策略，可以注册<code>EndpointFilter</code>bean。</p>
</blockquote>
<h2 id="保护HTTP端点"><a href="#保护HTTP端点" class="headerlink" title="保护HTTP端点"></a>保护HTTP端点</h2><p>您应该像使用任何其他敏感URL一样注意保护HTTP端点。如果存在Spring Security，则默认使用Spring Security的内容协商策略来保护端点。例如，如果您希望为HTTP端点配置自定义安全性，只允许具有特定角色的用户访问它们，Spring Boot提供了一些<code>RequestMatcher</code>可以与Spring Security结合使用的方便对象。</p>
<p>典型的Spring Security配置可能类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActuatorSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class="line">				.anyRequest().hasRole(<span class="string">"ENDPOINT_ADMIN"</span>)</span><br><span class="line">				.and()</span><br><span class="line">			.httpBasic();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例用于<code>EndpointRequest.toAnyEndpoint()</code>将请求与任何端点进行匹配，然后确保所有端点都具有该<code>ENDPOINT_ADMIN</code>角色。其他几种匹配方法也可用<code>EndpointRequest</code>。请参阅API文档（<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//html" target="_blank" rel="noopener">HTML</a>或 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf" target="_blank" rel="noopener">PDF</a>详细信息，）。</p>
<p>如果在防火墙后面部署应用程序，您可能希望无需身份验证即可访问所有执行器端点。您可以通过更改<code>management.endpoints.web.exposure.include</code>属性来执行此操作 ，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anagement.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure>
<p>此外，如果存在Spring Security，则需要添加自定义安全配置，以允许对端点进行未经身份验证的访问，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActuatorSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class="line">			.anyRequest().permitAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置端点"><a href="#配置端点" class="headerlink" title="配置端点"></a>配置端点</h2><p>端点自动缓存对不带任何参数的读取操作的响应。要配置端点缓存响应的时间量，请使用其<code>cache.time-to-live</code>属性。以下示例将<code>beans</code>端点缓存的生存时间设置为10秒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoint.beans.cache.time-to-live=10s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前缀<code>management.endpoint.&lt;name&gt;</code>用于唯一标识正在配置的端点。</p>
</blockquote>
<blockquote>
<p>在进行经过身份验证的HTTP请求时，Principal会将其视为端点的输入，因此不会缓存响应。</p>
</blockquote>
<h2 id="用于执行器Web端点的超媒体"><a href="#用于执行器Web端点的超媒体" class="headerlink" title="用于执行器Web端点的超媒体"></a>用于执行器Web端点的超媒体</h2><p>添加了“发现页面”，其中包含指向所有端点的链接。<code>/actuator</code>默认情况下，“发现页面”可用。</p>
<p>配置自定义管理上下文路径后，“发现页面”会自动从<code>/actuator</code>管理上下文的根目录移动。例如，如果管理上下文路径是<code>/management</code>，则可以从中获取发现页面<code>/management</code>。当管理上下文路径设置为时<code>/</code>，将禁用发现页面以防止与其他映射冲突的可能性。</p>
<h2 id="CORS支持"><a href="#CORS支持" class="headerlink" title="CORS支持"></a>CORS支持</h2><p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank" rel="noopener">跨源资源共享</a> （CORS）是一种<a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener">W3C规范</a>，允许您以灵活的方式指定授权的跨域请求类型。如果您使用Spring MVC或Spring WebFlux，则可以配置Actuator的Web端点以支持此类方案。</p>
<p>默认情况下禁用CORS支持，并且仅<code>management.endpoints.web.cors.allowed-origins</code>在设置了属性后才启用CORS支持 。以下配置允许<code>GET</code>和<code>POST</code>来自<code>example.com</code>域的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.cors.allowed-origins=http://example.com</span><br><span class="line">management.endpoints.web.cors.allowed-methods=GET,POST</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关 选项的完整列表，请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java" target="_blank" rel="noopener">CorsEndpointProperties</a>。</p>
</blockquote>
<h2 id="实现自定义端点"><a href="#实现自定义端点" class="headerlink" title="实现自定义端点"></a>实现自定义端点</h2><p>如果您添加带<code>@Bean</code>注释的<code>@Endpoint</code>注释<code>@ReadOperation</code>，通过JMX 注释的任何方法 <code>@WriteOperation</code>，或者<code>@DeleteOperation</code>通过JMX自动公开，以及在Web应用程序中也通过HTTP 添加注释。可以使用Jersey，Spring MVC或Spring WebFlux通过HTTP公开端点。</p>
<p>您还可以使用<code>@JmxEndpoint</code>或 编写特定于技术的端点<code>@WebEndpoint</code>。这些端点仅限于各自的技术。例如，<code>@WebEndpoint</code>仅通过HTTP而不是通过JMX公开。</p>
<p>您可以使用<code>@EndpointWebExtension</code>和 编写特定于技术的扩展<code>@EndpointJmxExtension</code>。通过这些注释，您可以提供特定于技术的操作来扩充现有端点。</p>
<p>最后，如果您需要访问特定于Web框架的功能，则可以实现Servlet或Spring <code>@Controller</code>和<code>@RestController</code>端点，但代价是它们不能通过JMX或使用不同的Web框架。</p>
<h3 id="接收输入"><a href="#接收输入" class="headerlink" title="接收输入"></a>接收输入</h3><p>端点上的操作通过其参数接收输入。通过Web公开时，这些参数的值取自URL的查询参数和JSON请求体。通过JMX公开时，参数将映射到MBean操作的参数。默认情况下需要参数。它们可以通过注释使它们成为可选的<a href="mailto:`@org.springframework.lang.Nullable" target="_blank" rel="noopener">`@org.springframework.lang.Nullable</a>`。</p>
<p>JSON请求正文中的每个根属性都可以映射到端点的参数。考虑以下JSON请求正文：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span>: <span class="string">"test"</span>,</span><br><span class="line">	<span class="attr">"counter"</span>: <span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以用于调用，需要一个写操作<code>String name</code>和<code>int counter</code> 参数。</p>
<blockquote>
<p>由于端点与技术无关，因此只能在方法签名中指定简单类型。特别是不支持使用定义<code>name</code>和<code>counter</code>属性的自定义类型声明单个参数 。</p>
</blockquote>
<blockquote>
<p>为了允许输入映射到操作方法的参数，应该编译实现端点的Java代码<code>-parameters</code>，并且应该编译实现端点的Kotlin代码<code>-java-parameters</code>。如果您使用的是Spring Boot的Gradle插件，或者您正在使用Maven和 <code>spring-boot-starter-parent</code>。</p>
</blockquote>
<h4 id="输入类型转换"><a href="#输入类型转换" class="headerlink" title="输入类型转换"></a>输入类型转换</h4><p>如有必要，传递给端点操作方法的参数将自动转换为所需类型。在调用操作方法之前，通过JMX或HTTP请求接收的输入将使用实例转换为所需类型<code>ApplicationConversionService</code>。</p>
<h3 id="自定义Web端点"><a href="#自定义Web端点" class="headerlink" title="自定义Web端点"></a>自定义Web端点</h3><p>操作<code>@Endpoint</code>，<code>@WebEndpoint</code>或者<code>@EndpointWebExtension</code>使用新泽西州，Spring MVC，或Spring WebFlux通过HTTP自动曝光。</p>
<h4 id="Web端点请求谓词"><a href="#Web端点请求谓词" class="headerlink" title="Web端点请求谓词"></a>Web端点请求谓词</h4><p>为Web暴露的端点上的每个操作自动生成请求谓词。</p>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>谓词的路径由端点的ID和Web暴露的端点的基本路径确定。默认基本路径是<code>/actuator</code>。例如，具有ID的端点<code>sessions</code>将<code>/actuator/sessions</code>用作谓词中的路径。</p>
<p>可以通过用操作方法的一个或多个参数注释来进一步定制路径<code>@Selector</code>。这样的参数作为路径变量添加到路径谓词中。调用端点操作时，变量的值将传递给操作方法。</p>
<h4 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h4><p>谓词的HTTP方法由操作类型决定，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">HTTP Method</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@ReadOperation</code></td>
<td style="text-align:center"><code>GET</code></td>
</tr>
<tr>
<td style="text-align:center"><code>@WriteOperation</code></td>
<td style="text-align:center"><code>POST</code></td>
</tr>
<tr>
<td style="text-align:center"><code>@DeleteOperation</code></td>
<td style="text-align:center"><code>DELETE</code></td>
</tr>
</tbody>
</table>
<h4 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h4><p>对于使用请求主体的<code>@WriteOperation</code>（HTTP <code>POST</code>），谓词的consumemes子句是<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。对于所有其他操作，consumemes子句为空。</p>
<h4 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h4><p>的产生谓词子句可以由被确定<code>produces</code>的属性 <code>@DeleteOperation</code>，<code>@ReadOperation</code>和<code>@WriteOperation</code>注解。该属性是可选的。如果未使用，则自动确定produce子句。</p>
<p>如果操作方法返回<code>void</code>或者<code>Void</code>produce子句为空。如果操作方法返回a <code>org.springframework.core.io.Resource</code>，则generate子句为<code>application/octet-stream</code>。对于所有其他操作，produce子句是 <code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。</p>
<h4 id="Web端点响应状态"><a href="#Web端点响应状态" class="headerlink" title="Web端点响应状态"></a>Web端点响应状态</h4><p>端点操作的默认响应状态取决于操作类型（读取，写入或删除）以及操作返回的内容（如果有）。</p>
<p>A <code>@ReadOperation</code>返回一个值，响应状态为200（OK）。如果它未返回值，则响应状态将为404（未找到）。</p>
<p>如果a <code>@WriteOperation</code>或<code>@DeleteOperation</code>返回值，则响应状态将为200（OK）。如果它没有返回值，则响应状态将为204（无内容）。</p>
<p>如果在没有必需参数的情况下调用操作，或者使用无法转换为所需类型的参数，则不会调用操作方法，并且响应状态将为400（错误请求）。</p>
<h4 id="Web端点范围请求"><a href="#Web端点范围请求" class="headerlink" title="Web端点范围请求"></a>Web端点范围请求</h4><p>HTTP范围请求可用于请求部分HTTP资源。使用Spring MVC或Spring Web Flux时，返回<code>org.springframework.core.io.Resource</code> 自动支持范围请求的操作。</p>
<blockquote>
<p>使用Jersey时不支持范围请求。</p>
</blockquote>
<h4 id="Web端点安全"><a href="#Web端点安全" class="headerlink" title="Web端点安全"></a>Web端点安全</h4><p>Web端点或特定于Web的端点扩展上的操作可以接收当前<code>java.security.Principal</code>或 <code>org.springframework.boot.actuate.endpoint.SecurityContext</code>作为方法参数。前者通常与<code>@Nullable</code>经过身份验证和未经身份验证的用户一起使用以提供不同的行为。后者通常用于使用其<code>isUserInRole(String)</code>方法执行授权检查。</p>
<h3 id="Servlet端点"><a href="#Servlet端点" class="headerlink" title="Servlet端点"></a>Servlet端点</h3><p><code>Servlet</code>可以公开为通过实施与注释的一个类的端点 <code>@ServletEndpoint</code>也实现<code>Supplier&lt;EndpointServlet&gt;</code>。Servlet端点提供与Servlet容器更深层次的集成，但代价是可移植性。它们旨在用于将现有的公开<code>Servlet</code>作为端点。对于新端点，应尽可能优先使用<code>@Endpoint</code>和<code>@WebEndpoint</code>注释。</p>
<h3 id="控制器端点"><a href="#控制器端点" class="headerlink" title="控制器端点"></a>控制器端点</h3><p><code>@ControllerEndpoint</code>并且<code>@RestControllerEndpoint</code>可用于实现仅由Spring MVC或Spring WebFlux公开的端点。使用Spring MVC和Spring WebFlux的标准注释（例如<code>@RequestMapping</code> 和）映射方法<code>@GetMapping</code>，并将端点的ID用作路径的前缀。控制器端点提供与Spring的Web框架更深层次的集成，但代价是可移植性。的<code>@Endpoint</code>和<code>@WebEndpoint</code>注解应当优选只要有可能。</p>
<h2 id="健康信息"><a href="#健康信息" class="headerlink" title="健康信息"></a>健康信息</h2><p>您可以使用运行状况信息来检查正在运行的应用程序的状态。监视软件经常使用它在生产系统出现故障时提醒某人。<code>health</code>端点公开的信息取决于<code>management.endpoint.health.show-details</code>可以使用以下值之一配置的 属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>never</code></td>
<td style="text-align:center">细节永远不会显示。</td>
</tr>
<tr>
<td style="text-align:center"><code>when-authorized</code></td>
<td style="text-align:center">详细信息仅向授权用户显示。可以使用配置授权角色 <code>management.endpoint.health.roles</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>always</code></td>
<td style="text-align:center">向所有用户显示详细信息。</td>
</tr>
</tbody>
</table>
<p>默认值为<code>never</code>。当用户处于一个或多个端点的角色时，将被视为已获得授权。如果端点没有配置角色（默认值），则认为所有经过身份验证的用户都已获得授权。可以使用<code>management.endpoint.health.roles</code>属性配置角色。</p>
<blockquote>
<p>如果您已保护应用程序并希望使用<code>always</code>，则安全配置必须允许对经过身份验证和未经身份验证的用户访问运行状况终结点。</p>
</blockquote>
<p>健康信息是从a的内容中收集的 （默认情况下，所有 实例都在你的Spring中定义.Spring Boot包括一些自动配置 ，你也可以编写自己的。默认情况下，最终的系统状态是通过对状态进行排序得出的从每个 基于状态的有序列表上。在排序列表中的第一个状态用作总体运行状况。如果没有回报是已知的一个状态 ，一个是使用状态。</p>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicatorRegistry.java" target="_blank" rel="noopener"><code>HealthIndicatorRegistry</code></a><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java" target="_blank" rel="noopener"><code>HealthIndicator</code></a><code>ApplicationContext</code> <code>HealthIndicators</code> <code>HealthAggregator</code> <code>HealthIndicator</code> <code>HealthIndicator</code> <code>HealthAggregator</code> <code>UNKNOWN</code></p>
<blockquote>
<p>该<code>HealthIndicatorRegistry</code>可用于注册和在运行时注销卫生指标。</p>
</blockquote>
<h3 id="自动配置的HealthIndicators"><a href="#自动配置的HealthIndicators" class="headerlink" title="自动配置的HealthIndicators"></a>自动配置的HealthIndicators</h3><p><code>HealthIndicators</code>适当时，Spring Boot会自动配置以下内容：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraHealthIndicator.java" target="_blank" rel="noopener"><code>CassandraHealthIndicator</code></a></td>
<td style="text-align:center">检查Cassandra数据库是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseHealthIndicator.java" target="_blank" rel="noopener"><code>CouchbaseHealthIndicator</code></a></td>
<td style="text-align:center">检查Couchbase群集是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/system/DiskSpaceHealthIndicator.java" target="_blank" rel="noopener"><code>DiskSpaceHealthIndicator</code></a></td>
<td style="text-align:center">检查磁盘空间不足。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jdbc/DataSourceHealthIndicator.java" target="_blank" rel="noopener"><code>DataSourceHealthIndicator</code></a></td>
<td style="text-align:center">检查是否可以获得连接<code>DataSource</code>。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchHealthIndicator.java" target="_blank" rel="noopener"><code>ElasticsearchHealthIndicator</code></a></td>
<td style="text-align:center">检查Elasticsearch集群是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/influx/InfluxDbHealthIndicator.java" target="_blank" rel="noopener"><code>InfluxDbHealthIndicator</code></a></td>
<td style="text-align:center">检查InfluxDB服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jms/JmsHealthIndicator.java" target="_blank" rel="noopener"><code>JmsHealthIndicator</code></a></td>
<td style="text-align:center">检查JMS代理是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mail/MailHealthIndicator.java" target="_blank" rel="noopener"><code>MailHealthIndicator</code></a></td>
<td style="text-align:center">检查邮件服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoHealthIndicator.java" target="_blank" rel="noopener"><code>MongoHealthIndicator</code></a></td>
<td style="text-align:center">检查Mongo数据库是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jHealthIndicator.java" target="_blank" rel="noopener"><code>Neo4jHealthIndicator</code></a></td>
<td style="text-align:center">检查Neo4j服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.java" target="_blank" rel="noopener"><code>RabbitHealthIndicator</code></a></td>
<td style="text-align:center">检查Rabbit服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisHealthIndicator.java" target="_blank" rel="noopener"><code>RedisHealthIndicator</code></a></td>
<td style="text-align:center">检查Redis服务器是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/solr/SolrHealthIndicator.java" target="_blank" rel="noopener"><code>SolrHealthIndicator</code></a></td>
<td style="text-align:center">检查Solr服务器是否已启动。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>您可以通过设置<code>management.health.defaults.enabled</code> 属性来禁用它们。</p>
</blockquote>
<h3 id="编写自定义HealthIndicators"><a href="#编写自定义HealthIndicators" class="headerlink" title="编写自定义HealthIndicators"></a>编写自定义HealthIndicators</h3><p>要提供自定义运行状况信息，可以注册实现该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java" target="_blank" rel="noopener"><code>HealthIndicator</code></a>接口的Spring bean 。您需要提供<code>health()</code>方法的实现并返回<code>Health</code> 响应。的<code>Health</code>响应应该包括一个状态，并且可以任选地包括另外的细节被显示。以下代码显示了一个示例<code>HealthIndicator</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.Health;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> errorCode = check(); <span class="comment">// perform some specific health check</span></span><br><span class="line">		<span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> Health.down().withDetail(<span class="string">"Error Code"</span>, errorCode).build();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Health.up().build();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给定的标识符<code>HealthIndicator</code>是没有<code>HealthIndicator</code>后缀的bean的名称（ 如果存在）。在前面的示例中，健康信息在名为的条目中可用<code>my</code>。</p>
</blockquote>
<p>除了Spring Boot的预定义 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/Status.java" target="_blank" rel="noopener"><code>Status</code></a>类型之外，还可以 <code>Health</code>返回<code>Status</code>表示新系统状态的自定义。在这种情况下，<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthAggregator.java" target="_blank" rel="noopener"><code>HealthAggregator</code></a>还需要提供接口的自定义实现 ，或者必须使用<code>management.health.status.order</code>配置属性配置默认实现。</p>
<p>例如，假设在您的某个实现中使用了 <code>Status</code>带代码的新代码。要配置严重性顺序，请将以下属性添加到应用程序属性：<code>FATAL`</code>HealthIndicator`</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.health.status.order=FATAL, DOWN, OUT_OF_SERVICE, UNKNOWN, UP</span><br></pre></td></tr></table></figure>
<p>在响应中的HTTP状态代码反映总体健康状况（例如， <code>UP</code>映射到200，而<code>OUT_OF_SERVICE</code>并<code>DOWN</code>映射到503）。如果通过HTTP访问运行状况端点，则可能还需要注册自定义状态映射。例如，以下属性映射<code>FATAL</code>到503（服务不可用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.health.status.http-mapping.FATAL=503</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要更多控制，可以定义自己的<code>HealthStatusHttpMapper</code>bean。</p>
</blockquote>
<p>下表显示了内置状态的默认状态映射：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">映射</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">下</td>
<td style="text-align:center">SERVICE_UNAVAILABLE（503）</td>
</tr>
<tr>
<td style="text-align:center">停止服务</td>
<td style="text-align:center">SERVICE_UNAVAILABLE（503）</td>
</tr>
<tr>
<td style="text-align:center">UP</td>
<td style="text-align:center">默认情况下没有映射，因此http状态为200</td>
</tr>
<tr>
<td style="text-align:center">未知</td>
<td style="text-align:center">默认情况下没有映射，因此http状态为200</td>
</tr>
</tbody>
</table>
<h3 id="反应性健康指标"><a href="#反应性健康指标" class="headerlink" title="反应性健康指标"></a>反应性健康指标</h3><p>对于反应式应用程序（例如使用Spring WebFlux的应用程序），<code>ReactiveHealthIndicator</code> 提供了一个非阻塞的合同来获取应用程序运行状况。与传统类似<code>HealthIndicator</code>，健康信息是从a的内容中收集的 （默认情况下，在您的。中定义的所有 和 实例都不会在弹性调度程序上执行不检查反应API的常规 。<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicatorRegistry.java" target="_blank" rel="noopener"><code>ReactiveHealthIndicatorRegistry</code></a><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java" target="_blank" rel="noopener"><code>HealthIndicator</code></a><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java" target="_blank" rel="noopener"> <code>ReactiveHealthIndicator</code></a><code>ApplicationContext</code> <code>HealthIndicator</code></p>
<blockquote>
<p>在响应式应用程序中，<code>ReactiveHealthIndicatorRegistry</code>可用于在运行时注册和取消注册运行状况指示器。</p>
</blockquote>
<p>要从反应式API提供自定义运行状况信息，您可以注册实现该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>ReactiveHealthIndicator</code></a> 接口的Spring bean 。以下代码显示了一个示例<code>ReactiveHealthIndicator</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactiveHealthIndicator</span> <span class="keyword">implements</span> <span class="title">ReactiveHealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Mono&lt;Health&gt; <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> doHealthCheck() <span class="comment">//执行一些返回Mono &lt;Health&gt; </span></span><br><span class="line">			.onErrorResume(ex -&gt; Mono.just(<span class="keyword">new</span> Health.Builder().down(ex).build())));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要自动处理错误，请考虑从中扩展 <code>AbstractReactiveHealthIndicator</code>。</p>
</blockquote>
<h3 id="自动配置的ReactiveHealthIndicators"><a href="#自动配置的ReactiveHealthIndicators" class="headerlink" title="自动配置的ReactiveHealthIndicators"></a>自动配置的ReactiveHealthIndicators</h3><p><code>ReactiveHealthIndicators</code>适当时，Spring Boot会自动配置以下内容：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>CassandraReactiveHealthIndicator</code></a></td>
<td style="text-align:center">检查Cassandra数据库是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>CouchbaseReactiveHealthIndicator</code></a></td>
<td style="text-align:center">检查Couchbase群集是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>MongoReactiveHealthIndicator</code></a></td>
<td style="text-align:center">检查Mongo数据库是否已启动。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisReactiveHealthIndicator.java" target="_blank" rel="noopener"><code>RedisReactiveHealthIndicator</code></a></td>
<td style="text-align:center">检查Redis服务器是否已启动。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>必要时，反应指标取代常规指标。此外，任何 <code>HealthIndicator</code>未明确处理的内容都会自动换行。</p>
</blockquote>
<h2 id="应用信息"><a href="#应用信息" class="headerlink" title="应用信息"></a>应用信息</h2><p>应用程序信息公开从<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java" target="_blank" rel="noopener"><code>InfoContributor</code></a>您的中定义的所有bean 收集的各种信息 <code>ApplicationContext</code>。Spring Boot包含许多自动配置的<code>InfoContributor</code>bean，您可以编写自己的bean。</p>
<h3 id="自动配置的InfoContributors"><a href="#自动配置的InfoContributors" class="headerlink" title="自动配置的InfoContributors"></a>自动配置的InfoContributors</h3><p><code>InfoContributor</code>适当时，Spring Boot会自动配置以下bean：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java" target="_blank" rel="noopener"><code>EnvironmentInfoContributor</code></a></td>
<td style="text-align:center">暴露出钥匙<code>Environment</code>下面的任何<code>info</code>钥匙。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java" target="_blank" rel="noopener"><code>GitInfoContributor</code></a></td>
<td style="text-align:center">如果<code>git.properties</code>文件可用，则公开git信息。</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java" target="_blank" rel="noopener"><code>BuildInfoContributor</code></a></td>
<td style="text-align:center">如果<code>META-INF/build-info.properties</code>文件可用，则公开构建信息。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>可以通过设置<code>management.info.defaults.enabled</code> 属性来禁用它们。</p>
</blockquote>
<h3 id="自定义应用程序信息"><a href="#自定义应用程序信息" class="headerlink" title="自定义应用程序信息"></a>自定义应用程序信息</h3><p>您可以<code>info</code>通过设置<code>info.*</code>Spring属性来自定义端点公开的数据。密钥<code>Environment</code>下的所有属性都会<code>info</code>自动显示。例如，您可以将以下设置添加到您的<code>application.properties</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.app.encoding=UTF-8</span><br><span class="line">info.app.java.source=1.8</span><br><span class="line">info.app.java.target=1.8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您可以<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-automatic-expansion" target="_blank" rel="noopener">在构建时扩展信息属性，</a>而不是对这些值进行硬编码 。</p>
<p>假设您使用Maven，您可以按如下方式重写前面的示例：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.app.encoding=@project.build.sourceEncoding@</span><br><span class="line">info.app.java.source=@java.version@</span><br><span class="line">info.app.java.target=@java.version@</span><br></pre></td></tr></table></figure>
<h3 id="Git提交信息"><a href="#Git提交信息" class="headerlink" title="Git提交信息"></a>Git提交信息</h3><p><code>info</code>端点的另一个有用功能是它能够<code>git</code>在构建项目时发布有关源代码存储库状态的信息。如果 <code>GitProperties</code>豆可用，<code>git.branch</code>，<code>git.commit.id</code>，和<code>git.commit.time</code>属性暴露出来。</p>
<blockquote>
<p>一个<code>GitProperties</code>bean是自动配置，如果一个<code>git.properties</code>文件可在classpath的根目录。有关更多详细<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-git-info" target="_blank" rel="noopener">信息，</a>请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-git-info" target="_blank" rel="noopener">生成git信息</a> ”。</p>
</blockquote>
<p>如果要显示完整的git信息（即完整内容 <code>git.properties</code>），请使用该<code>management.info.git.mode</code>属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.info.git.mode=full</span><br></pre></td></tr></table></figure>
<h3 id="构建信息"><a href="#构建信息" class="headerlink" title="构建信息"></a>构建信息</h3><p>如果<code>BuildProperties</code>bean可用，<code>info</code>端点也可以发布有关构建的信息。如果<code>META-INF/build-info.properties</code>类路径中有文件可用，则会发生这种情况。</p>
<blockquote>
<p>Maven和Gradle插件都可以生成该文件。有关更多详细<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-build-info" target="_blank" rel="noopener">信息，</a>请参阅“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-build-info" target="_blank" rel="noopener">生成构建信息</a> ”。</p>
</blockquote>
<h3 id="编写自定义InfoContributors"><a href="#编写自定义InfoContributors" class="headerlink" title="编写自定义InfoContributors"></a>编写自定义InfoContributors</h3><p>要提供自定义应用程序信息，可以注册实现该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java" target="_blank" rel="noopener"><code>InfoContributor</code></a>接口的Spring bean 。</p>
<p>以下示例<code>example</code>使用单个值提供条目：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInfoContributor</span> <span class="keyword">implements</span> <span class="title">InfoContributor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contribute</span><span class="params">(Info.Builder builder)</span> </span>&#123;</span><br><span class="line">		builder.withDetail(<span class="string">"example"</span>,</span><br><span class="line">				Collections.singletonMap(<span class="string">"key"</span>, <span class="string">"value"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果到达<code>info</code>端点，您应该看到包含以下附加条目的响应：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"example"</span>: &#123;</span><br><span class="line">		<span class="attr">"key"</span> : <span class="string">"value"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-endpoints/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-actuator/">使用SpringBoot-actuator</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/actuator/">actuator</a></div></div><div class="post-content"><div class="main-content content"><h1 id="启用生产就绪功能"><a href="#启用生产就绪功能" class="headerlink" title="启用生产就绪功能"></a>启用生产就绪功能</h1><p>该<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-actuator" target="_blank" rel="noopener"><code>spring-boot-actuator</code></a>模块提供了Spring Boot的所有生产就绪功能。启用这些功能的最简单方法是为<code>spring-boot-starter-actuator</code>“Starter” 添加依赖项。</p>
<p><strong>执行器的定义</strong></p>
<p>致动器是制造术语，指的是用于移动或控制某物的机械装置。执行器可以通过一个小的变化产生大量的运动。</p>
<p>要将执行器添加到基于Maven的项目，请添加以下“Starter”依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于Gradle，请使用以下声明：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	<span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-actuator"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-actuator/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-创建自己的自动配置/">使用SpringBoot-创建自己的自动配置</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/configuration/">configuration</a></div></div><div class="post-content"><div class="main-content content"><h1 id="创建自己的自动配置"><a href="#创建自己的自动配置" class="headerlink" title="创建自己的自动配置"></a>创建自己的自动配置</h1><p>如果您在开发共享库的公司工作，或者您在开源或商业库中工作，则可能需要开发自己的自动配置。自动配置类可以捆绑在外部jar中，仍然可以通过Spring Boot获取。</p>
<p>自动配置可以与“启动器”相关联，该“启动器”提供自动配置代码以及您将使用它的典型库。我们首先介绍了构建自己的自动配置需要了解的内容，然后我们将继续介绍<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-custom-starter" target="_blank" rel="noopener">创建自定义启动器所需</a>的 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-custom-starter" target="_blank" rel="noopener">典型步骤</a>。</p>
<blockquote>
<p>可以使用<a href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration" target="_blank" rel="noopener">演示项目</a>来展示如何逐步创建启动器。</p>
</blockquote>
<h2 id="了解自动配置的Bean"><a href="#了解自动配置的Bean" class="headerlink" title="了解自动配置的Bean"></a>了解自动配置的Bean</h2><p>在引擎盖下，自动配置使用标准<code>@Configuration</code>类实现。其他<code>@Conditional</code>注释用于约束何时应用自动配置。通常，自动配置类使用<code>@ConditionalOnClass</code>和 <code>@ConditionalOnMissingBean</code>注释。这可确保仅在找到相关类时以及未声明自己的类时才应用自动配置 <code>@Configuration</code>。</p>
<p>您可以浏览源代码<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure" target="_blank" rel="noopener"><code>spring-boot-autoconfigure</code></a> 以查看<code>@Configuration</code>Spring提供的类（请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories" target="_blank" rel="noopener"><code>META-INF/spring.factories</code></a> 文件）。</p>
<h2 id="找到自动配置候选者"><a href="#找到自动配置候选者" class="headerlink" title="找到自动配置候选者"></a>找到自动配置候选者</h2><p>Spring Boot会检查<code>META-INF/spring.factories</code>已发布jar中是否存在文件。该文件应列出<code>EnableAutoConfiguration</code>密钥下的配置类 ，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自动配置，必须加载这种方式<em>只</em>。确保它们在特定的包空间中定义，并且它们永远不是组件扫描的目标。此外，自动配置类不应启用组件扫描以查找其他组件。应该使用特定的<code>@ Import</code>s代替。</p>
</blockquote>
<p>如果需要按特定顺序应用配置，则可以使用 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java" target="_blank" rel="noopener"><code>@AutoConfigureAfter</code></a>或 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java" target="_blank" rel="noopener"><code>@AutoConfigureBefore</code></a>注释。例如，如果您提供特定于Web的配置，则可能需要在之后应用您的类 <code>WebMvcAutoConfiguration</code>。</p>
<p>如果您想订购某些不应该彼此直接了解的自动配置，您也可以使用<code>@AutoConfigureOrder</code>。该注释与常规注释具有相同的语义，<code>@Order</code>但为自动配置类提供了专用顺序。</p>
<h2 id="条件注释"><a href="#条件注释" class="headerlink" title="条件注释"></a>条件注释</h2><p>您几乎总是希望<code>@Conditional</code>在自动配置类中包含一个或多个注释。该<code>@ConditionalOnMissingBean</code>注释是用来让开发者重写自动配置，如果他们不满意自己的缺省值一个常见的例子。</p>
<p>Spring Boot包含许多<code>@Conditional</code>注释，您可以通过注释<code>@Configuration</code>类或单个<code>@Bean</code>方法在自己的代码中重用这些注释。这些注释包括：</p>
<ul>
<li>Class条件</li>
<li>Bean条件</li>
<li>Property条件</li>
<li>Resource条件</li>
<li>Web Application条件</li>
<li>spEL表达式条件</li>
</ul>
<h3 id="Class-Conditions"><a href="#Class-Conditions" class="headerlink" title="Class Conditions"></a>Class Conditions</h3><p><code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingClass</code>注解让 <code>@Configuration</code>类基于特定类的存在或不存在被包括在内。由于使用<a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a>解析注释元数据这一事实，您可以使用该<code>value</code>属性来引用真实类，即使该类实际上可能不会出现在正在运行的应用程序类路径中。<code>name</code> 如果您希望使用<code>String</code>值指定类名，也可以使用该属性。</p>
<p>此机制不适用于<code>@Bean</code>通常返回类型是条件的目标的方法：在方法的条件适用之前，JVM将加载类和可能处理的方法引用，如果类不是当下。</p>
<p>要处理此方案，<code>@Configuration</code>可以使用单独的类来隔离条件，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//一些条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自动配置的bean</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(EmbeddedAcmeService.class)</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedConfiguration</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> EmbeddedAcmeService <span class="title">embeddedAcmeService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您使用<code>@ConditionalOnClass</code>或<code>@ConditionalOnMissingClass</code>作为元注释的一部分来组成您自己的组合注释，则必须使用<code>name</code>在这种情况下引用该类而不处理。</p>
</blockquote>
<h3 id="Bean-Conditions"><a href="#Bean-Conditions" class="headerlink" title="Bean Conditions"></a>Bean Conditions</h3><p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>注解让豆基于特定豆的存在或不存在被包括在内。您可以使用该<code>value</code> 属性按类型<code>name</code>指定bean 或按名称指定bean。该<code>search</code> 属性允许您限制<code>ApplicationContext</code>搜索Bean时应考虑的层次结构。</p>
<p>放置在<code>@Bean</code>方法上时，目标类型默认为方法的返回类型，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，<code>myService</code>如果没有<code>MyService</code>包含类型的bean，则将创建bean <code>ApplicationContext</code>。</p>
<blockquote>
<p>您需要非常小心添加bean定义的顺序，因为这些条件是根据到目前为止已处理的内容进行评估的。出于这个原因，我们建议仅对自动配置类使用<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>注释（因为在添加任何用户定义的bean定义之后，这些类保证加载）。</p>
</blockquote>
<blockquote>
<p><code>@ConditionalOnBean</code>并且<code>@ConditionalOnMissingBean</code>不会阻止<code>@Configuration</code> 创建类。在类级别使用这些条件和<code>@Bean</code>使用注释标记每个包含的方法之间的唯一区别是，<code>@Configuration</code>如果条件不匹配，前者会阻止将类注册为bean。</p>
</blockquote>
<h3 id="Property-Conditions"><a href="#Property-Conditions" class="headerlink" title="Property Conditions"></a>Property Conditions</h3><p>该<code>@ConditionalOnProperty</code>注解让配置基于Spring的环境属性被包括在内。使用<code>prefix</code>和<code>name</code>属性指定应检查的属性。默认情况下，<code>false</code>匹配存在且不相等的任何属性。您还可以使用<code>havingValue</code>和 <code>matchIfMissing</code>属性创建更高级的检查。</p>
<h3 id="Resource-Conditions"><a href="#Resource-Conditions" class="headerlink" title="Resource Conditions"></a>Resource Conditions</h3><p>该<code>@ConditionalOnResource</code>注解让配置被包括仅当特定资源是否存在。可以使用常用的Spring约定来指定资源，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:/home/user/test.dat</span><br></pre></td></tr></table></figure>
<h3 id="Web-Application-Conditions"><a href="#Web-Application-Conditions" class="headerlink" title="Web Application Conditions"></a>Web Application Conditions</h3><p>在<code>@ConditionalOnWebApplication</code>和<code>@ConditionalOnNotWebApplication</code>注释，让配置取决于应用程序是否是一个“Web应用程序”被包括在内。Web应用程序是使用Spring <code>WebApplicationContext</code>，定义<code>session</code>范围或具有的任何应用程序<code>StandardServletEnvironment</code>。</p>
<h3 id="spEL-Conditions"><a href="#spEL-Conditions" class="headerlink" title="spEL Conditions"></a>spEL Conditions</h3><p>该<code>@ConditionalOnExpression</code>注解让配置基于一个的结果被包括<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/core.html#expressions" target="_blank" rel="noopener">使用SpEL表达</a>。</p>
<h2 id="测试自动配置"><a href="#测试自动配置" class="headerlink" title="测试自动配置"></a>测试自动配置</h2><p>自动配置可能受许多因素的影响：用户配置（<code>@Bean</code> 定义和<code>Environment</code>自定义），条件评估（存在特定库）等。具体而言，每个测试都应创建一个定义良好的<code>ApplicationContext</code>代表，以表示这些自定义的组合。 <code>ApplicationContextRunner</code>提供了实现这一目标的好方法。</p>
<p><code>ApplicationContextRunner</code>通常被定义为测试类的一个字段来收集基本的通用配置。以下示例确保 <code>UserServiceAutoConfiguration</code>始终调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">		.withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果必须定义多个自动配置，则无需按照与运行应用程序时完全相同的顺序调用它们的声明。</p>
</blockquote>
<p>每个测试都可以使用运行器来表示特定的用例。例如，下面的示例调用用户配置（<code>UserConfiguration</code>）并检查自动配置是否正确退回。调用<code>run</code>提供了可以使用的回调上下文<code>Assert4J</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultServiceBacksOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.contextRunner.withUserConfiguration(UserConfiguration.class)</span><br><span class="line">			.run((context) -&gt; &#123;</span><br><span class="line">				assertThat(context).hasSingleBean(UserService.class);</span><br><span class="line">				assertThat(context.getBean(UserService.class)).isSameAs(</span><br><span class="line">						context.getBean(UserConfiguration.class).myUserService());</span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> UserService <span class="title">myUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> UserService(<span class="string">"mine"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以轻松自定义<code>Environment</code>，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceNameCanBeConfigured</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.contextRunner.withPropertyValues(<span class="string">"user.name=test123"</span>).run((context) -&gt; &#123;</span><br><span class="line">		assertThat(context).hasSingleBean(UserService.class);</span><br><span class="line">		assertThat(context.getBean(UserService.class).getName()).isEqualTo(<span class="string">"test123"</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runner也可以用来显示<code>ConditionEvaluationReport</code>。报告可以打印<code>INFO</code>或<code>DEBUG</code>级别打印。以下示例显示如何使用<code>ConditionEvaluationReportLoggingListener</code> 在自动配置测试中打印报表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> autoConfigTest &#123;</span><br><span class="line">	ConditionEvaluationReportLoggingListener initializer = </span><br><span class="line">        <span class="keyword">new</span> ConditionEvaluationReportLoggingListener(LogLevel.INFO);</span><br><span class="line">	ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">			.withInitializer(initializer).run((context) -&gt; &#123;</span><br><span class="line">					<span class="comment">// Do something...</span></span><br><span class="line">			&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟Web上下文"><a href="#模拟Web上下文" class="headerlink" title="模拟Web上下文"></a>模拟Web上下文</h3><p>如果您需要测试仅在Servlet或Reactive Web应用程序上下文中运行的自动配置，请分别使用<code>WebApplicationContextRunner</code>或<code>ReactiveWebApplicationContextRunner</code>。</p>
<h3 id="覆盖Classpath"><a href="#覆盖Classpath" class="headerlink" title="覆盖Classpath"></a>覆盖Classpath</h3><p>还可以测试在运行时不存在特定类和/或包时发生的情况。Spring Boot附带一个<code>FilteredClassLoader</code>可以由跑步者轻松使用的。在以下示例中，我们声明如果<code>UserService</code>不存在，则会正确禁用自动配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceIsIgnoredIfLibraryIsNotPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.contextRunner.withClassLoader(<span class="keyword">new</span> FilteredClassLoader(UserService.class))</span><br><span class="line">			.run((context) -&gt; assertThat(context).doesNotHaveBean(<span class="string">"userService"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建自己的启动器"><a href="#创建自己的启动器" class="headerlink" title="创建自己的启动器"></a>创建自己的启动器</h2><p>的完整Spring Boot启动程序可能包含以下组件：</p>
<ul>
<li><code>autoconfigure</code>包含自动配置代码的模块。</li>
<li>该<code>starter</code>模块提供对<code>autoconfigure</code>模块以及库的依赖关系以及通常有用的任何其他依赖关系。简而言之，添加启动器应该提供开始使用该库所需的一切。</li>
</ul>
<blockquote>
<p>如果您不需要将这两个问题分开，则可以将自动配置代码和依赖关系管理组合在一个模块中。</p>
</blockquote>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>您应该确保为您的启动器提供适当的命名空间。<code>spring-boot</code>即使您使用其他Maven，也不要使用它来启动模块名称<code>groupId</code>。我们可能会为您将来自动配置的内容提供官方支持。</p>
<p>根据经验，您应该在启动器后命名组合模块。例如，假设您正在为“acme”创建启动器，并且您将自动配置模块<code>acme-spring-boot-autoconfigure</code>和启动器命名为<code>acme-spring-boot-starter</code>。如果您只有一个组合两者的模块，请将其命名<code>acme-spring-boot-starter</code>。</p>
<p>此外，如果您的启动器提供配置密钥，请为它们使用唯一的命名空间。特别是，不包括你在春天开机使用的命名空间键（如 <code>server</code>，<code>management</code>，<code>spring</code>，等）。如果您使用相同的命名空间，我们将来可能会以破坏您的模块的方式修改这些命名空间。</p>
<p>确保 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#configuration-metadata-annotation-processor" target="_blank" rel="noopener">触发元数据生成，</a>以便为您的密钥提供IDE帮助。您可能希望查看生成的元数据（<code>META-INF/spring-configuration-metadata.json</code>）以确保正确记录您的密钥。</p>
<h3 id="autoconfigure模块"><a href="#autoconfigure模块" class="headerlink" title="autoconfigure模块"></a>autoconfigure模块</h3><p>该<code>autoconfigure</code>模块包含开始使用库所需的所有内容。它还可以包含配置键定义（例如 <code>@ConfigurationProperties</code>）和任何可用于进一步自定义组件初始化方式的回调接口。</p>
<blockquote>
<p>您应该将库的依赖项标记为可选，以便您可以<code>autoconfigure</code>更轻松地将模块包含在项目中。如果以这种方式执行，则不提供库，默认情况下，Spring Boot会退出。</p>
</blockquote>
<p>Spring Boot使用注释处理器来收集元数据文件（<code>META-INF/spring-autoconfigure-metadata.properties</code>）中自动配置的条件。如果该文件存在，则用于热切过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于Gradle 4.5及更早版本，应在<code>compileOnly</code> 配置中声明依赖项，如以下示例所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	compileOnly <span class="string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Gradle 4.6及更高版本时，应在<code>annotationProcessor</code> 配置中声明依赖项，如以下示例所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	annotationProcessor <span class="string">"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动器模块"><a href="#启动器模块" class="headerlink" title="启动器模块"></a>启动器模块</h3><p>启动器是一个空罐子。它的唯一目的是提供必要的依赖项来使用库。您可以将其视为对入门所需内容的一种看法。</p>
<p>不要对添加启动器的项目做出假设。如果您自动配置的库通常需要其他启动器，请同时提及它们。如果可选依赖项的数量很高，则提供一组适当的<em>默认</em>依赖项可能很难，因为您应该避免包含对典型库的使用不必要的依赖项。换句话说，您不应该包含可选的依赖项。</p>
<blockquote>
<p>无论哪种方式，您的启动器必须<code>spring-boot-starter</code>直接或间接引用核心Spring Boot启动器（）（如果您的启动器依赖于另一个启动器，则无需添加它）。如果只使用自定义启动器创建项目，则Spring Boot的核心功能将通过核心启动器的存在来实现。</p>
</blockquote>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-创建自己的自动配置/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-WebService/">使用SpringBoot-WebService</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/service/">service</a></div></div><div class="post-content"><div class="main-content content"><h1 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h1><p>Spring Boot提供Web服务自动配置，因此您必须做的就是定义您的<code>Endpoints</code>。</p>
<p>在<a href="https://docs.spring.io/spring-ws/docs/3.0.6.RELEASE/reference/" target="_blank" rel="noopener">春天的Web服务功能</a>可以与轻松访问<code>spring-boot-starter-webservices</code>模块。</p>
<p><code>SimpleWsdl11Definition</code>和<code>SimpleXsdSchema</code>bean可以分别为您的WSDL和XSD自动创建。为此，请配置其位置，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.webservices.wsdl-locations=classpath:/wsdl</span><br></pre></td></tr></table></figure>
<h2 id="使用Web调用Web服务-WebServiceTemplate"><a href="#使用Web调用Web服务-WebServiceTemplate" class="headerlink" title="使用Web调用Web服务 WebServiceTemplate"></a>使用Web调用Web服务 WebServiceTemplate</h2><p>如果需要从应用程序调用远程Web服务，则可以使用 <a href="https://docs.spring.io/spring-ws/docs/3.0.6.RELEASE/reference/#client-web-service-template" target="_blank" rel="noopener"><code>WebServiceTemplate</code></a>该类。由于<code>WebServiceTemplate</code>实例在使用之前通常需要自定义，因此Spring Boot不提供任何单个自动配置的<code>WebServiceTemplate</code>bean。但是，它会自动配置a <code>WebServiceTemplateBuilder</code>，可用于<code>WebServiceTemplate</code>在需要时创建 实例。</p>
<p>以下代码显示了一个典型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> WebServiceTemplate webServiceTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebServiceTemplateBuilder webServiceTemplateBuilder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.webServiceTemplate = webServiceTemplateBuilder.build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DetailsResp <span class="title">someWsCall</span><span class="params">(DetailsReq detailsReq)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">return</span> (DetailsResp) <span class="keyword">this</span>.webServiceTemplate</span><br><span class="line">             .marshalSendAndReceive(detailsReq, <span class="keyword">new</span> SoapActionCallback(ACTION));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用类路径上的可用HTTP客户端库<code>WebServiceTemplateBuilder</code>检测合适的基于 <code>WebServiceMessageSender</code>HTTP的。您还可以按如下方式自定义读取和连接超时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebServiceTemplate <span class="title">webServiceTemplate</span><span class="params">(WebServiceTemplateBuilder builder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> builder.messageSenders(<span class="keyword">new</span> HttpWebServiceMessageSenderBuilder()</span><br><span class="line">			.setConnectTimeout(<span class="number">5000</span>).setReadTimeout(<span class="number">2000</span>).build()).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-WebService/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-WebSockets/">使用SpringBoot-WebSockets</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/websocket/">websocket</a></div></div><div class="post-content"><div class="main-content content"><h1 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h1><p>Spring Boot为嵌入式Tomcat，Jetty和Undertow提供WebSockets自动配置。如果将war文件部署到独立容器，则Spring Boot假定容器负责其WebSocket支持的配置。</p>
<p>Spring Framework 为MVC Web应用程序提供了<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web.html#websocket" target="_blank" rel="noopener">丰富的WebSocket支持</a>，可以通过该<code>spring-boot-starter-websocket</code>模块轻松访问 。</p>
<p>WebSocket支持也可用于 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-websocket" target="_blank" rel="noopener">响应式Web应用程序，</a>并且需要包括WebSocket API以及<code>spring-boot-starter-webflux</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-WebSockets/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBott-test/">使用SpringBott-test</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/test/">test</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>Spring Boot提供了许多实用程序和注释来帮助您测试应用程序。测试支持由两个模块提供：<code>spring-boot-test</code>包含核心项，并<code>spring-boot-test-autoconfigure</code>支持测试的自动配置。</p>
<p>大多数开发人员使用<code>spring-boot-starter-test</code>启动器，它导入Spring Boot测试模块以及JUnit，AssertJ，Hamcrest和许多其他有用的库。</p>
<h2 id="测试范围依赖性"><a href="#测试范围依赖性" class="headerlink" title="测试范围依赖性"></a>测试范围依赖性</h2><p>在<code>spring-boot-starter-test</code>启动器中（<code>test</code> <code>scope</code>）包含以下提供的库：</p>
<ul>
<li><a href="http://junit.org/" target="_blank" rel="noopener">JUnit</a>：单元测试Java应用程序的事实上的标准。</li>
<li><a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#integration-testing" target="_blank" rel="noopener">Spring Test</a>和Spring Boot测试：Spring Boot应用程序的实用程序和集成测试支持。</li>
<li><a href="https://joel-costigliola.github.io/assertj/" target="_blank" rel="noopener">AssertJ</a>：一个流畅的断言库。</li>
<li><a href="http://hamcrest.org/JavaHamcrest/" target="_blank" rel="noopener">Hamcrest</a>：匹配器对象库（也称为约束或谓词）。</li>
<li><a href="http://mockito.org/" target="_blank" rel="noopener">Mockito</a>：一个Java <a href="http://mockito.org/" target="_blank" rel="noopener">模拟</a>框架。</li>
<li><a href="https://github.com/skyscreamer/JSONassert" target="_blank" rel="noopener">JSONassert</a>：JSON的断言库。</li>
<li><a href="https://github.com/jayway/JsonPath" target="_blank" rel="noopener">JsonPath</a>：JSON的XPath。</li>
</ul>
<p>我们通常发现这些常用库在编写测试时很有用。如果这些库不符合您的需求，您可以添加自己的其他测试依赖项。</p>
<h2 id="测试Spring应用程序"><a href="#测试Spring应用程序" class="headerlink" title="测试Spring应用程序"></a>测试Spring应用程序</h2><p>依赖注入的一个主要优点是它应该使您的代码更容易进行单元测试。您可以使用<code>new</code>运算符实例化对象，甚至不涉及Spring。您还可以使用<em>模拟对象</em>而不是真正的依赖项。</p>
<p>通常，您需要超越单元测试并开始集成测试（使用Spring <code>ApplicationContext</code>）。能够在不需要部署应用程序或需要连接到其他基础架构的情况下执行集成测试非常有用。</p>
<p>Spring Framework包含一个用于此类集成测试的专用测试模块。您可以直接声明依赖关系<code>org.springframework:spring-test</code>或使用<code>spring-boot-starter-test</code>“Starter”来传递它。</p>
<p>如果您之前没有使用过该<code>spring-test</code>模块，那么首先应阅读Spring Framework参考文档的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testing" target="_blank" rel="noopener">相关部分</a>。</p>
<h2 id="测试Spring-Boot应用程序"><a href="#测试Spring-Boot应用程序" class="headerlink" title="测试Spring Boot应用程序"></a>测试Spring Boot应用程序</h2><p>Spring Boot应用程序是一个Spring <code>ApplicationContext</code>，所以没有什么特别的东西可以用来测试它超出你通常使用的Spring语境。</p>
<blockquote>
<p>只有在您<code>SpringApplication</code>创建Spring Boot的外部属性，日志记录和其他功能时，默认情况下才会在上下文中安装它们。</p>
</blockquote>
<p>Spring Boot提供了一个<code>@SpringBootTest</code>注释，<code>spring-test</code> <code>@ContextConfiguration</code>当您需要Spring Boot功能时，它可以用作标准注释的替代方法。注释的工作原理是通过 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-detecting-config" target="_blank" rel="noopener">创建 <code>ApplicationContext</code>测试中使用的<code>SpringApplication</code></a>。除了 <code>@SpringBootTest</code>提供许多其他注释之外，还提供了用于 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">测试</a>应用程序的<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">更具体的切片</a>。</p>
<blockquote>
<p>如果您使用的是JUnit 4，请不要忘记添加<code>@RunWith(SpringRunner.class)</code>到测试中，否则注释将被忽略。如果您使用的是JUnit 5，则无需添加等效项<code>@ExtendWith(SpringExtension)</code>，<code>@SpringBootTest</code>并且其他<code>@…Test</code>注释已经使用它进行注释。</p>
</blockquote>
<p>默认情况下，<code>@SpringBootTest</code>不会启动服务器。您可以使用该<code>webEnvironment</code> 属性<code>@SpringBootTest</code>进一步优化测试的运行方式：</p>
<ul>
<li><code>MOCK</code>（默认）：加载Web <code>ApplicationContext</code>并提供模拟Web环境。使用此批注时，不会启动嵌入式服务器。如果类路径上没有Web环境，则此模式将透明地回退到创建常规非Web <code>ApplicationContext</code>。它可以与Web应用程序一起使用 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-mock-environment" target="_blank" rel="noopener"><code>@AutoConfigureMockMvc</code>或<code>@AutoConfigureWebTestClient</code></a>用于基于模拟的Web应用程序测试。</li>
<li><code>RANDOM_PORT</code>：加载a <code>WebServerApplicationContext</code>并提供真实的Web环境。嵌入式服务器启动并在随机端口上侦听。</li>
<li><code>DEFINED_PORT</code>：加载a <code>WebServerApplicationContext</code>并提供真实的Web环境。嵌入式服务器启动并侦听定义的端口（来自您的<code>application.properties</code>）或默认端口<code>8080</code>。</li>
<li><code>NONE</code>：<code>ApplicationContext</code>通过使用<code>SpringApplication</code>但不提供 <em>任何</em> Web环境（模拟或其他）来加载。</li>
</ul>
<blockquote>
<p>如果您的测试是<code>@Transactional</code>，则默认情况下会在每个测试方法结束时回滚事务。但是，当使用这种安排<code>RANDOM_PORT</code>或者 <code>DEFINED_PORT</code>隐式地提供真实的servlet环境时，HTTP客户端和服务器在不同的线程中运行，因此在单独的事务中运行。在这种情况下，在服务器上启动的任何事务都不会回滚。</p>
</blockquote>
<blockquote>
<p><code>@SpringBootTest`</code>webEnvironment = WebEnvironment.RANDOM_PORT`如果您的应用程序使用管理服务器的不同端口，则还将在单独的随机端口上启动管理服务器。</p>
</blockquote>
<h3 id="检测Web应用程序类型"><a href="#检测Web应用程序类型" class="headerlink" title="检测Web应用程序类型"></a>检测Web应用程序类型</h3><p>如果Spring MVC可用，则配置基于MVC的常规应用程序上下文。如果您只有Spring WebFlux，我们会检测到并配置基于WebFlux的应用程序上下文。</p>
<p>如果两者都存在，则Spring MVC优先。如果要在此方案中测试响应式Web应用程序，则必须设置该<code>spring.main.web-application-type</code> 属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(properties = <span class="string">"spring.main.web-application-type=reactive"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebFluxTests</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="检测测试配置"><a href="#检测测试配置" class="headerlink" title="检测测试配置"></a>检测测试配置</h3><p>如果您熟悉Spring Test Framework，则可能习惯使用 <code>@ContextConfiguration(classes=…)</code>以指定<code>@Configuration</code>要加载的Spring 。或者，您可能经常<code>@Configuration</code>在测试中使用嵌套类。</p>
<p>在测试Spring Boot应用程序时，通常不需要这样做。<code>@*Test</code> 只要您没有明确定义，Spring Boot的注释就会自动搜索您的主要配置。</p>
<p>搜索算法从包含测试的包开始工作，直到找到用<code>@SpringBootApplication</code>or 注释的类<code>@SpringBootConfiguration</code>。只要您以合理的方式<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#using-boot-structuring-your-code" target="_blank" rel="noopener">构建代码</a>，通常就会找到主要配置。</p>
<blockquote>
<p>如果使用 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests" target="_blank" rel="noopener">测试批注来测试应用程序的更具体的片段</a>，则应避免在<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-user-configuration" target="_blank" rel="noopener">main方法的应用程序类中</a>添加特定于特定区域的配置设置 。</p>
<p><code>@SpringBootApplication</code>定义的基础组件扫描配置排除了用于确保切片按预期工作的过滤器。如果您<code>@ComponentScan</code>在已<code>@SpringBootApplication</code>注释的类上使用显式 指令，请注意将禁用这些过滤器。如果您正在使用切片，则应再次定义它们。</p>
</blockquote>
<p>如果要自定义主要配置，可以使用嵌套 <code>@TestConfiguration</code>类。与嵌套<code>@Configuration</code>类不同，嵌套类将用于代替应用程序的主要配置，<code>@TestConfiguration</code>除了应用程序的主要配置之外，还使用嵌套类。</p>
<blockquote>
<p>Spring的测试框架在测试之间缓存应用程序上下文。因此，只要您的测试共享相同的配置（无论如何发现），加载上下文的潜在耗时过程只发生一次。</p>
</blockquote>
<h3 id="排除测试配置"><a href="#排除测试配置" class="headerlink" title="排除测试配置"></a>排除测试配置</h3><p>如果您的应用程序使用组件扫描（例如，如果您使用 <code>@SpringBootApplication</code>或<code>@ComponentScan</code>），您可能会发现仅为特定测试创建的顶级配置类会意外地在任何地方被捕获。</p>
<p>正如我们<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-detecting-config" target="_blank" rel="noopener">之前所见</a>，<code>@TestConfiguration</code>可以在测试的内部类上使用来自定义主要配置。放置在顶级类时，<code>@TestConfiguration</code>表示<code>src/test/java</code>不应通过扫描拾取类。然后，您可以在需要的位置显式导入该类，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Import</span>(MyTestsConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您直接使用<code>@ComponentScan</code>（即不通过 <code>@SpringBootApplication</code>），则需要注册<code>TypeExcludeFilter</code>。有关详细信息，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/context/TypeExcludeFilter.html" target="_blank" rel="noopener">Javadoc</a>。</p>
</blockquote>
<h3 id="使用模拟环境进行测试"><a href="#使用模拟环境进行测试" class="headerlink" title="使用模拟环境进行测试"></a>使用模拟环境进行测试</h3><p>默认情况下，<code>@SpringBootTest</code>不启动服务器。如果您要针对此模拟环境测试Web端点，则可以另外进行配置 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference//testing.html#spring-mvc-test-framework" target="_blank" rel="noopener"><code>MockMvc</code></a>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBoot</span><br><span class="line">Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockMvcExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mvc.perform(get(<span class="string">"/"</span>)).andExpect(status().isOk())</span><br><span class="line">				.andExpect(content().string(<span class="string">"Hello World"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你想只专注于网络层，而不是开始一个完整的 <code>ApplicationContext</code>，可以考虑 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests" target="_blank" rel="noopener">使用 <code>@WebMvcTest</code>替代</a>。</p>
</blockquote>
<p>或者，您可以配置一个 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#webtestclient-tests" target="_blank" rel="noopener"><code>WebTestClient</code></a>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureWebTestClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockWebTestClientExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> WebTestClient webClient;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.webClient.get().uri(<span class="string">"/"</span>).exchange().expectStatus().isOk()</span><br><span class="line">            .expectBody(String.class).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用正在运行的服务器进行测试"><a href="#使用正在运行的服务器进行测试" class="headerlink" title="使用正在运行的服务器进行测试"></a>使用正在运行的服务器进行测试</h3><p>如果您需要启动一个完整运行的服务器，我们建议您使用随机端口。如果使用<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>，每次测试运行时都会随机选取一个可用端口。</p>
<p>该<code>@LocalServerPort</code>注释可用于 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#howto-discover-the-http-port-at-runtime" target="_blank" rel="noopener">注射使用的实际端口</a>到您的测试。为了方便起见，测试，需要做出REST调用启动的服务器可另外<code>@Autowire</code>一个<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#webtestclient-tests" target="_blank" rel="noopener"><code>WebTestClient</code></a>，它解析为正在运行的服务器相对链接，并附带了用于验证响应的专用API，如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPortWebTestClientExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> WebTestClient webClient;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.webClient.get().uri(<span class="string">"/"</span>).exchange().expectStatus().isOk()</span><br><span class="line">				.expectBody(String.class).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此类设置需要<code>spring-webflux</code>在类路径上。如果您不能或不会添加webflux，Spring Boot还提供了一个<code>TestRestTemplate</code>工具：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPortTestRestTemplateExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String body = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"/"</span>, String.class);</span><br><span class="line">		assertThat(body).isEqualTo(<span class="string">"Hello World"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用JMX"><a href="#使用JMX" class="headerlink" title="使用JMX"></a>使用JMX</h3><p>当测试上下文框架缓存上下文时，默认情况下禁用JMX以防止相同的组件在同一域上注册。如果此类测试需要访问 <code>MBeanServer</code>，请考虑将其标记为脏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(properties = <span class="string">"spring.jmx.enabled=true"</span>)</span><br><span class="line"><span class="meta">@DirtiesContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleJmxTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> MBeanServer mBeanServer;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mocking-and-Spying-Beans"><a href="#Mocking-and-Spying-Beans" class="headerlink" title="Mocking and Spying Beans"></a>Mocking and Spying Beans</h3><p>运行测试时，有时需要在应用程序上下文中模拟某些组件。例如，您可能拥有在开发期间不可用的某些远程服务的外观。当您想要模拟在真实环境中难以触发的故障时，模拟也很有用。</p>
<p>Spring Boot包含一个<code>@MockBean</code>注释，可用于为您内部的bean定义Mockito模拟<code>ApplicationContext</code>。您可以使用批注添加新bean或替换单个现有bean定义。注释可以直接用于测试类，测试中的字段，或<code>@Configuration</code>类和字段。在字段上使用时，也会注入创建的模拟的实例。每种测试方法后，模拟豆都会自动重置。</p>
<blockquote>
<p>如果您的测试使用Spring Boot的测试注释之一（例如<code>@SpringBootTest</code>），则会自动启用此功能。要以不同的排列方式使用此功能，必须显式添加侦听器，如以下示例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestExecutionListeners</span>（MockitoTestExecutionListener.class）</span><br></pre></td></tr></table></figure>
<p>以下示例使用<code>RemoteService</code>模拟实现替换现有bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@MockBean</span></span><br><span class="line">	<span class="keyword">private</span> RemoteService remoteService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> Reverser reverser;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// RemoteService has been injected into the reverser bean</span></span><br><span class="line">		given(<span class="keyword">this</span>.remoteService.someCall()).willReturn(<span class="string">"mock"</span>);</span><br><span class="line">		String reverse = reverser.reverseSomeCall();</span><br><span class="line">		assertThat(reverse).isEqualTo(<span class="string">"kcom"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，您可以使用<code>@SpyBean</code>Mockito来包装任何现有的bean <code>spy</code>。有关详细信息，请参阅<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/api/org/springframework/boot/test/mock/mockito/SpyBean.html" target="_blank" rel="noopener">Javadoc</a>。</p>
<blockquote>
<p>虽然Spring的测试框架在测试之间缓存应用程序上下文并重用共享相同配置的测试的上下文，但是使用<code>@MockBean</code>或<code>@SpyBean</code> 影响缓存键，这很可能会增加上下文的数量。</p>
</blockquote>
<blockquote>
<p>如果您使用通过名称引用参数的方法<code>@SpyBean</code>来监视bean，则<code>@Cacheable</code>必须使用编译应用程序<code>-parameters</code>。这确保了一旦bean被监视，参数名称可用于缓存基础结构。</p>
</blockquote>
<h3 id="自动配置的测试"><a href="#自动配置的测试" class="headerlink" title="自动配置的测试"></a>自动配置的测试</h3><p>Spring Boot的自动配置系统适用于应用程序，但有时对于测试来说有点太多了。通常有助于仅加载测试应用程序“切片”所需的配置部分。例如，您可能希望测试Spring MVC控制器是否正确映射URL，并且您不希望在这些测试中涉及数据库调用，或者您可能想要测试JPA实体，并且您对Web层不感兴趣测试运行。</p>
<p>该<code>spring-boot-test-autoconfigure</code>模块包括许多可用于自动配置这种“切片”的注释。它们中的每一个都以类似的方式工作，提供一个<code>@…Test</code>注释，用于加载可用于自定义自动配置设置的<code>ApplicationContext</code>一个或多个<code>@AutoConfigure…</code>注释。</p>
<blockquote>
<p>每个切片将组件扫描限制为适当的组件，并加载一组非常有限的自动配置类。如果您需要排除其中一个，大多数<code>@…Test</code>注释都会提供一个<code>excludeAutoConfiguration</code>属性。或者，您可以使用<code>@ImportAutoConfiguration#exclude</code>。</p>
</blockquote>
<blockquote>
<p><code>@Test</code>不支持在一次测试中使用多个注释包括多个“切片” 。如果您需要多个“切片”，请选择其中一个<code>@…Test</code>注释并<code>@AutoConfigure…</code>手动包含其他“切片” 的注释。</p>
</blockquote>
<blockquote>
<p>也可以使用<code>@AutoConfigure…</code>带有标准 <code>@SpringBootTest</code>注释的注释。如果您对“切片”应用程序不感兴趣但想要一些自动配置的测试bean，则可以使用此组合。</p>
</blockquote>
<h3 id="自动配置的JSON测试"><a href="#自动配置的JSON测试" class="headerlink" title="自动配置的JSON测试"></a>自动配置的JSON测试</h3><p>要测试该对象JSON序列化和反序列化是否按预期工作，您可以使用<code>@JsonTest</code>注释。<code>@JsonTest</code>自动配置可用的受支持JSON映射器，它可以是以下库之一：</p>
<ul>
<li>Jackson<code>ObjectMapper</code>，任何<code>@JsonComponent</code>beans和Jackson<code>Module</code>S</li>
<li><code>Gson</code></li>
<li><code>Jsonb</code></li>
</ul>
<blockquote>
<p><code>@JsonTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p>
</blockquote>
<p>如果需要配置自动配置的元素，可以使用 <code>@AutoConfigureJsonTesters</code>注释。</p>
<p>Spring Boot包括基于AssertJ的助手，它们与JSONAssert和JsonPath库一起使用，以检查JSON是否按预期显示。的<code>JacksonTester</code>，<code>GsonTester</code>，<code>JsonbTester</code>，和<code>BasicJsonTester</code>类可以分别用于杰克逊，GSON，Jsonb，和字符串。测试类上的任何辅助字段都可以<code>@Autowired</code>在使用时使用<code>@JsonTest</code>。以下示例显示了Jackson的测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@JsonTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJsonTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> JacksonTester&lt;VehicleDetails&gt; json;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		VehicleDetails details = <span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>);</span><br><span class="line">		<span class="comment">//在与测试断言相同的包中断言.json文件</span></span><br><span class="line">		assertThat(<span class="keyword">this</span>.json.write(details)).isEqualToJson(<span class="string">"expected.json"</span>);</span><br><span class="line">		<span class="comment">//或者使用基于JSON路径的断言</span></span><br><span class="line">		assertThat(<span class="keyword">this</span>.json.write(details)).hasJsonPathStringValue(<span class="string">"@.make"</span>);</span><br><span class="line">		assertThat(<span class="keyword">this</span>.json.write(details)).extractingJsonPathStringValue(<span class="string">"@.make"</span>)</span><br><span class="line">				.isEqualTo(<span class="string">"Honda"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeserialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String content = <span class="string">"&#123;\"make\":\"Ford\",\"model\":\"Focus\"&#125;"</span>;</span><br><span class="line">		assertThat(<span class="keyword">this</span>.json.parse(content))</span><br><span class="line">				.isEqualTo(<span class="keyword">new</span> VehicleDetails(<span class="string">"Ford"</span>, <span class="string">"Focus"</span>));</span><br><span class="line">		assertThat(<span class="keyword">this</span>.json.parseObject(content).getMake()).isEqualTo(<span class="string">"Ford"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JSON帮助程序类也可以直接在标准单元测试中使用。为此，如果不使用，请在<code>initFields</code>方法中调用帮助程序的<code>@Before</code>方法 <code>@JsonTest</code>。</p>
</blockquote>
<h3 id="自动配置的Spring-MVC测试"><a href="#自动配置的Spring-MVC测试" class="headerlink" title="自动配置的Spring MVC测试"></a>自动配置的Spring MVC测试</h3><p>要测试Spring MVC控制器是否按预期工作，请使用<code>@WebMvcTest</code> 注释。<code>@WebMvcTest</code>自动配置Spring MVC的基础设施和限制扫描豆<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>， <code>GenericConverter</code>，<code>Filter</code>，<code>WebMvcConfigurer</code>，和<code>HandlerMethodArgumentResolver</code>。<code>@Component</code>使用此批注时不会扫描常规bean。</p>
<blockquote>
<p><code>@WebMvcTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p>
</blockquote>
<blockquote>
<p>如果需要注册额外的组件，例如Jackson <code>Module</code>，则可以<code>@Import</code>在测试中使用其他配置类。</p>
</blockquote>
<p>通常，<code>@WebMvcTest</code>仅限于单个控制器，并与其结合使用 <code>@MockBean</code>，为所需的协作者提供模拟实现。</p>
<p><code>@WebMvcTest</code>还自动配置<code>MockMvc</code>。Mock MVC提供了一种快速测试MVC控制器的强大方法，无需启动完整的HTTP服务器。</p>
<blockquote>
<p>您还可以通过使用注释来<code>MockMvc</code>非自动配置<code>@WebMvcTest</code>（例如 <code>@SpringBootTest</code>）<code>@AutoConfigureMockMvc</code>。以下示例使用<code>MockMvc</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebMvcTest</span>(UserVehicleController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@MockBean</span></span><br><span class="line">	<span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))</span><br><span class="line">				.willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));</span><br><span class="line">		<span class="keyword">this</span>.mvc.perform(get(<span class="string">"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">            .andExpect(status().isOk()).andExpect(content().string(<span class="string">"Honda Civic"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要配置自动配置的元素（例如，应该应用servlet过滤器时），则可以使用<code>@AutoConfigureMockMvc</code> 注释中的属性。</p>
</blockquote>
<p>如果您使用HtmlUnit或Selenium，则自动配置还提供HTMLUnit <code>WebClient</code> bean和/或<code>WebDriver</code>bean。以下示例使用HtmlUnit：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.gargoylesoftware.htmlunit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebMvcTest</span>(UserVehicleController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHtmlUnitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@MockBean</span></span><br><span class="line">	<span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))</span><br><span class="line">				.willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));</span><br><span class="line">		HtmlPage page = <span class="keyword">this</span>.webClient.getPage(<span class="string">"/sboot/vehicle.html"</span>);</span><br><span class="line">		assertThat(page.getBody().getTextContent()).isEqualTo(<span class="string">"Honda Civic"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，Spring Boot将<code>WebDriver</code>bean放在一个特殊的“范围”中，以确保驱动程序在每次测试后退出并注入新实例。如果您不想要此行为，可以添加<code>@Scope(&quot;singleton&quot;)</code>到您的<code>WebDriver</code> <code>@Bean</code> 定义中。</p>
</blockquote>
<blockquote>
<p><code>webDriver</code>Spring Boot创建的范围将替换任何用户定义的同名范围。如果您定义自己的<code>webDriver</code>范围，您可能会发现它在您使用时停止工作<code>@WebMvcTest</code>。</p>
</blockquote>
<p>如果在类路径上有Spring Security，<code>@WebMvcTest</code>则还会扫描<code>WebSecurityConfigurer</code> bean。您可以使用Spring Security的测试支持，而不是完全禁用此类测试的安全性。有关如何使用Spring Security <code>MockMvc</code>支持的更多详细信息，请参见<em>第80章“ 使用Spring Security测试</em>方法”部分。</p>
<blockquote>
<p>有时编写Spring MVC测试是不够的; Spring Boot可以帮助您<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">使用实际服务器</a>运行 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">完整的端到端测试</a>。</p>
</blockquote>
<h3 id="自动配置的Spring-WebFlux测试"><a href="#自动配置的Spring-WebFlux测试" class="headerlink" title="自动配置的Spring WebFlux测试"></a>自动配置的Spring WebFlux测试</h3><p>要测试<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference//web-reactive.html" target="_blank" rel="noopener">Spring WebFlux</a>控制器是否按预期工作，您可以使用<code>@WebFluxTest</code>注释。<code>@WebFluxTest</code> 自动配置春季WebFlux基础设施和限制扫描豆<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>，<code>GenericConverter</code>，和 <code>WebFluxConfigurer</code>。 使用注释<code>@Component</code>时不会扫描常规bean <code>@WebFluxTest</code>。</p>
<blockquote>
<p><code>@WebFluxTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p>
</blockquote>
<blockquote>
<p>如果需要注册额外的组件，例如Jackson <code>Module</code>，则可以<code>@Import</code>在测试中导入其他配置类。</p>
</blockquote>
<p>通常，<code>@WebFluxTest</code>仅限于单个控制器并与<code>@MockBean</code>注释结合使用， 以便为所需的协作者提供模拟实现。</p>
<p><code>@WebFluxTest</code>还有自动配置 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#webtestclient" target="_blank" rel="noopener"><code>WebTestClient</code></a>，这提供了一种快速测试WebFlux控制器的强大方法，无需启动完整的HTTP服务器。</p>
<blockquote>
<p>您还可以通过使用注释来<code>WebTestClient</code>非自动配置<code>@WebFluxTest</code>（例如 <code>@SpringBootTest</code>）<code>@AutoConfigureWebTestClient</code>。以下示例显示了使用both <code>@WebFluxTest</code>和a的类<code>WebTestClient</code>：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebFluxTest</span>(UserVehicleController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> WebTestClient webClient;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@MockBean</span></span><br><span class="line">	<span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">"sboot"</span>))</span><br><span class="line">				.willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>));</span><br><span class="line">		<span class="keyword">this</span>.webClient.get().uri(<span class="string">"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN)</span><br><span class="line">				.exchange()</span><br><span class="line">				.expectStatus().isOk()</span><br><span class="line">				.expectBody(String.class).isEqualTo(<span class="string">"Honda Civic"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此设置仅由WebFlux应用程序支持，因为<code>WebTestClient</code>在模拟的Web应用程序中使用仅适用于WebFlux。</p>
</blockquote>
<blockquote>
<p><code>@WebFluxTest</code>无法检测通过功能Web框架注册的路由。要<code>RouterFunction</code>在上下文中测试bean，请考虑<code>RouterFunction</code> 通过<code>@Import</code>或使用自己导入<code>@SpringBootTest</code>。</p>
</blockquote>
<blockquote>
<p>有时编写Spring WebFlux测试是不够的; Spring Boot可以帮助您<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">使用实际服务器</a>运行 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">完整的端到端测试</a>。</p>
</blockquote>
<h3 id="自动配置的数据JPA测试"><a href="#自动配置的数据JPA测试" class="headerlink" title="自动配置的数据JPA测试"></a>自动配置的数据JPA测试</h3><p>您可以使用<code>@DataJpaTest</code>注释来测试JPA应用程序。默认情况下，它配置内存中的嵌入式数据库，扫描<code>@Entity</code>类并配置Spring Data JPA存储库。常规<code>@Component</code>bean没有加载到 <code>ApplicationContext</code>。</p>
<blockquote>
<p><code>@DataJpaTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p>
</blockquote>
<p>默认情况下，数据JPA测试是事务性的，并在每次测试结束时回滚。有关 更多详细信息，请参阅Spring Framework Reference Documentation中的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions" target="_blank" rel="noopener">相关部分</a>。如果这不是您想要的，您可以为测试或整个类禁用事务管理，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据JPA测试也可以注入一个 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.java" target="_blank" rel="noopener"><code>TestEntityManager</code></a> bean，它提供了<code>EntityManager</code>专门为测试设计的标准JPA的替代方法。如果要<code>TestEntityManager</code>在<code>@DataJpaTest</code>实例外部 使用，也可以使用<code>@AutoConfigureTestEntityManager</code> 注释。<code>JdbcTemplate</code>如果您需要，也可以使用A. 以下示例显示<code>@DataJpaTest</code>正在使用的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestEntityManager entityManager;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.entityManager.persist(<span class="keyword">new</span> User(<span class="string">"sboot"</span>, <span class="string">"1234"</span>));</span><br><span class="line">		User user = <span class="keyword">this</span>.repository.findByUsername(<span class="string">"sboot"</span>);</span><br><span class="line">		assertThat(user.getUsername()).isEqualTo(<span class="string">"sboot"</span>);</span><br><span class="line">		assertThat(user.getVin()).isEqualTo(<span class="string">"1234"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存中的嵌入式数据库通常可以很好地用于测试，因为它们很快并且不需要任何安装。但是，如果您更喜欢对真实数据库运行测试，则可以使用<code>@AutoConfigureTestDatabase</code>注释，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@AutoConfigureTestDatabase</span>(replace=Replace.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的JDBC测试"><a href="#自动配置的JDBC测试" class="headerlink" title="自动配置的JDBC测试"></a>自动配置的JDBC测试</h3><p><code>@JdbcTest</code>类似于<code>@DataJpaTest</code>但仅适用于仅需要 <code>DataSource</code>并且不使用Spring Data JDBC的测试。默认情况下，它配置内存中的嵌入式数据库和<code>JdbcTemplate</code>。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。</p>
<blockquote>
<p><code>@JdbcTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p>
</blockquote>
<p>默认情况下，JDBC测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参阅Spring Framework Reference Documentation中的 <a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions" target="_blank" rel="noopener">相关部分</a>。如果这不是您想要的，您可以禁用测试或整个类的事务管理，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@JdbcTest</span></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您希望测试针对真实数据库运行，则可以使用与<code>@AutoConfigureTestDatabase</code>注释相同的方式使用 注释<code>DataJpaTest</code>。（参见“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test" target="_blank" rel="noopener">第46.3.12节</a> ” ,”<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test" target="_blank" rel="noopener">自动配置的数据JPA测试</a> “）</p>
<h3 id="自动配置的数据JDBC测试"><a href="#自动配置的数据JDBC测试" class="headerlink" title="自动配置的数据JDBC测试"></a>自动配置的数据JDBC测试</h3><p><code>@DataJdbcTest</code>类似于<code>@JdbcTest</code>但是适用于使用Spring Data JDBC存储库的测试。默认情况下，它配置内存中的嵌入式数据库，a <code>JdbcTemplate</code>和Spring Data JDBC存储库。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。</p>
<blockquote>
<p><code>@DataJdbcTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p>
</blockquote>
<p>默认情况下，数据JDBC测试是事务性的，并在每次测试结束时回滚。有关 更多详细信息，请参阅Spring Framework Reference Documentation中的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions" target="_blank" rel="noopener">相关部分</a>。如果这不是您想要的，您可以禁用测试或整个测试类的事务管理，如 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test" target="_blank" rel="noopener">JDBC示例中所示</a>。</p>
<p>如果您希望测试针对真实数据库运行，则可以使用与<code>@AutoConfigureTestDatabase</code>注释相同的方式使用 注释<code>DataJpaTest</code>。（参见“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test" target="_blank" rel="noopener">第46.3.12节</a> ” ,”<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test" target="_blank" rel="noopener">自动配置的数据JPA测试</a> “）</p>
<h3 id="自动配置的jOOQ测试"><a href="#自动配置的jOOQ测试" class="headerlink" title="自动配置的jOOQ测试"></a>自动配置的jOOQ测试</h3><p>您可以使用<code>@JooqTest</code>与<code>@JdbcTest</code>jOOQ相关的测试类似的方式。由于jOOQ严重依赖于与数据库模式对应的基于Java的模式，因此使用现有模式<code>DataSource</code>。如果要将其替换为内存数据库，可以使用<code>@AutoConfigureTestDatabase</code>覆盖这些设置。（有关在Spring Boot中使用jOOQ的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-jooq" target="_blank" rel="noopener">第31.6节</a> ” <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-jooq" target="_blank" rel="noopener">，“使用jOOQ”</a>。）常规 <code>@Component</code>bean不会加载到<code>ApplicationContext</code>。</p>
<blockquote>
<p><code>@JooqTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置列表。</p>
</blockquote>
<p><code>@JooqTest</code>配置一个<code>DSLContext</code>。常规<code>@Component</code>bean没有加载到 <code>ApplicationContext</code>。以下示例显示<code>@JooqTest</code>正在使用的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jooq.DSLContext;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.jooq.JooqTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@JooqTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJooqTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DSLContext dslContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JOOQ测试是事务性的，默认情况下在每次测试结束时回滚。如果这不是您想要的，您可以禁用测试或整个测试类的事务管理，如 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test" target="_blank" rel="noopener">JDBC示例中所示</a>。</p>
<h3 id="自动配置的数据MongoDB测试"><a href="#自动配置的数据MongoDB测试" class="headerlink" title="自动配置的数据MongoDB测试"></a>自动配置的数据MongoDB测试</h3><p>您可以使用它<code>@DataMongoTest</code>来测试MongoDB应用程序。默认情况下，它配置内存中嵌入的MongoDB（如果可用），配置<code>MongoTemplate</code>，扫描 <code>@Document</code>类以及配置Spring Data MongoDB存储库。常规 <code>@Component</code>bean没有加载到<code>ApplicationContext</code>。（有关将MongoDB与Spring Boot一起使用的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-mongodb" target="_blank" rel="noopener">第32.2节”，“MongoDB”</a>。）</p>
<blockquote>
<p><code>@DataMongoTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p>
</blockquote>
<p>以下类显示<code>@DataMongoTest</code>正在使用的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataMongoTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataMongoTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存中嵌入式MongoDB通常适用于测试，因为它速度快，不需要任何开发人员安装。但是，如果您更喜欢对真正的MongoDB服务器运行测试，则应排除嵌入式MongoDB自动配置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"> <span class="keyword">import</span> org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataMongoTest</span>(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataMongoNonEmbeddedTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的数据Neo4j测试"><a href="#自动配置的数据Neo4j测试" class="headerlink" title="自动配置的数据Neo4j测试"></a>自动配置的数据Neo4j测试</h3><p>您可以使用它<code>@DataNeo4jTest</code>来测试Neo4j应用程序。默认情况下，它使用内存中嵌入式Neo4j（如果嵌入式驱动程序可用），扫描<code>@NodeEntity</code>类并配置Spring Data Neo4j存储库。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。（有关使用带有Spring Boot的Neo4J的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-neo4j" target="_blank" rel="noopener">第32.3节”，“Neo4j”</a>。）</p>
<blockquote>
<p><code>@DataNeo4jTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p>
</blockquote>
<p>以下示例显示了在Spring Boot中使用Neo4J测试的典型设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataNeo</span>4jTest</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataNeo4jTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> YourRepository repository;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，Data Neo4j测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参阅Spring Framework Reference Documentation中的<a href="https://docs.spring.io/spring/docs/5.1.5.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions" target="_blank" rel="noopener">相关部分</a>。如果这不是您想要的，您可以禁用测试或整个类的事务管理，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataNeo</span>4jTest</span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的数据Redis测试"><a href="#自动配置的数据Redis测试" class="headerlink" title="自动配置的数据Redis测试"></a>自动配置的数据Redis测试</h3><p>您可以使用它<code>@DataRedisTest</code>来测试Redis应用程序。默认情况下，它会扫描 <code>@RedisHash</code>类并配置Spring Data Redis存储库。常规<code>@Component</code> bean没有加载到<code>ApplicationContext</code>。（有关使用带有Spring Boot的Redis的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-redis" target="_blank" rel="noopener">第32.1节”，“Redis”</a>。）</p>
<blockquote>
<p><code>@DataRedisTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p>
</blockquote>
<p>以下示例显示<code>@DataRedisTest</code>正在使用的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataRedisTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataRedisTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> YourRepository repository;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的数据LDAP测试"><a href="#自动配置的数据LDAP测试" class="headerlink" title="自动配置的数据LDAP测试"></a>自动配置的数据LDAP测试</h3><p>您可以使用它<code>@DataLdapTest</code>来测试LDAP应用程序。默认情况下，它配置内存中嵌入式LDAP（如果可用），配置<code>LdapTemplate</code>，扫描<code>@Entry</code> 类以及配置Spring Data LDAP存储库。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。（有关在Spring Boot中使用LDAP的更多信息，请参阅本章前面的“ <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-ldap" target="_blank" rel="noopener">第32.9节”，“LDAP”</a>。）</p>
<blockquote>
<p><code>@DataLdapTest</code>可以 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p>
</blockquote>
<p>以下示例显示<code>@DataLdapTest</code>正在使用的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ldap.core.LdapTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataLdapTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataLdapTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> LdapTemplate ldapTemplate;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存中嵌入式LDAP通常适用于测试，因为它速度快，不需要任何开发人员安装。但是，如果您更喜欢针对真实LDAP服务器运行测试，则应排除嵌入式LDAP自动配置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@DataLdapTest</span>(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataLdapNonEmbeddedTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的REST客户端"><a href="#自动配置的REST客户端" class="headerlink" title="自动配置的REST客户端"></a>自动配置的REST客户端</h3><p>您可以使用<code>@RestClientTest</code>注释来测试REST客户端。默认情况下，它会自动配置Jackson，GSON和Jsonb支持，配置<code>RestTemplateBuilder</code>并添加支持<code>MockRestServiceServer</code>。常规<code>@Component</code>bean没有加载到<code>ApplicationContext</code>。</p>
<blockquote>
<p><code>@RestClientTest</code>可以<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#test-auto-configuration" target="_blank" rel="noopener">在附录中找到</a>启用的自动配置设置列表。</p>
</blockquote>
<p>应使用<code>value</code>or <code>components</code>属性指定要测试的特定bean <code>@RestClientTest</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@RestClientTest</span>(RemoteVehicleDetailsService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRestClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RemoteVehicleDetailsService service;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> MockRestServiceServer server;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class="params">()</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.server.expect(requestTo(<span class="string">"/greet/details"</span>))</span><br><span class="line">				.andRespond(withSuccess(<span class="string">"hello"</span>, MediaType.TEXT_PLAIN));</span><br><span class="line">		String greeting = <span class="keyword">this</span>.service.callRestService();</span><br><span class="line">		assertThat(greeting).isEqualTo(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的Spring-REST-Docs测试"><a href="#自动配置的Spring-REST-Docs测试" class="headerlink" title="自动配置的Spring REST Docs测试"></a>自动配置的Spring REST Docs测试</h3><p>您可以使用<code>@AutoConfigureRestDocs</code>注释在Mock MVC，REST Assured或WebTestClient的测试中使用<a href="https://projects.spring.io/spring-restdocs/" target="_blank" rel="noopener">Spring REST Docs</a>。它消除了对Spring REST Docs中JUnit规则的需求。</p>
<p><code>@AutoConfigureRestDocs</code>可用于覆盖默认输出目录（<code>target/generated-snippets</code>如果您使用的是Maven，或者<code>build/generated-snippets</code>如果您使用的是Gradle）。它还可用于配置出现在任何已记录的URI中的主机，方案和端口。</p>
<h4 id="使用Mock-MVC自动配置Spring-REST-Docs测试"><a href="#使用Mock-MVC自动配置Spring-REST-Docs测试" class="headerlink" title="使用Mock MVC自动配置Spring REST Docs测试"></a>使用Mock MVC自动配置Spring REST Docs测试</h4><p><code>@AutoConfigureRestDocs</code>自定义<code>MockMvc</code>bean以使用Spring REST Docs。您可以<code>@Autowired</code>像在通常使用Mock MVC和Spring REST Docs时那样在测试中使用它来注入它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@WebMvcTest</span>(UserController.class)</span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDocumentationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mvc.perform(get(<span class="string">"/users"</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">				.andExpect(status().isOk())</span><br><span class="line">				.andDo(document(<span class="string">"list-users"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您需要对Spring REST Docs配置的更多控制而不是属性提供，则<code>@AutoConfigureRestDocs</code>可以使用 <code>RestDocsMockMvcConfigurationCustomizer</code>bean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationConfiguration</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">RestDocsMockMvcConfigurationCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(MockMvcRestDocumentationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">		configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要对参数化输出目录使用Spring REST Docs支持，可以创建<code>RestDocumentationResultHandler</code>bean。自动配置<code>alwaysDo</code>使用此结果处理程序调用 ，从而使每个<code>MockMvc</code>调用自动生成默认代码段。以下示例显示了 <code>RestDocumentationResultHandler</code>正在定义的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultHandlerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RestDocumentationResultHandler <span class="title">restDocumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> MockMvcRestDocumentation.document(<span class="string">"&#123;method-name&#125;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用REST-Assured自动配置Spring-REST-Docs测试"><a href="#使用REST-Assured自动配置Spring-REST-Docs测试" class="headerlink" title="使用REST Assured自动配置Spring REST Docs测试"></a>使用REST Assured自动配置Spring REST Docs测试</h4><p><code>@AutoConfigureRestDocs</code>制作一个<code>RequestSpecification</code>预先配置为使用Spring REST Docs 的bean，可用于您的测试。您可以<code>@Autowired</code>像在通常使用REST Assured和Spring REST Doc时那样在测试中使用它来注入它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.restassured.specification.RequestSpecification;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.LocalServerPort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.restassured.RestAssured.given;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.is;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.restdocs.restassured3.RestAssuredRestDocumentation.document;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDocumentationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@LocalServerPort</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RequestSpecification documentationSpec;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		given(<span class="keyword">this</span>.documentationSpec).filter(document(<span class="string">"list-users"</span>)).when()</span><br><span class="line">				.port(<span class="keyword">this</span>.port).get(<span class="string">"/"</span>).then().assertThat().statusCode(is(<span class="number">200</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您需要对Spring REST Docs配置的更多控制而不是属性提供<code>@AutoConfigureRestDocs</code>，<code>RestDocsRestAssuredConfigurationCustomizer</code> 则可以使用bean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationConfiguration</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">RestDocsRestAssuredConfigurationCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestAssuredRestDocumentationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">		configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附加自动配置和切片"><a href="#附加自动配置和切片" class="headerlink" title="附加自动配置和切片"></a>附加自动配置和切片</h3><p>每个切片提供一个或多个<code>@AutoConfigure…</code>注释，即定义应作为切片的一部分包括的自动配置。可以通过创建自定义<code>@AutoConfigure…</code>注释或仅通过添加<code>@ImportAutoConfiguration</code>到测试来添加其他自动配置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@JdbcTest</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration</span>(IntegrationAutoConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJdbcTests</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>确保不使用常规<code>@Import</code>注释来导入自动配置，因为Spring Boot会以特定方式处理它们。</p>
</blockquote>
<h3 id="用户配置和切片"><a href="#用户配置和切片" class="headerlink" title="用户配置和切片"></a>用户配置和切片</h3><p>如果以合理的方式<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#using-boot-structuring-your-code" target="_blank" rel="noopener">构造代码</a>，<code>@SpringBootApplication</code>则<a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-detecting-config" target="_blank" rel="noopener">默认情况下</a>会将您的 类 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-detecting-config" target="_blank" rel="noopener">用作</a>测试的配置。</p>
<p>然后，重要的是不要使用特定于其功能的特定区域的配置设置来丢弃应用程序的主类。</p>
<p>假设您正在使用Spring Batch并依赖于它的自动配置。您可以<code>@SpringBootApplication</code>按如下方式定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>因为此类是测试的源配置，所以任何切片测试实际上都会尝试启动Spring Batch，这绝对不是您想要做的。建议的方法是将特定于区域的配置移动到与<code>@Configuration</code>应用程序相同级别的单独类中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchConfiguration</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据应用程序的复杂程度，您可能只有一个 <code>@Configuration</code>类用于自定义，或者每个域区域有一个类。后一种方法允许您在必要时使用<code>@Import</code>注释在其中一个测试中启用它。</p>
</blockquote>
<p>混淆的另一个原因是类路径扫描。假设您以合理的方式构建代码，则需要扫描其他包。您的应用程序可能类似于以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(&#123; <span class="string">"com.example.app"</span>, <span class="string">"org.acme.another"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这样做会有效地覆盖默认组件扫描指令，并且无论您选择哪个切片，都会扫描这两个包。例如， <code>@DataJpaTest</code>似乎突然扫描了应用程序的组件和用户配置。同样，将自定义指令移动到单独的类是解决此问题的好方法。</p>
<blockquote>
<p>如果这不是您的选项，您可以<code>@SpringBootConfiguration</code> 在测试的层次结构中创建一个位置，以便使用它。或者，您可以为测试指定源，这会禁用查找默认源的行为。</p>
</blockquote>
<h3 id="使用Spock测试Spring-Boot应用程序"><a href="#使用Spock测试Spring-Boot应用程序" class="headerlink" title="使用Spock测试Spring Boot应用程序"></a>使用Spock测试Spring Boot应用程序</h3><p>如果您希望使用Spock来测试Spring Boot应用程序，您应该将Spock <code>spock-spring</code>模块的依赖项添加到应用程序的构建中。<code>spock-spring</code>将Spring的测试框架集成到Spock中。建议您使用Spock 1.2或更高版本从Spock的Spring Framework和Spring Boot集成的许多改进中受益。有关更多详细信息，请参阅<a href="http://spockframework.org/spock/docs/1.2/modules.html#_spring_module" target="_blank" rel="noopener">Spock Spring模块的文档</a>。</p>
<h2 id="测试应用程序"><a href="#测试应用程序" class="headerlink" title="测试应用程序"></a>测试应用程序</h2><p>在测试应用程序时通常有用的一些测试实用程序类是作为其一部分打包的<code>spring-boot</code>。</p>
<h3 id="ConfigFileApplicationContextInitializer"><a href="#ConfigFileApplicationContextInitializer" class="headerlink" title="ConfigFileApplicationContextInitializer"></a>ConfigFileApplicationContextInitializer</h3><p><code>ConfigFileApplicationContextInitializer</code>是一个<code>ApplicationContextInitializer</code>可以应用于测试以加载Spring Boot <code>application.properties</code>文件的。当您不需要提供的全部功能时，可以使用它<code>@SpringBootTest</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(classes = Config.class,</span><br><span class="line">	initializers = ConfigFileApplicationContextInitializer.class)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ConfigFileApplicationContextInitializer</code>单独使用不提供<code>@Value(&quot;${…}&quot;)</code>注射支持 。它唯一的工作是确保将<code>application.properties</code>文件加载到Spring中<code>Environment</code>。要获得<code>@Value</code>支持，您需要另外配置<code>PropertySourcesPlaceholderConfigurer</code>或使用<code>@SpringBootTest</code>，为您自动配置一个。</p>
</blockquote>
<h3 id="TestPropertyValues"><a href="#TestPropertyValues" class="headerlink" title="TestPropertyValues"></a>TestPropertyValues</h3><p><code>TestPropertyValues</code>让您快速添加属性 <code>ConfigurableEnvironment</code>或<code>ConfigurableApplicationContext</code>。您可以使用<code>key=value</code>字符串调用它 ，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestPropertyValues.of(<span class="string">"org=Spring"</span>, <span class="string">"name=Boot"</span>).applyTo(env);</span><br></pre></td></tr></table></figure>
<h3 id="OutputCapture"><a href="#OutputCapture" class="headerlink" title="OutputCapture"></a>OutputCapture</h3><p><code>OutputCapture</code>是一个<code>Rule</code>可以用来捕获<code>System.out</code>和 <code>System.err</code>输出的JUnit 。您可以将捕获声明为a <code>@Rule</code>然后<code>toString()</code> 用于断言，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.rule.OutputCapture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Rule</span></span><br><span class="line">	<span class="keyword">public</span> OutputCapture capture = <span class="keyword">new</span> OutputCapture();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">		assertThat(capture.toString(), containsString(<span class="string">"World"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TestRestTemplate"><a href="#TestRestTemplate" class="headerlink" title="TestRestTemplate"></a>TestRestTemplate</h3><blockquote>
<p>Spring Framework 5.0提供了一个<code>WebTestClient</code>适用于 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests" target="_blank" rel="noopener">WebFlux集成测试</a>以及 <a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">WebFlux和MVC端到端测试的新功能</a>。它提供了一个流畅的断言API，不像<code>TestRestTemplate</code>。</p>
</blockquote>
<p><code>TestRestTemplate</code>是Spring的便捷替代品，<code>RestTemplate</code>在集成测试中很有用。您可以获得一个vanilla模板或一个发送基本HTTP身份验证（使用用户名和密码）的模板。在任何一种情况下，模板都以一种测试友好的方式运行，不会在服务器端错误上抛出异常。建议（但不是强制性的）使用Apache HTTP Client（版本4.3.2或更高版本）。如果您在类路径中有这个，则<code>TestRestTemplate</code>通过适当地配置客户端来响应。如果您确实使用Apache的HTTP客户端，则启用一些其他测试友好功能：</p>
<ul>
<li>不遵循重定向（因此您可以断言响应位置）。</li>
<li>Cookie被忽略（因此模板是无状态的）。</li>
</ul>
<p><code>TestRestTemplate</code> 可以直接在集成测试中实例化，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> TestRestTemplate template = <span class="keyword">new</span> TestRestTemplate();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		HttpHeaders headers = <span class="keyword">this</span>.template</span><br><span class="line">            .getForEntity(<span class="string">"http://myhost.example.com/example"</span>, String.class)</span><br><span class="line">            .getHeaders();</span><br><span class="line">		assertThat(headers.getLocation()).hasHost(<span class="string">"other.example.com"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，如果您使用或使用<code>@SpringBootTest</code>注释 ，则可以注入完全配置并开始使用它。如有必要，可以通过bean 应用其他自定义。任何未指定主机和端口的URL都会自动连接到嵌入式服务器，<code>WebEnvironment.RANDOM_PORT</code> <code>WebEnvironment.DEFINED_PORT</code> <code>TestRestTemplate</code> <code>RestTemplateBuilder</code>如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleWebClientTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestRestTemplate template;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		HttpHeaders headers = <span class="keyword">this</span>.template.getForEntity(<span class="string">"/example"</span>, String.class)</span><br><span class="line">				.getHeaders();</span><br><span class="line">		assertThat(headers.getLocation()).hasHost(<span class="string">"other.example.com"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@TestConfiguration</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">					.setReadTimeout(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><a class="button-hover more" href="/2019/03/21/使用SpringBott-test/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-JMX的监测和管理/">使用SpringBoot-JMX的监测和管理</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/jmx/">jmx</a></div></div><div class="post-content"><div class="main-content content"><h1 id="对JMX的监测和管理"><a href="#对JMX的监测和管理" class="headerlink" title="对JMX的监测和管理"></a>对JMX的监测和管理</h1><p>Java Management Extensions（JMX）提供了一种监视和管理应用程序的标准机制。Spring Boot公开了最适合<code>MBeanServer</code>作为ID为的bean <code>mbeanServer</code>。您的任何豆被标注有春天JMX注释（ <code>@ManagedResource</code>，<code>@ManagedAttribute</code>，或<code>@ManagedOperation</code>）接触到它。</p>
<p>如果您的平台提供标准<code>MBeanServer</code>，Spring Boot将使用它，并<code>MBeanServer</code>在必要时默认使用VM 。如果全部失败，<code>MBeanServer</code>将创建一个新的。</p>
<p>有关详细信息，请参阅 课程<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java" target="_blank" rel="noopener"><code>JmxAutoConfiguration</code></a>。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-JMX的监测和管理/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-Integration和Session/">使用SpringBoot-Integration和Session</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/integration/">integration</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/session/">session</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Spring-Integration-整合"><a href="#Spring-Integration-整合" class="headerlink" title="Spring Integration(整合)"></a>Spring Integration(整合)</h1><p>Spring Boot为使用<a href="https://projects.spring.io/spring-integration/" target="_blank" rel="noopener">Spring Integration</a>提供了一些便利，包括<code>spring-boot-starter-integration</code>“Starter”。Spring Integration提供了有关消息传递以及其他传输（如HTTP，TCP等）的抽象。如果类路径上有Spring Integration，则通过<code>@EnableIntegration</code>注释初始化它。</p>
<p>Spring Boot还配置了一些由于存在其他Spring Integration模块而触发的功能。如果<code>spring-integration-jmx</code>也在类路径上，则通过JMX发布消息处理统计信息。如果<code>spring-integration-jdbc</code>可用，则可以在启动时创建默认数据库模式，如以下行所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.integration.jdbc.initialize-schema = always</span><br></pre></td></tr></table></figure>
<p>有关 详细信息，请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java" target="_blank" rel="noopener"><code>IntegrationAutoConfiguration</code></a> 和<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java" target="_blank" rel="noopener"><code>IntegrationProperties</code></a>类。</p>
<p>默认情况下，如果存在千分尺<code>meterRegistry</code>bean，则由Micrometer管理Spring Integration指标。如果您希望使用旧版Spring Integration度量标准，请将<code>DefaultMetricsFactory</code>bean 添加到应用程序上下文中。</p>
<h1 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h1><p>Spring Boot为各种数据存储提供<a href="https://projects.spring.io/spring-session/" target="_blank" rel="noopener">Spring Session</a>自动配置。构建Servlet Web应用程序时，可以自动配置以下存储：</p>
<ul>
<li>JDBC</li>
<li>Redis</li>
<li>Hazelcast</li>
<li>MongoDB</li>
</ul>
<p>构建响应式Web应用程序时，可以自动配置以下存储：</p>
<ul>
<li>Redis</li>
<li>MongoDB</li>
</ul>
<p>如果类路径上存在单个Spring Session模块，则Spring Boot会自动使用该存储实现。如果您有多个实现，则必须选择<a href="https://github.com/spring-projects/spring-boot/tree/v2.1.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/session/StoreType.java" target="_blank" rel="noopener"><code>StoreType</code></a>要用于存储会话的实现。例如，要使用JDBC作为后端存储，您可以按如下方式配置应用程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.store-type=jdbc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您可以通过设置禁用春季会议<code>store-type</code>到<code>none</code>。</p>
</blockquote>
<p>每个商店都有特定的附加设置。例如，可以为JDBC存储定制表的名称，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.session.jdbc.table-name=SESSIONS</span><br></pre></td></tr></table></figure>
<p>要设置会话超时，可以使用该<code>spring.session.timeout</code>属性。如果未设置该属性，则自动配置将回退到值 <code>server.servlet.session.timeout</code>。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-Integration和Session/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/2019/03/21/使用SpringBoot-Quartz/">使用SpringBoot-Quartz</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2019-03-21</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/springboot/">springboot</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/quartz/">quartz</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/schedul/">schedul</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/task/">task</a></div></div><div class="post-content"><div class="main-content content"><h1 id="Quartz-Scheduler"><a href="#Quartz-Scheduler" class="headerlink" title="Quartz Scheduler"></a>Quartz Scheduler</h1><p>Spring Boot为使用<a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">Quartz调度程序</a>提供了一些便利 ，包括 <code>spring-boot-starter-quartz</code>“Starter”。如果Quartz可用，<code>Scheduler</code>则自动配置a（通过<code>SchedulerFactoryBean</code>抽象）。</p>
<p>自动拾取以下类型的豆并与以下相关联 <code>Scheduler</code>：</p>
<ul>
<li><code>JobDetail</code>：定义一个特定的Job。<code>JobDetail</code>可以使用<code>JobBuilder</code>API 构建实例 。</li>
<li><code>Calendar</code>。</li>
<li><code>Trigger</code>：定义何时触发特定作业。</li>
</ul>
<p>默认情况下，使用内存<code>JobStore</code>。但是，如果<code>DataSource</code>应用程序中有bean可用，并且相应地<code>spring.quartz.job-store-type</code>配置了 属性，则可以配置基于JDBC的存储，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.job-store-type=jdbc</span><br></pre></td></tr></table></figure>
<p>使用JDBC存储时，可以在启动时初始化模式，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.quartz.jdbc.initialize-schema=always</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，使用Quartz库提供的标准脚本检测并初始化数据库。这些脚本删除现有表，在每次重启时删除所有触发器。也可以通过设置<code>spring.quartz.jdbc.schema</code>属性来提供自定义脚本 。</p>
</blockquote>
<p>要让Quartz使用<code>DataSource</code>除应用程序main之外的其他东西<code>DataSource</code>，请声明一个<code>DataSource</code>bean，用它来注释其<code>@Bean</code>方法<code>@QuartzDataSource</code>。这样做可确保 架构初始化和架构初始化<code>DataSource</code>都使用Quartz特定的<code>SchedulerFactoryBean</code>。</p>
<p>默认情况下，配置创建的作业不会覆盖已从永久性作业存储读取的已注册作业。要启用覆盖现有作业定义，请设置该<code>spring.quartz.overwrite-existing-jobs</code>属性。</p>
<p>可以使用<code>spring.quartz</code>属性和 <code>SchedulerFactoryBeanCustomizer</code>bean 自定义Quartz Scheduler配置，这允许进行编程<code>SchedulerFactoryBean</code> 自定义。可以使用高级Quartz配置属性进行自定义 <code>spring.quartz.properties.*</code>。</p>
<blockquote>
<p>特别是，<code>Executor</code>bean不与调度程序相关联，因为Quartz提供了一种通过配置调度程序的方法<code>spring.quartz.properties</code>。如果需要自定义任务执行程序，请考虑实现<code>SchedulerFactoryBeanCustomizer</code>。</p>
</blockquote>
<p>作业可以定义setter以注入数据映射属性。也可以以类似的方式注入常规bean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Inject "MyService" bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Inject the "name" job data property</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="任务执行和调度"><a href="#任务执行和调度" class="headerlink" title="任务执行和调度"></a>任务执行和调度</h1><p>在<code>Executor</code>上下文中没有bean的情况下，Spring Boot会自动配置一个 <code>ThreadPoolTaskExecutor</code>合理的默认值，这些默认值可以自动关联到异步任务执行（<code>@EnableAsync</code>）和Spring MVC异步请求处理。</p>
<blockquote>
<p>如果您<code>Executor</code>在上下文中定义了自定义，则常规任务执行（即 <code>@EnableAsync</code>）将透明地使用它，但不会配置Spring MVC支持，因为它需要<code>AsyncTaskExecutor</code>实现（命名 <code>applicationTaskExecutor</code>）。根据您的目标安排，您可以将您更改 <code>Executor</code>为a <code>ThreadPoolTaskExecutor</code>或定义a <code>ThreadPoolTaskExecutor</code>和<code>AsyncConfigurer</code>包装自定义<code>Executor</code>。</p>
<p>自动配置<code>TaskExecutorBuilder</code>允许您轻松创建实例，以重现默认情况下自动配置的功能。</p>
</blockquote>
<p>线程池使用8个核心线程，可根据负载增长和缩小。可以使用<code>spring.task.execution</code>命名空间对这些默认设置进行微调，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.task.execution.pool.max-threads=16</span><br><span class="line">spring.task.execution.pool.queue-capacity=100</span><br><span class="line">spring.task.execution.pool.keep-alive=10s</span><br></pre></td></tr></table></figure>
<p>这会将线程池更改为使用有界队列，以便在队列满（100个任务）时，线程池增加到最多16个线程。当线程在闲置10秒（而不是默认为60秒）时回收线程时，池的收缩会更加激进。</p>
<p><code>ThreadPoolTaskScheduler</code>如果需要与计划任务执行（<code>@EnableScheduling</code>）相关联，也可以自动配置A. 默认情况下，线程池使用一个线程，并且可以使用<code>spring.task.scheduling</code>命名空间对这些设置进行微调。</p>
<p>既是<code>TaskExecutorBuilder</code>豆和<code>TaskSchedulerBuilder</code>绿豆可在上下文提供如果自定义遗嘱执行人或调度需要创建。</p>
</div></div><a class="button-hover more" href="/2019/03/21/使用SpringBoot-Quartz/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-angle-right"></i></a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2019 By YoungDream</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/clicklove.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>